-- update database FROM version 200108 to 200109

BEGIN TRANSACTION  --( will be rolled back if wrong version#

-------------------------------------------------------------------------------
-- Recreate CreateDeleteObj. Somehow the one in 200107To200108 didn't have
-- the right version of the stored procedure. <sigh> Even if it did, the
-- command line doesn't like double quotes. Had to change the dynamic SQL
-- to use the stinkin' ugly square brackets.
-------------------------------------------------------------------------------

IF OBJECT_ID('CreateDeleteObj') IS NOT NULL BEGIN
	PRINT 'removing procedure CreateDeleteObj'
	DROP PROC CreateDeleteObj
END
GO
PRINT 'creating procedure CreateDeleteObj'
GO

CREATE PROCEDURE CreateDeleteObj
	@nClassId INT
AS
	DECLARE
		@nvcObjClassName NVARCHAR(100),
		@nvcClassName NVARCHAR(100),
		@nFieldId INT,
		@nvcFieldName NVARCHAR(100),
		@nvcProcName NVARCHAR(120),  --( max possible size + a couple spare
		@nvcQuery1 VARCHAR(4000), --( 4000's not big enough; need more than 1 string
		@nvcQuery2 VARCHAR(4000),
		@nvcQuery3 VARCHAR(4000),
		@nvcQuery4 VARCHAR(4000),
		@fBuildProc BIT, --( Currently all tables are getting one
		@nvcDropQuery NVARCHAR(140),
		@nvcObjName NVARCHAR(100),
		@nOwnedClassId INT,
		@nDebug TINYINT

	SET @nDebug = 0

	SELECT @nvcObjClassName = c.Name FROM Class$ c WHERE c.Id = @nClassId

	SET @fBuildProc = 0
	SET @nvcProcName = N'TR_' + @nvcObjClassName + N'_ObjDel_Del'
	SET @nvcQuery1 = ''
	SET @nvcQuery2 = ''
	SET @nvcQuery3 = ''
	SET @nvcQuery4 = ''

	--( The initial part of the CREATE TRIGGER command
	IF OBJECT_ID(@nvcProcName) IS NULL
		SET @nvcQuery1 = N'CREATE'
	ELSE
		SET @nvcQuery1 = N'ALTER'

	--( This assumes only one ID (row) in deleted

	SET @nvcQuery1 = @nvcQuery1 +
		N' TRIGGER ' + @nvcProcName + N' ON ' + @nvcObjClassName + CHAR(13) +
		N'INSTEAD OF DELETE ' + CHAR(13) +
		N'AS ' + CHAR(13)
	IF @nDebug = 1
		SET @nvcQuery1 = @nvcQuery1 +
			CHAR(9) + N'PRINT ''TRIGGER ' + @nvcProcName +
				N' ON ' + @nvcObjClassName + N' INSTEAD OF DELETE ''' + CHAR(13) +
			CHAR(9) + CHAR(13)
	SET @nvcQuery1 = @nvcQuery1 +
		CHAR(9) + N'/* == This trigger generated by CreateDeleteObj == */ ' + CHAR(13) +
		CHAR(9) + CHAR(13) +
		CHAR(9) + N'DECLARE @nObjId INT ' + CHAR(13) +
		CHAR(9) + N'SELECT @nObjId = d.[Id] FROM deleted d' + CHAR(13) +
		CHAR(9) + CHAR(13)

	--==( Delete references *to* this object )==--

	--( atomic references to this object

	SELECT TOP 1 @nFieldId = f.Id, @nvcClassName = c.Name, @nvcFieldName = f.Name
	FROM Field$ f
	JOIN Class$ c ON c.Id = f.Class
	WHERE f.DstCls = @nClassId AND f.Type = 24
	ORDER BY f.Id

	IF @@ROWCOUNT != 0 BEGIN
		SET @fBuildProc = 1
		SET @nvcQuery1 = @nvcQuery1 + CHAR(9) +
			'/* Delete atomic references *to* this object */ ' + CHAR(13) +
			CHAR(9) + CHAR(13)
	END
	WHILE @@ROWCOUNT != 0 BEGIN
		SET @nvcQuery1 = @nvcQuery1 +
			CHAR(9) + N'UPDATE ' + @nvcClassName + N' WITH (SERIALIZABLE) ' + CHAR(13) +
			CHAR(9) + N'SET [' + @nvcFieldName + N'] = NULL ' + CHAR(13) +
			CHAR(9) + N'WHERE [' + @nvcFieldName + N'] = @nObjId ' + CHAR(13) +
			CHAR(9) + CHAR(13)

		SELECT TOP 1 @nFieldId = f.Id, @nvcClassName = c.Name, @nvcFieldName = f.Name
		FROM Field$ f
		JOIN Class$ c ON c.Id = f.Class
		WHERE f.Id > @nFieldId AND f.DstCls = @nClassId AND f.Type = 24
		ORDER BY f.Id
	END

	--( collection and sequence refences

	SELECT TOP 1 @nFieldId = f.Id, @nvcClassName = c.Name, @nvcFieldName = f.Name
	FROM Field$ f
	JOIN Class$ c ON c.Id = f.Class
	WHERE f.DstCls = @nClassId AND f.Type IN (26, 28)
	ORDER BY f.Id

	IF @@ROWCOUNT != 0 BEGIN
		SET @fBuildProc = 1
		SET @nvcQuery2 = @nvcQuery2 + CHAR(9) +
			'/* Delete collection and sequence references *to* this object */ ' + CHAR(13) +
			CHAR(9) + CHAR(13)
	END
	WHILE @@ROWCOUNT != 0 BEGIN
		SET @nvcQuery2 = @nvcQuery2 +
			CHAR(9) + N'DELETE ' + @nvcClassName + N'_' + @nvcFieldName + N' WITH (SERIALIZABLE) ' + CHAR(13) +
			CHAR(9) + N'WHERE [Dst] = @nObjId ' + CHAR(13) +
			CHAR(9) + CHAR(13)

		SELECT TOP 1 @nFieldId = f.Id, @nvcClassName = c.Name, @nvcFieldName = f.Name
		FROM Field$ f
		JOIN Class$ c ON c.Id = f.Class
		WHERE f.Id > @nFieldId AND f.DstCls = @nClassId AND f.Type IN (26, 28)
		ORDER BY f.Id
	END

	--==( Delete references *of* this object )==--

	--( Atomic references will get wiped out autmatically when this record
	--( goes away.

	--( Collection and Sequence refences

	SELECT TOP 1 @nFieldId = f.Id, @nvcClassName = c.Name, @nvcFieldName = f.Name
	FROM Field$ f
	JOIN Class$ c ON c.Id = f.Class
	WHERE f.Class = @nClassId AND f.Type IN (26, 28)
	ORDER BY f.Id

	IF @@ROWCOUNT != 0 BEGIN
		SET @fBuildProc = 1
		SET @nvcQuery3 = @nvcQuery3 + CHAR(9) +
			'/* Delete references *of* this object */ ' + CHAR(13) +
			CHAR(9) + CHAR(13)
	END
	WHILE @@ROWCOUNT != 0 BEGIN
		SET @nvcQuery3 = @nvcQuery3 +
			CHAR(9) + N'DELETE ' + @nvcClassName + N'_' + @nvcFieldName + N' WITH (SERIALIZABLE) ' + CHAR(13) +
			CHAR(9) + N'WHERE [Src] = @nObjId ' + CHAR(13) +
			CHAR(9) + CHAR(13)

		SELECT TOP 1 @nFieldId = f.Id, @nvcClassName = c.Name, @nvcFieldName = f.Name
		FROM Field$ f
		JOIN Class$ c ON c.Id = f.Class
		WHERE f.Id > @nFieldId AND f.Class = @nClassId AND f.Type IN (26, 28)
		ORDER BY f.Id
	END

	--==( Delete strings of this object )==--

	SET @nvcQuery4 = @nvcQuery4 +
		CHAR(9) + N'/* Delete any strings of this object */ ' + CHAR(13) +
		CHAR(9) + CHAR(13)

	--( If any MultiStr$ properties, create delete code.
	SELECT TOP 1 @nFieldId = Id FROM Field$ WHERE Class = @nClassId AND Type = 14
	IF @@ROWCOUNT != 0 BEGIN
		SET @fBuildProc = 1
		SET @nvcQuery4 = @nvcQuery4 +
			CHAR(9) + N'DELETE MultiStr$ WITH (SERIALIZABLE) ' + CHAR(13) +
			CHAR(9) + N'WHERE [Obj] = @nObjId ' + CHAR(13) +
			CHAR(9) + CHAR(13)
	END

	--( If any MultiTxt$ properties, create delete code.
	SELECT TOP 1 @nFieldId = f.ID, @nvcClassName = c.Name, @nvcFieldName = f.Name
	FROM Field$ f
	JOIN Class$ c ON c.ID = f.Class
	WHERE f.Class = @nClassId AND f.Type = 16
	ORDER BY f.Id

	WHILE @@ROWCOUNT != 0 BEGIN
		SET @fBuildProc = 1
		SET @nvcQuery4 = @nvcQuery4 +
			CHAR(9) + N'DELETE ' + @nvcClassName + N'_' + @nvcFieldName + N' WITH (SERIALIZABLE) ' + CHAR(13) +
			CHAR(9) + N'WHERE [Obj] = @nObjId ' + CHAR(13) +
			CHAR(9) + CHAR(13)

		SELECT TOP 1 @nFieldId = f.Id, @nvcClassName = c.Name, @nvcFieldName = f.Name
		FROM Field$ f
		JOIN Class$ c ON c.Id = f.Class
		WHERE f.ID > @nFieldId AND f.Class = @nClassId AND f.Type = 16
		ORDER BY f.Id
	END

	--( If any MultiBigStr$ properties, create delete code.

	SELECT TOP 1 @nFieldId = Id FROM Field$ WHERE Class = @nClassId AND Type = 18
	IF @@ROWCOUNT != 0 BEGIN
		SET @fBuildProc = 1
		SET @nvcQuery4 = @nvcQuery4 +
			CHAR(9) + N'DELETE MultiBigStr$ WITH (SERIALIZABLE) ' + CHAR(13) +
			CHAR(9) + N'WHERE [Obj] = @nObjId ' + CHAR(13) +
			CHAR(9) + CHAR(13)
	END

	--( If any MultiBigTxt$ properties, create delete code.

	SELECT TOP 1 @nFieldId = Id FROM Field$ WHERE Class = @nClassId AND Type = 20
	IF @@ROWCOUNT != 0 BEGIN
		SET @fBuildProc = 1
		SET @nvcQuery4 = @nvcQuery4 +
			CHAR(9) + N'DELETE MultiBigTxt$ WITH (SERIALIZABLE) ' + CHAR(13) +
			CHAR(9) + N'WHERE [Obj] = @nObjId ' + CHAR(13) +
			CHAR(9) + CHAR(13)
	END

	--==( Delete this row, since this is an DELETE INSTEAD OF trigger )==--

	SET @fBuildProc = 1
	SET @nvcQuery4 = @nvcQuery4 +
		CHAR(9) + N'/* Delete this row (for INSTEAD OF DELETE trigger) */ ' + CHAR(13) +
		CHAR(9) + CHAR(13)
	SET @nvcQuery4 = @nvcQuery4 +
		CHAR(9) + N'DELETE ' + @nvcObjClassName + N' WITH (SERIALIZABLE) ' + CHAR(13) +
		CHAR(9) + N'WHERE [Id] = @nObjId ' + CHAR(13) +
		CHAR(9) + CHAR(13)

	--==( Delete properties in parent class )==--

	--( This will delete properties *only* in the parent class,
	--( because the parent class will have the same call to
	--( delete properties in *its* parent class. The parent
	--( class has a depth of 1.

	SELECT @nvcClassName = c.Name
	FROM ClassPar$ cp
	JOIN Class$ c ON c.Id = cp.Dst
	WHERE cp.Src = @nClassId AND cp.Depth = 1

	IF @@ROWCOUNT = 1 BEGIN	--( should only be CmObject that misses
		SET @fBuildProc = 1
		SET @nvcQuery4 = @nvcQuery4 +
			CHAR(9) + N'/* Delete properties in parent class */' + CHAR(13) +
			CHAR(9) + CHAR(13)
		SET @nvcQuery4 = @nvcQuery4 +
			CHAR(9) + N'DELETE ' + @nvcClassName + N' WITH (SERIALIZABLE) ' + CHAR(13) +
			CHAR(9) + N'WHERE [Id] = @nObjId ' + CHAR(13) +
			CHAR(9) + CHAR(13)
	END

	--==( Create the new trigger )==--

	IF @fBuildProc = 1 BEGIN
		IF @nDebug = 1 BEGIN
			PRINT '---- query1 ----'
			PRINT @nvcQuery1
			PRINT CHAR(9) + '---- query2 ----'
			PRINT @nvcQuery2
			PRINT CHAR(9) + '---- query3 ----'
			PRINT @nvcQuery3
			PRINT CHAR(9) + '---- query4 ----'
			PRINT @nvcQuery4
		END

		EXECUTE (@nvcQuery1 + @nvcQuery2 + @nvcQuery3 + @nvcQuery4)
	END
GO

-------------------------------------------------------------------------------
-- Recreate DeleteObjects. I accounted for sending an XML *string* in the
-- former version, but not an XML doc handle in the form of an integer. <sigh>
-------------------------------------------------------------------------------

IF OBJECT_ID('DeleteObjects') IS NOT NULL BEGIN
	PRINT 'removing procedure DeleteObjects'
	DROP PROC DeleteObjects
END
GO
PRINT 'creating procedure DeleteObjects'
GO

CREATE PROCEDURE DeleteObjects
	@ntIds NTEXT = NULL,
	@nXmlIdsParam INT = NULL
AS
	DECLARE @tIds TABLE (ID INT, ClassName NVARCHAR(100), Level TINYINT)

	DECLARE
		@hXmlIds INT,
		@nRowCount INT,
		@nObjId INT,
		@nLevel INT,
		@nvcClassName NVARCHAR(100),
		@nvcSql NVARCHAR(1000),
		@nError INT

	SET @nError = 0

	IF (@ntIds IS NULL AND @nXmlIdsParam IS NULL) OR (@ntIds IS NOT NULL AND @nXmlIdsParam IS NOT NULL)
		GOTO Fail

	--==( Load Ids )==--

	--( If we're working with an XML doc:
	IF @nXmlIdsParam IS NOT NULL BEGIN
		INSERT INTO @tIds
		SELECT f.ID, c.Name, 0
		FROM OPENXML(@nXmlIdsParam, '/root/Obj') WITH (ID INT) f
		JOIN CmObject o ON o.ID = f.ID
		JOIN Class$ c ON c.ID = o.Class$
	END
	--( If we're working with an XML string:
	ELSE IF SUBSTRING(@ntIds, 1, 1) = '<' BEGIN
		EXECUTE sp_xml_preparedocument @hXmlIds OUTPUT, @ntIds

		INSERT INTO @tIds
		SELECT f.ID, f.ClassName, 0
		FROM dbo.fnGetIdsFromString(@ntIds, @hXmlIds) AS f

		EXECUTE sp_xml_removedocument @hXmlIds
	END
	--( If we're working with a comma delimited list
	ELSE
		INSERT INTO @tIds
		SELECT f.ID, f.ClassName, 0
		FROM dbo.fnGetIdsFromString(@ntIds, NULL) AS f

	--( Now find owned objects

	SET @nLevel = 1

	INSERT INTO @tIds
	SELECT o.ID, c.Name, @nLevel
	FROM @tIds t
	JOIN CmObject o ON o.Owner$ = t.Id
	JOIN Class$ c ON c.ID = o.Class$

	SET @nRowCount = @@ROWCOUNT
	WHILE @nRowCount != 0 BEGIN
		SET @nLevel = @nLevel + 1

		INSERT INTO @tIds
		SELECT o.ID, c.Name, @nLevel
		FROM @tIds t
		JOIN CmObject o ON o.Owner$ = t.Id
		JOIN Class$ c ON c.ID = o.Class$
		WHERE t.Level = @nLevel - 1

		SET @nRowCount = @@ROWCOUNT
	END
	SET @nLevel = @nLevel - 1

	--==( Delete objects )==--

	--( We're going to start out at the leaves and work
	--( toward the trunk.

	WHILE @nLevel >= 0	BEGIN

		SELECT TOP 1 @nObjId = t.ID, @nvcClassName = t.ClassName
		FROM @tIds t
		WHERE t.Level = @nLevel
		ORDER BY t.Id

		SET @nRowCount = @@ROWCOUNT
		WHILE @nRowCount = 1 BEGIN
			SET @nvcSql = N'DELETE ' + @nvcClassName + N' WHERE Id = @nObjectID'
			EXEC sp_executesql @nvcSql, N'@nObjectID INT', @nObjectId = @nObjId
			SET @nError = @@ERROR
			IF @nError != 0
				GOTO Fail

			SELECT TOP 1 @nObjId = t.ID, @nvcClassName = t.ClassName
			FROM @tIds t
			WHERE t.Id > @nobjId AND t.Level = @nLevel
			ORDER BY t.ID

			SET @nRowCount = @@ROWCOUNT
		END

		SET @nLevel = @nLevel - 1
	END

	RETURN 0

Fail:
	RETURN @nError
GO

-------------------------------------------------------------------------------
-- Wipe out the old DeleteObj$ with this stub. DeleteObj$ ought to be removed
-- completely from interface code at some point.
-------------------------------------------------------------------------------

if object_id('DeleteObj$') is not null begin
	print 'removing proc DeleteObj$'
	drop proc [DeleteObj$]
end
go
print 'creating proc DeleteObj$'
go
create proc [DeleteObj$]
	@objId int = null,
	@hXMLDocObjList int=null
as
	DECLARE @nvcId NVARCHAR(20)
	SET @nvcId = CONVERT(NVARCHAR(20), @objId)

	EXEC DeleteObjects @nvcId, @hXMLDocObjList
GO

-------------------------------------------------------------------------------
-- Change call to DeleteObjects in DeleteOwnSeq$
-------------------------------------------------------------------------------

if object_id('DeleteOwnSeq$') is not null begin
	print 'removing proc DeleteOwnSeq$'
	drop proc [DeleteOwnSeq$]
end
go
print 'creating proc DeleteOwnSeq$'
go
create proc [DeleteOwnSeq$]
	@SrcObjId int,
	@SrcFlid int,
	@ListStmp int,
	@StartObj int,
	@EndObj int = null
as
	declare @sTranName varchar(50)
	declare @StartOrd int, @EndOrd int
	declare @guid uniqueidentifier
	declare	@fIsNocountOn int, @Err int, @nTrnCnt int, @UpdStmp int,
		@nvcId NVARCHAR(20)

	DECLARE @tblIds TABLE (Id NVARCHAR(20))

	set @Err = 0

	set @fIsNocountOn = @@options & 512
	if @fIsNocountOn = 0 set nocount on

	-- determine if the procedure was called within a transaction; if yes then create a savepoint,
	--	otherwise create a transaction
	set @sTranName = 'DeleteOwnSeq$_' + convert(varchar(11), @@trancount)
	set @nTrnCnt = @@trancount
	if @nTrnCnt = 0 begin tran @sTranName
	else save tran @sTranName
	set @Err = @@error
	if @Err <> 0 begin
		raiserror('DeleteOwnSeq$: SQL Error %d; Unable to create a transaction', 16, 1, @Err)
		goto LFail
	end

	-- get the starting and ending ordinal values
	select	@StartOrd = [OwnOrd$]
	from	CmObject (repeatableread)
	where	[Owner$] = @SrcObjId
		and [OwnFlid$] = @SrcFlid
		and [Id] = @StartObj
	if @EndObj is null begin
		select	@EndOrd = max([OwnOrd$])
		from	CmObject (REPEATABLEREAD)
		where	[Owner$] = @SrcObjId
			and [OwnFlid$] = @SrcFlid
	end
	else begin
		select	@EndOrd = [OwnOrd$]
		from	CmObject (repeatableread)
		where	[Owner$] = @SrcObjId
			and [OwnFlid$] = @SrcFlid
			and [Id] = @EndObj
	end

	-- validate the parameters
	if @StartOrd is null begin
		raiserror('DeleteOwnSeq$: Unable to locate ordinal value in CmObject: SrcObjId(Owner$) = %d SrcFlid(OwnFlid$) = %d StartObj(Id) = %d',
				16, 1, @SrcObjId, @SrcFlid, @StartObj)
		set @Err = 51001
		goto LFail
	end
	if @EndOrd is null begin
		raiserror('DeleteOwnSeq$: Unable to locate ordinal value in CmObject: SrcObjId(Owner$) = %d SrcFlid(OwnFlid$) = %d EndObj(Id) = %d',
				16, 1, @SrcObjId, @SrcFlid, @EndObj)
		set @Err = 51002
		goto LFail
	end
	if @EndOrd < @StartOrd begin
		raiserror('DeleteOwnSeq$: The starting ordinal value %d is greater than the ending ordinal value %d in CmObject: SrcObjId(Owner$) = %d SrcFlid(OwnFlid$) = %d StartObj(Id) = %d EndObj(Id) = %d',
				16, 1, @StartOrd, @EndOrd, @SrcObjId, @SrcFlid, @StartObj, @EndObj)
		set @Err = 51004
		goto LFail
	end

	-- get the list of objects that are to be deleted and insert them into the ObjInfoTbl$ table
	--set @guid = newid()
	--insert into ObjInfoTbl$ with (rowlock) (uid, ObjId)
	--select	@guid, [Id]
	INSERT INTO @tblIds
	SELECT CONVERT(NVARCHAR(20), Id)
	from	CmObject with (REPEATABLEREAD)
	where	[Owner$] = @SrcObjId
		and [OwnFlid$] = @SrcFlid
		and [OwnOrd$] >= @StartOrd
		and [OwnOrd$] <= @EndOrd

	set @Err = @@error
	if @Err <> 0 begin
		raiserror('DeleteOwnSeq$: SQL Error %d; Unable to insert objects into the ObjInfoTbl$; SrcObjId(Owner$) = %d SrcFlid(OwnFlid$) = %d StartObj(Id) = %d EndObj(Id) = %d',
				16, 1, @Err, @SrcObjId, @SrcFlid, @StartObj, @EndObj)
		goto LFail
	end

	SELECT TOP 1 @nvcId FROM @tblIds ORDER BY Id
	WHILE @@ROWCOUNT != 0 BEGIN
		--exec @Err = DeleteObject$ @guid, null, 1
		EXEC DeleteObjects @nvcId
		SELECT TOP 1 @nvcId FROM @tblIds WHERE ID < @nvcId ORDER BY Id
	END
	if @Err <> 0 goto LFail

	if @nTrnCnt = 0 commit tran @sTranName

	-- if nocount was turned on turn it off
	if @fIsNocountOn = 0 set nocount off
	return 0

LFail:
	rollback tran @sTranName

	-- if nocount was turned on turn it off
	if @fIsNocountOn = 0 set nocount off
	return @Err
go

-------------------------------------------------------------------------------
-- The Field$ trigger needs to call CreateDeleteObj
-------------------------------------------------------------------------------

IF OBJECT_ID('TR_Field$_UpdateModel_InsLast') IS NOT NULL BEGIN
	PRINT 'removing trigger TR_Field$_UpdateModel_InsLast'
	DROP TRIGGER TR_Field$_UpdateModel_InsLast
END
GO
PRINT 'creating trigger TR_Field$_UpdateModel_InsLast'
GO

CREATE TRIGGER TR_Field$_UpdateModel_InsLast ON Field$ FOR INSERT
AS
	DECLARE
		@nErr INT,
		@nClassid INT,
		@nAbstract BIT,
		@nLoopLevel TINYINT,
		@fExit BIT

	DECLARE @tblSubclasses TABLE (ClassId INT, Abstract BIT, ClassLevel TINYINT)

	SELECT @nClassId = Class FROM inserted
	SET @nLoopLevel = 1

	--==( Outer loop: all the classes for the level )==--

	--( This insert is necessary for any subclasses. It also
	--( gets Class$.Abstract for updating the CreateObject_*
	--( stored procedure.

	INSERT INTO @tblSubclasses
	SELECT @nClassId, c.Abstract, @nLoopLevel
	FROM Class$ c
	WHERE c.Id = @nClassId

	--( Rebuild the delete trigger

	EXEC @nErr = CreateDeleteObj @nClassId
	IF @nErr <> 0 GOTO LFail

	--( Rebuild CreateObject_*

	SELECT @nAbstract = Abstract FROM @tblSubClasses
	IF @nAbstract != 1 BEGIN
		EXEC @nErr = DefineCreateProc$ @nClassId
		IF @nErr <> 0 GOTO LFail
	END

	SET @fExit = 0
	WHILE @fExit = 0 BEGIN

		--( Inner loop: update all classes subclassed from the previous
		--( set of classes.

		SELECT TOP 1 @nClassId = ClassId, @nAbstract = Abstract
		FROM @tblSubclasses
		WHERE ClassLevel = @nLoopLevel
		ORDER BY ClassId

		WHILE @@ROWCOUNT > 0 BEGIN

			--( Update the view

			EXEC @nErr = UpdateClassView$ @nClassId, 1
			IF @nErr <> 0 GOTO LFail

			--( Get next class

			SELECT TOP 1 @nClassId = ClassId, @nAbstract = Abstract
			FROM @tblSubclasses
			WHERE ClassLevel = @nLoopLevel AND ClassId > @nClassId
			ORDER BY ClassId
		END

		--( Load outer loop with next level
		SET @nLoopLevel = @nLoopLevel + 1

		INSERT INTO @tblSubclasses
		SELECT c.Id, c.Abstract, @nLoopLevel
		FROM @tblSubClasses sc
		JOIN Class$ c ON c.Base = sc.ClassId
		WHERE sc.ClassLevel = @nLoopLevel - 1

		IF @@ROWCOUNT = 0
			SET @fExit = 1
	END

	RETURN

LFail:
	ROLLBACK TRANSACTION
	RETURN

GO

EXEC sp_settriggerorder 'TR_Field$_UpdateModel_InsLast', 'last', 'INSERT'
GO

-------------------------------------------------------------------------------
-- The Class$ trigger needs to call CreateDeleteObj
-------------------------------------------------------------------------------

IF OBJECT_ID('TR_Class$_InsLast') IS NOT NULL BEGIN
	PRINT 'removing trigger TR_Class$_InsLast'
	DROP TRIGGER TR_Class$_InsLast
END
GO
PRINT 'creating trigger TR_Class$_InsLast'
GO

CREATE TRIGGER TR_Class$_InsLast ON Class$ FOR INSERT
AS
	DECLARE
		@nErr INT,
		@nClassid INT,
		@nAbstract BIT

	SELECT @nClassId = Id, @nAbstract = Abstract FROM inserted

	--( Build the CreateObject_ stored procedure
	IF @nAbstract = 0 BEGIN
		EXEC @nErr = DefineCreateProc$ @nClassId
		IF @nErr <> 0 GOTO LFail
	END

	--( Build the delete trigger
	EXEC @nErr = CreateDeleteObj @nClassId
	IF @nErr <> 0 GOTO LFail

	RETURN

LFail:
	ROLLBACK TRANSACTION
	RETURN
GO


EXEC sp_settriggerorder 'TR_Class$_InsLast', 'last', 'INSERT'
GO

-------------------------------------------------------------------------------
-- Create all the new triggers we'll need
-------------------------------------------------------------------------------

BEGIN
	PRINT 'Creating delete triggers...'
	DECLARE	@nClassId INT
	--( First class
	SELECT TOP 1 @nClassId = Id FROM Class$ ORDER BY Id
	WHILE @@ROWCOUNT != 0 BEGIN
		EXEC CreateDeleteObj @nClassId
		--( Next class
		SELECT TOP 1 @nClassId = Id FROM Class$ WHERE Id > @nClassId ORDER BY Id
	END
END
GO

-------------------------------------------------------------------------------
-- Finish or roll back transaction as applicable
-------------------------------------------------------------------------------

declare @dbVersion int
SELECT @dbVersion = DbVer FROM Version$
if @dbVersion = 200108
begin
	UPDATE Version$ SET DbVer = 200109
	COMMIT TRANSACTION
	print 'database updated to version 200109'
end
else
begin
	ROLLBACK TRANSACTION
	print 'Update aborted: this works only if DbVer = 200108 (DbVer = ' +
			convert(varchar, @dbVersion) + ')'
end
GO
