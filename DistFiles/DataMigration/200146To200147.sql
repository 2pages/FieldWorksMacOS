-- update database FROM version 200146 to 200147
BEGIN TRANSACTION  --( will be rolled back if wrong version#)

-------------------------------------------------------------------------------
-- Fixed numerous problems discovered between migrated db from v1 and
-- current versions.
-------------------------------------------------------------------------------

-- Fix this stored procedure to produce a longer query (needed with ANSQ migrated DB)
IF OBJECT_ID('CreateGetRefsToObj') IS NOT NULL BEGIN
	PRINT 'removing procedure CreateGetRefsToObj'
	DROP PROCEDURE CreateGetRefsToObj
END
GO
PRINT 'creating procedure CreateGetRefsToObj'
GO

CREATE PROCEDURE CreateGetRefsToObj
AS
	DECLARE
		@fDebug BIT,
		@nFieldId INT,
		@nDstCls INT,
		@nDstCls2 INT,
		@nvcClassName NVARCHAR(100),
		@nvcFieldName NVARCHAR(100),
		@nFieldClass INT,
		@nFieldType INT,
		@nvcProcName NVARCHAR(120),  --( max possible size + a couple spare
		@nvcQ VARCHAR(4000),
		@nvcQuery1 VARCHAR(4000), --( 4000's not big enough; need more than 1 string
		@nvcQuery2 VARCHAR(4000),
		@nvcQuery3 VARCHAR(4000),
		@nvcQuery4 VARCHAR(4000),
		@nvcQuery5 VARCHAR(4000),
		@nvcQuery6 VARCHAR(4000),
		@nvcQuery7 VARCHAR(4000),
		@nvcQuery8 VARCHAR(4000),
		@nvcQuery9 VARCHAR(4000),
		@nvcQuery10 VARCHAR(4000),
		@nvcQuery11 VARCHAR(4000),
		@nvcQuery12 VARCHAR(4000),
		@nvcQuery13 VARCHAR(4000),
		@nvcQuery14 VARCHAR(4000),
		@nvcQuery15 VARCHAR(4000),
		@nFetchStatus BIT,
		@fFirstIf BIT,
		@nError INT

	SET @fDebug = 0 --( 0 produces stored procedure, 1 produces print
	SET @nvcQ = ''
	SET @nvcQuery1 = ''
	SET @nvcQuery2 = ''
	SET @nvcQuery3 = ''
	SET @nvcQuery4 = ''
	SET @nvcQuery5 = ''
	SET @nvcQuery6 = ''
	SET @nvcQuery7 = ''
	SET @nvcQuery8 = ''
	SET @nvcQuery9 = ''
	SET @nvcQuery10 = ''
	SET @nvcQuery11 = ''
	SET @nvcQuery12 = ''
	SET @nvcQuery13 = ''
	SET @nvcQuery14 = ''
	SET @nvcQuery15 = ''
	set @nError = 0

	--( Loop for subclasses

	IF OBJECT_ID('fnGetRefsToObj') IS NULL
		SET @nvcQuery1 = N'CREATE FUNCTION fnGetRefsToObj (' + CHAR(13)
	ELSE
		SET @nvcQuery1 = N'ALTER FUNCTION fnGetRefsToObj (' + CHAR(13)

	SET @nvcQuery1 = @nvcQuery1 +
		CHAR(9) + N'@nObjId INT, ' + CHAR(13) +
		CHAR(9) + N'@nClassId INT = NULL) ' + CHAR(13) +
		N'RETURNS @tblR TABLE ( ' + CHAR(13) +
		CHAR(9) + N'ObjId INT, ' + CHAR(13) +
		CHAR(9) + N'ObjClass INT, ' + CHAR(13) +
		CHAR(9) + N'ClassLevel INT, ' + CHAR(13) +
		CHAR(9) + N'ObjLevel INT, ' + CHAR(13) +
		CHAR(9) + N'RefObjId INT, ' + CHAR(13) +
		CHAR(9) + N'RefObjClass INT, ' + CHAR(13) +
		CHAR(9) + N'RefObjField INT, ' + CHAR(13) +
		CHAR(9) + N'RefObjFieldOrder INT, ' + CHAR(13) +
		CHAR(9) + N'RefObjFieldType INT) ' + CHAR(13) +
		N'AS BEGIN ' + CHAR(13) +
		CHAR(13) +
		N'/* == This function generated by CreateGetRefsToObj == */ ' + CHAR(13) +
		CHAR(13) +
		N'DECLARE @nDst INT, @nFetchStatus INT, @nObjLevel INT, @nClassLevel INT;' + CHAR(13) +
		N'DECLARE @tblO TABLE (Id INT, ObjLevel INT, Class INT, ClassLevel INT)' + CHAR(13) +
		N'IF @nClassId IS NULL ' + CHAR(13) +
		CHAR(9) + 'SELECT @nClassId = Class$ FROM CmObject WHERE [ID] = @nObjId' + CHAR(13) +
		CHAR(13) +
		N'/* Get Owned objects */ ' + CHAR(13) +
		N'SET @nObjLevel = 1;'  + CHAR(13) +
		N'INSERT INTO @tblO (ID, ObjLevel, Class, ClassLevel)' + CHAR(13) +
		CHAR(9) + N'VALUES (@nObjId, @nObjLevel, @nClassId, 0)' + CHAR(13) +
		N'WHILE @@ROWCOUNT != 0 BEGIN' + CHAR(13) +
		CHAR(9) + N'SET @nObjLevel = @nObjLevel + 1;' + CHAR(13) +
		CHAR(9) + N'INSERT INTO @tblO' + CHAR(13) +
		CHAR(9) + CHAR(9) + N'SELECT co.Id, @nObjLevel, co.Class$, 0' +CHAR(13) +
		CHAR(9) + CHAR(9) + N'FROM @tblO t ' + CHAR(13) +
		CHAR(9) + CHAR(9) + N'JOIN CmObject co ON co.Owner$ = t.Id' + CHAR(13) +
		CHAR(9) + CHAR(9) + N'WHERE t.ObjLevel = @nObjLevel - 1;' + CHAR(13) +
		N'END;' + CHAR(13) +
		CHAR(13) +
		N'/* Get super classes of the objects */ ' + CHAR(13) +
		N'INSERT INTO @tblO' + CHAR(13) +
		N'SELECT o.Id, o.ObjLevel, cp.dst, cp.Depth' + CHAR(13) +
		N'FROM @tblO o' + CHAR(13) +
		N'JOIN ClassPar$ cp ON cp.Src = o.Class' + CHAR(13) +
		N'WHERE cp.Depth != 0' + CHAR(13) +
		CHAR(13) +
		N'/* Now get references to them */ ' + CHAR(13) +
		N'DECLARE curClassDepth CURSOR ' + CHAR(13) +
		CHAR(9) + N'FOR SELECT Id, Class, ClassLevel, ObjLevel - 1 FROM @tblO '  + CHAR(13) +
		N'OPEN curClassDepth;' + CHAR(13) +
		N'FETCH NEXT FROM curClassDepth INTO @nObjId, @nDst, @nClassLevel, @nObjLevel;' + CHAR(13) +
		N'SET @nFetchStatus = @@FETCH_STATUS;' + CHAR(13) +
		N'WHILE @nFetchStatus = 0 BEGIN ' + CHAR(13)

	DECLARE curRefs CURSOR LOCAL STATIC FORWARD_ONLY READ_ONLY FOR
		SELECT f.Id, f.Class, f.DstCls, c.Name AS ClassName, f.Name AS FieldName, f.Type
		FROM Field$ f
		JOIN Class$ c ON c.Id = f.Class
		WHERE f.Type IN (24, 26, 28)
		ORDER BY f.DstCls, f.Id

	SET @nDstCls2 = 987654321	--( bogus ID
	SET @fFirstIf = 1

	OPEN curRefs
	FETCH curRefs INTO @nFieldId, @nFieldClass, @nDstCls, @nvcClassName, @nvcFieldName, @nFieldType
	SET @nFetchStatus = @@FETCH_STATUS
	WHILE @nFetchStatus = 0 BEGIN
		--( Create an IF block for a particular class

		IF @nDstCls != @nDstCls2 BEGIN
			SET @nvcQ = CHAR(9)
			IF @fFirstIf = 0
				SET @nvcQ = @nvcQ + N'ELSE '
			SET @nvcQ = @nvcQ + N'IF @nDst = ' + CONVERT(NVARCHAR(10), @nDstCls) + N' BEGIN ' + CHAR(13)
			SET @nDstCls2 = @nDstCls
		END

		IF LEN(@nvcQuery1) < 3750
			SET @nvcQuery1 = @nvcQuery1 + @nvcQ
		ELSE IF LEN(@nvcQuery2) < 3750
			SET @nvcQuery2 = @nvcQuery2 + @nvcQ
		ELSE IF LEN(@nvcQuery3) < 3750
			SET @nvcQuery3 = @nvcQuery3 + @nvcQ
		ELSE IF LEN(@nvcQuery4) < 3750
			SET @nvcQuery4 = @nvcQuery4 + @nvcQ
		ELSE IF LEN(@nvcQuery5) < 3750
			SET @nvcQuery5 = @nvcQuery5 + @nvcQ
		ELSE IF LEN(@nvcQuery6) < 3750
			SET @nvcQuery6 = @nvcQuery6 + @nvcQ
		ELSE IF LEN(@nvcQuery7) < 3750
			SET @nvcQuery7 = @nvcQuery7 + @nvcQ
		ELSE IF LEN(@nvcQuery8) < 3750
			SET @nvcQuery8 = @nvcQuery8 + @nvcQ
		ELSE IF LEN(@nvcQuery9) < 3750
			SET @nvcQuery9 = @nvcQuery9 + @nvcQ
		ELSE IF LEN(@nvcQuery10) < 3750
			SET @nvcQuery10 = @nvcQuery10 + @nvcQ
		ELSE IF LEN(@nvcQuery11) < 3750
			SET @nvcQuery11 = @nvcQuery11 + @nvcQ
		ELSE IF LEN(@nvcQuery12) < 3750
			SET @nvcQuery12 = @nvcQuery12 + @nvcQ
		ELSE IF LEN(@nvcQuery13) < 3750
			SET @nvcQuery13 = @nvcQuery13 + @nvcQ
		ELSE IF LEN(@nvcQuery14) < 3750
			SET @nvcQuery14 = @nvcQuery14 + @nvcQ
		ELSE IF LEN(@nvcQuery15) < 3750
			SET @nvcQuery15 = @nvcQuery15 + @nvcQ

		--( Cycle through the classes that refer to this one.

		WHILE @nDstCls2 = @nDstCls AND @nFetchStatus = 0 BEGIN
			IF @nFieldType = 24
				SET @nvcQ =
					CHAR(9) + CHAR(9) + N'INSERT INTO @tblR ' + CHAR(13) +
					CHAR(9) + CHAR(9) + CHAR(9) + N'SELECT @nObjId, @nDst, @nClassLevel, @nObjLevel, r.[Id], '
						+ CONVERT(NVARCHAR(10), @nFieldClass) + N', ' +
						+ CONVERT(NVARCHAR(10), @nFieldId) +
						+ N', NULL, '
						+ CONVERT(NVARCHAR(10), @nFieldType) + CHAR(13) +
					CHAR(9) + CHAR(9) + CHAR(9) + N'FROM [' + @nvcClassName + N'] r ' + CHAR(13) +
					CHAR(9) + CHAR(9) + CHAR(9) + N'LEFT OUTER JOIN @tblO o ON o.[Id] = r.[Id] ' + CHAR(13) +
					CHAR(9) + CHAR(9) + CHAR(9) + N'WHERE r.[' + @nvcFieldName + N'] = @nObjId ' +
					N'AND o.[Id] IS NULL;' + CHAR(13)
			ELSE BEGIN
				SET @nvcQ =
					CHAR(9) + CHAR(9) + N'INSERT INTO @tblR ' + CHAR(13) +
					CHAR(9) + CHAR(9) + CHAR(9) + N'SELECT @nObjId, @nDst, @nClassLevel, @nObjLevel, r.Src, ' +
					+ CONVERT(NVARCHAR(10), @nFieldClass) + N', ' +
					+ CONVERT(NVARCHAR(10), @nFieldId)

				IF @nFieldType = 26
					SET @nvcQ = @nvcQ + N', NULL, '
				ELSE
					SET @nvcQ = @nvcQ + N', r.Ord, '

				SET @nvcQ = @nvcQ +
					CONVERT(NVARCHAR(10), @nFieldType) + CHAR(13) +
					CHAR(9) + CHAR(9) + CHAR(9) + N'FROM ' + @nvcClassName + N'_' + @nvcFieldName + N' r ' + CHAR(13) +
					CHAR(9) + CHAR(9) + CHAR(9) + N'LEFT OUTER JOIN @tblO o ON o.Id = r.Src ' + CHAR(13) +
					CHAR(9) + CHAR(9) + CHAR(9) + N'WHERE r.Dst = @nObjId AND o.Id IS NULL;' + CHAR(13)
			END
			IF LEN(@nvcQuery1) < 3750
				SET @nvcQuery1 = @nvcQuery1 + @nvcQ
			ELSE IF LEN(@nvcQuery2) < 3750
				SET @nvcQuery2 = @nvcQuery2 + @nvcQ
			ELSE IF LEN(@nvcQuery3) < 3750
				SET @nvcQuery3 = @nvcQuery3 + @nvcQ
			ELSE IF LEN(@nvcQuery4) < 3750
				SET @nvcQuery4 = @nvcQuery4 + @nvcQ
			ELSE IF LEN(@nvcQuery5) < 3750
				SET @nvcQuery5 = @nvcQuery5 + @nvcQ
			ELSE IF LEN(@nvcQuery6) < 3750
				SET @nvcQuery6 = @nvcQuery6 + @nvcQ
			ELSE IF LEN(@nvcQuery7) < 3750
				SET @nvcQuery7 = @nvcQuery7 + @nvcQ
			ELSE IF LEN(@nvcQuery8) < 3750
				SET @nvcQuery8 = @nvcQuery8 + @nvcQ
			ELSE IF LEN(@nvcQuery9) < 3750
				SET @nvcQuery9 = @nvcQuery9 + @nvcQ
			ELSE IF LEN(@nvcQuery10) < 3750
				SET @nvcQuery10 = @nvcQuery10 + @nvcQ
			ELSE IF LEN(@nvcQuery11) < 3750
				SET @nvcQuery11 =@nvcQuery11 + @nvcQ
			ELSE IF LEN(@nvcQuery12) < 3750
				SET @nvcQuery12 = @nvcQuery12 + @nvcQ
			ELSE IF LEN(@nvcQuery13) < 3750
				SET @nvcQuery13 = @nvcQuery13 + @nvcQ
			ELSE IF LEN(@nvcQuery14) < 3750
				SET @nvcQuery14 = @nvcQuery14 + @nvcQ
			ELSE IF LEN(@nvcQuery15) < 3750
				SET @nvcQuery15 = @nvcQuery15 + @nvcQ

			FETCH curRefs INTO @nFieldId, @nFieldClass, @nDstCls, @nvcClassName, @nvcFieldName, @nFieldType
			SET @nFetchStatus = @@FETCH_STATUS
		END

		--( Close out the if block
		IF LEN(@nvcQuery1) < 3750
			SET @nvcQuery1 = @nvcQuery1 + CHAR(9) + N'END;' + CHAR(13)
		ELSE IF LEN(@nvcQuery2) < 3750
			SET @nvcQuery2 = @nvcQuery2 + CHAR(9) + N'END;' + CHAR(13)
		ELSE IF LEN(@nvcQuery3) < 3750
			SET @nvcQuery3 = @nvcQuery3 + CHAR(9) + N'END;' + CHAR(13)
		ELSE IF LEN(@nvcQuery4) < 3750
			SET @nvcQuery4 = @nvcQuery4 + CHAR(9) + N'END;' + CHAR(13)
		ELSE IF LEN(@nvcQuery5) < 3750
			SET @nvcQuery5 = @nvcQuery5 + CHAR(9) + N'END;' + CHAR(13)
		ELSE IF LEN(@nvcQuery6) < 3750
			SET @nvcQuery6 = @nvcQuery6 + CHAR(9) + N'END;' + CHAR(13)
		ELSE IF LEN(@nvcQuery7) < 3750
			SET @nvcQuery7 = @nvcQuery7 + CHAR(9) + N'END;' + CHAR(13)
		ELSE IF LEN(@nvcQuery8) < 3750
			SET @nvcQuery8 = @nvcQuery8 + CHAR(9) + N'END;' + CHAR(13)
		ELSE IF LEN(@nvcQuery9) < 3750
			SET @nvcQuery9 = @nvcQuery9 + CHAR(9) + N'END;' + CHAR(13)
		ELSE IF LEN(@nvcQuery10) < 3750
			SET @nvcQuery10 = @nvcQuery10 + CHAR(9) + N'END;' + CHAR(13)
		ELSE IF LEN(@nvcQuery11) < 3750
			SET @nvcQuery11 = @nvcQuery11 + CHAR(9) + N'END;' + CHAR(13)
		ELSE IF LEN(@nvcQuery12) < 3750
			SET @nvcQuery12 = @nvcQuery12 + CHAR(9) + N'END;' + CHAR(13)
		ELSE IF LEN(@nvcQuery13) < 3750
			SET @nvcQuery13 = @nvcQuery13 + CHAR(9) + N'END;' + CHAR(13)
		ELSE IF LEN(@nvcQuery14) < 3750
			SET @nvcQuery14 = @nvcQuery14 + CHAR(9) + N'END;' + CHAR(13)
		ELSE IF LEN(@nvcQuery15) < 3750
			SET @nvcQuery15 = @nvcQuery15 + CHAR(9) + N'END;' + CHAR(13)

	END --( @@FETCH_STATUS = 0
	CLOSE curRefs
	DEALLOCATE curRefs

	SET @nvcQ =
		CHAR(9) + N'FETCH NEXT FROM curClassDepth INTO @nObjId, @nDst, @nClassLevel, @nObjLevel; ' + CHAR(13) +
		CHAR(9) + N'SET @nFetchStatus = @@FETCH_STATUS; ' + CHAR(13) +
		N'END; ' + CHAR(13) +
		N'RETURN; ' + CHAR(13) +
		N'END ' + CHAR(13)

	IF LEN(@nvcQuery1) < 3750
		SET @nvcQuery1 = @nvcQuery1 + @nvcQ
	ELSE IF LEN(@nvcQuery2) < 3750
		SET @nvcQuery2 = @nvcQuery2 + @nvcQ
	ELSE IF LEN(@nvcQuery3) < 3750
		SET @nvcQuery3 = @nvcQuery3 + @nvcQ
	ELSE IF LEN(@nvcQuery4) < 3750
		SET @nvcQuery4 = @nvcQuery4 + @nvcQ
	ELSE IF LEN(@nvcQuery5) < 3750
		SET @nvcQuery5 = @nvcQuery5 + @nvcQ
	ELSE IF LEN(@nvcQuery6) < 3750
		SET @nvcQuery6 = @nvcQuery6 + @nvcQ
	ELSE IF LEN(@nvcQuery7) < 3750
		SET @nvcQuery7 = @nvcQuery7 + @nvcQ
	ELSE IF LEN(@nvcQuery8) < 3750
		SET @nvcQuery8 = @nvcQuery8 + @nvcQ
	ELSE IF LEN(@nvcQuery9) < 3750
		SET @nvcQuery9 = @nvcQuery9 + @nvcQ
	ELSE IF LEN(@nvcQuery10) < 3750
		SET @nvcQuery10 = @nvcQuery10 + @nvcQ
	ELSE IF LEN(@nvcQuery11) < 3750
		SET @nvcQuery11 = @nvcQuery11 + @nvcQ
	ELSE IF LEN(@nvcQuery12) < 3750
		SET @nvcQuery12 = @nvcQuery12 + @nvcQ
	ELSE IF LEN(@nvcQuery13) < 3750
		SET @nvcQuery13 = @nvcQuery13 + @nvcQ
	ELSE IF LEN(@nvcQuery14) < 3750
		SET @nvcQuery14 = @nvcQuery14 + @nvcQ
	ELSE IF LEN(@nvcQuery15) < 3750
		SET @nvcQuery15 = @nvcQuery15 + @nvcQ

	IF @fDebug = 0 BEGIN
		EXEC (
			@nvcQuery1 + N' ' + @nvcQuery2 + N' ' + @nvcQuery3 + N' ' +
			@nvcQuery4 + N' ' + @nvcQuery5 + N' ' + @nvcQuery6 + N' ' +
			@nvcQuery7 + N' ' + @nvcQuery8 + N' ' + @nvcQuery9 + N' ' +
			@nvcQuery10 + N' ' + @nvcQuery11 + N' ' + @nvcQuery12 + N' ' +
			@nvcQuery13 + N' ' + @nvcQuery14 + N' ' + @nvcQuery15)
		SET @nError = @@ERROR
	END
	ELSE BEGIN
		PRINT @nvcQuery1
		PRINT '--(Starting @nvcQuery2'
		PRINT @nvcQuery2
		PRINT '--(Starting @nvcQuery3'
		PRINT @nvcQuery3
		PRINT '--(Starting @nvcQuery4'
		PRINT @nvcQuery4
		PRINT '--(Starting @nvcQuery5'
		PRINT @nvcQuery5
		PRINT '--(Starting @nvcQuery6'
		PRINT @nvcQuery6
		PRINT '--(Starting @nvcQuery7'
		PRINT @nvcQuery7
		PRINT '--(Starting @nvcQuery8'
		PRINT @nvcQuery8
		PRINT '--(Starting @nvcQuery9'
		PRINT @nvcQuery9
		PRINT '--(Starting @nvcQuery10'
		PRINT @nvcQuery10
		PRINT '--(Starting @nvcQuery11'
		PRINT @nvcQuery11
		PRINT '--(Starting @nvcQuery12'
		PRINT @nvcQuery12
		PRINT '--(Starting @nvcQuery13'
		PRINT @nvcQuery13
		PRINT '--(Starting @nvcQuery14'
		PRINT @nvcQuery14
		PRINT '--(Starting @nvcQuery15'
		PRINT @nvcQuery15
	END

	RETURN @nError
GO

-- Fix this trigger to update reference delete triggers when properties are deleted.
SET QUOTED_IDENTIFIER OFF
GO
SET ANSI_NULLS ON
GO

ALTER   trigger TR_Field$_UpdateModel_Del on Field$ for delete
as
	declare @Clid INT
	declare @DstCls INT
	declare @sName VARCHAR(100)
	declare @sClass VARCHAR(100)
	declare @sFlid VARCHAR(20)
	declare @Type INT
	DECLARE @nAbstract INT

	declare @Err INT
	declare @fIsNocountOn INT
	declare @sql VARCHAR(1000)

	set @fIsNocountOn = @@options & 512
	if @fIsNocountOn = 0 set nocount on

	-- get the first custom field to process
	Select @sFlid= min([id]) from deleted

	-- loop through all of the custom fields to be deleted
	while @sFlid is not null begin

		-- get deleted fields
		select 	@Type = [Type], @Clid = [Class], @sName = [Name], @DstCls = [DstCls]
		from	deleted
		where	[Id] = @sFlid

		-- get class name
		select 	@sClass = [Name], @nAbstract = Abstract  from class$  where [Id] = @Clid

		if @type IN (14,16,18,20) begin
			-- Remove any data stored for this multilingual custom field.
			declare @sTable VARCHAR(20)
			set @sTable = case @type
				when 14 then 'MultiStr$'
				when 16 then 'MultiTxt$ (No Longer Exists)'
				when 18 then 'MultiBigStr$'
				when 20 then 'MultiBigTxt$'
				end
			IF @type != 16  -- MultiTxt$ data will be deleted when the table is dropped
			BEGIN
				set @sql = 'DELETE FROM [' + @sTable + '] WHERE [Flid] = ' + @sFlid
				exec (@sql)
				set @Err = @@error
				if @Err <> 0 goto LFail
			END

			-- Remove the view created for this multilingual custom field.
			IF @type != 16
				set @sql = 'DROP VIEW [' + @sClass + '_' + @sName + ']'
			ELSE
				SET @sql = 'DROP TABLE [' + @sClass + '_' + @sName + ']'
			exec (@sql)
			set @Err = @@error
			if @Err <> 0 goto LFail
		end
		else if @type IN (23,25,27) begin
			-- Remove the view created for this custom OwningAtom/Collection/Sequence field.
			set @sql = 'DROP VIEW [' + @sClass + '_' + @sName + ']'
			exec (@sql)
			set @Err = @@error
			if @Err <> 0 goto LFail
			-- Check for any objects stored for this custom OwningAtom/Collection/Sequence field.
			declare @DelId INT
			select @DelId = [Id] FROM CmObject (readuncommitted) WHERE [OwnFlid$] = @sFlid
			set @Err = @@error
			if @Err <> 0 goto LFail
			if @DelId is not null begin
				raiserror('TR_Field$_UpdateModel_Del: Unable to remove %s field until corresponding objects are deleted',
						16, 1, @sName)
				goto LFail
			end
		end
		else if @type IN (26,28) begin
			-- Remove the table created for this custom ReferenceCollection/Sequence field.
			set @sql = 'DROP TABLE [' + @sClass + '_' + @sName + ']'
			exec (@sql)
			set @Err = @@error
			if @Err <> 0 goto LFail

			-- Remove the procedure that handles reference collections or sequences for
			-- the dropped table
			set @sql = N'
				IF OBJECT_ID(''ReplaceRefColl_' + @sClass +  '_' + @sName + ''') IS NOT NULL
					DROP PROCEDURE [ReplaceRefColl_' + @sClass + '_' + @sName + ']
				IF OBJECT_ID(''ReplaceRefSeq_' + @sClass +  '_' + @sName + ''') IS NOT NULL
					DROP PROCEDURE [ReplaceRefSeq_' + @sClass + '_' + @sName + ']'
			exec (@sql)
			set @Err = @@error
			if @Err <> 0 goto LFail
		end
		else begin
			-- Remove the format column created if this was a custom String field.
			if @type in (13,17) begin
				set @sql = 'ALTER TABLE [' + @sClass + '] DROP COLUMN [' + @sName + '_Fmt]'
				exec (@sql)
				set @Err = @@error
				if @Err <> 0 goto LFail
			end
			-- Remove the constraint created if this was a custom ReferenceAtom field.
			-- Not necessary for CmObject : Foreign Key constraints are not created agains CmObject
			if @type = 24 begin
				declare @sTarget VARCHAR(100)
				select @sTarget = [Name] FROM [Class$] WHERE [Id] = @DstCls
				set @Err = @@error
				if @Err <> 0 goto LFail
				if @sTarget != 'CmObject' begin
					set @sql = 'ALTER TABLE [' + @sClass + '] DROP CONSTRAINT [' +
						'_FK_' + @sClass + '_' + @sName + ']'
					exec (@sql)
					set @Err = @@error
					if @Err <> 0 goto LFail
				end
			end
			-- Remove Default Constraint from Numeric or Date fields before dropping the column
			If @type in (1,2,3,4,5,8) begin
				select @sql = 'ALTER TABLE [' + @sClass + '] DROP CONSTRAINT [' + so.name + ']'
				from sysconstraints sc
					join sysobjects so on so.id = sc.constid and so.name like 'DF[_]%'
					join sysobjects so2 on so2.id = sc.id
					join syscolumns sco on sco.id = sc.id and sco.colid = sc.colid
				where so2.name = @sClass   -- Tablename
				and   sco.name = @sName    -- Fieldname
				and   so2.type = 'U'	   -- Userdefined table
				exec (@sql)
				set @Err = @@error
				if @Err <> 0 goto LFail
			end

			-- Remove the column created for this custom field.
			set @sql = 'ALTER TABLE [' + @sClass + '] DROP COLUMN [' + @sName + ']'
			exec (@sql)
			set @Err = @@error
			if @Err <> 0 goto LFail

			-- fix the view associated with this class.
			exec @Err = UpdateClassView$ @Clid, 1
			if @Err <> 0 goto LFail
		end

		--( Rebuild the delete trigger

		EXEC @Err = CreateDeleteObj @Clid
		IF @Err <> 0 GOTO LFail

		--( Rebuild CreateObject_*

		IF @nAbstract != 1 BEGIN
			EXEC @Err = DefineCreateProc$ @Clid
			IF @Err <> 0 GOTO LFail
		END

		-- get the next custom field to process
		Select @sFlid= min([id]) from deleted  where [Id] > @sFlid

	end -- While loop

	--( Rebuild the stored function fnGetRefsToObj
	EXEC @Err = CreateGetRefsToObj
	IF @Err <> 0 GOTO LFail

	-- if nocount was turned on turn it off
	if @fIsNocountOn = 0 set nocount off
	return

LFail:
	rollback tran
	return
go

-- Remove old ScrImportMapping class no longer being used
exec DeleteModelClass 3009
-- Remove old ScrImportFootnoteSettings class no longer being used
exec DeleteModelClass 3012

-- Fix significant changes in fields
-- ICULocale changed type
if ((select type from field$ where id = 3013001) = 13) begin
	delete from field$ where id = 3013001
	insert into Field$ ([Id], [Type], [Class], [DstCls], [Name], [Custom], [CustomId], [Min], [Max], [Big])
		values(3013001, 15, 3013, null, 'ICULocale', 0, null, null, null, null)
end
-- Name change from DefaultFootnoteMarker to FootnoteMarkerSymbol
if ((select name from field$ where id = 3001010) = 'DefaultFootnoteMarker') begin
	delete from field$ where id = 3001010
	insert into Field$ ([Id], [Type], [Class], [DstCls], [Name], [Custom], [CustomId], [Min], [Max], [Big])
		values(3001010, 15, 3001, null, 'FootnoteMarkerSymbol', 0, null, null, null, null)
end
-- Name change from DefaultDisplayFootnoteReference to DisplayFootnoteReference
if ((select name from field$ where id = 3001012) = 'DefaultDisplayFootnoteReference') begin
	delete from field$ where id = 3001012
	insert into Field$ ([Id], [Type], [Class], [DstCls], [Name], [Custom], [CustomId], [Min], [Max], [Big])
		values(3001012, 1, 3001, null, 'DisplayFootnoteReference', 0, null, null, null, null)
end

-- Remove old fields if they are still present.
-- Scripture_DefaultDisplayFootnoteMarker
if exists (select id from field$ where id = 3001011)
	delete from field$ where id = 3001011
-- ScrMarkerMapping_FootnoteMarker
if exists (select id from field$ where id = 3016007)
	delete from field$ where id = 3016007
-- ScrMarkerMapping_DisplayFootnoteMarker
if exists (select id from field$ where id = 3016008)
	delete from field$ where id = 3016008
-- ScrMarkerMapping_DisplayFootnoteReference
if exists (select id from field$ where id = 3016009)
	delete from field$ where id = 3016009
-- ReversalIndexEntry_Form
if exists (select id from field$ where id = 5053004)
	delete from field$ where id = 5053004
-- ReversalIndexEntry_WritingSystem
if exists (select id from field$ where id = 5053005)
	delete from field$ where id = 5053005

-- Add new fields if they are missing.
-- Scripture_FootnoteMarkerType
if not exists (select id from field$ where id = 3001026)
insert into Field$ ([Id], [Type], [Class], [DstCls], [Name], [Custom], [CustomId], [Min], [Max], [Big])
	values(3001026, 2, 3001, null, 'FootnoteMarkerType', 0, null, null, null, null)
-- Scripture_DisplayCrossRefReference
if not exists (select id from field$ where id = 3001027)
insert into Field$ ([Id], [Type], [Class], [DstCls], [Name], [Custom], [CustomId], [Min], [Max], [Big])
	values(3001027, 1, 3001, null, 'DisplayCrossRefReference', 0, null, null, null, null)
-- Scripture_CrossRefMarkerSymbol
if not exists (select id from field$ where id = 3001028)
insert into Field$ ([Id], [Type], [Class], [DstCls], [Name], [Custom], [CustomId], [Min], [Max], [Big])
	values(3001028, 15, 3001, null, 'CrossRefMarkerSymbol', 0, null, null, null, null)
-- Scripture_CrossRefMarkerType
if not exists (select id from field$ where id = 3001029)
insert into Field$ ([Id], [Type], [Class], [DstCls], [Name], [Custom], [CustomId], [Min], [Max], [Big])
	values(3001029, 2, 3001, null, 'CrossRefMarkerType', 0, null, null, null, null)
-- Scripture_CrossRefsCombinedWithFootnotes
if not exists (select id from field$ where id = 3001030)
insert into Field$ ([Id], [Type], [Class], [DstCls], [Name], [Custom], [CustomId], [Min], [Max], [Big])
	values(3001030, 1, 3001, null, 'CrossRefsCombinedWithFootnotes', 0, null, null, null, null)
-- LexicalDatabase_StylesheetVersion
if not exists (select id from field$ where id = 5005020)
insert into Field$ ([Id], [Type], [Class], [DstCls], [Name], [Custom], [CustomId], [Min], [Max], [Big])
	values(5005020, 6, 5005, null, 'StylesheetVersion', 0, null, null, null, null)
-- ReversalIndexEntry_ReversalForm
if not exists (select id from field$ where id = 5053006)
insert into Field$ ([Id], [Type], [Class], [DstCls], [Name], [Custom], [CustomId], [Min], [Max], [Big])
	values(5053006, 16, 5053, null, 'ReversalForm', 0, null, null, null, null)

-- Fix ScrImportSource_ view that had an extra FMT column
exec UpdateClassView$ 3013, 1

-- Remove bogus view, if it exists
if exists (select * from sysobjects where id = object_id(N'ScrSriptureNote_')
	and objectproperty(id, N'IsView') = 1)
	drop view ScrSriptureNote_

-- Add TR_LexEntry_MainEntriesOrSenses_DtTmIns trigger if it is missing.
if object_id('TR_LexEntry_MainEntriesOrSenses_DtTmIns') is not null begin
	print 'removing trigger TR_LexEntry_MainEntriesOrSenses_DtTmIns'
	drop trigger TR_LexEntry_MainEntriesOrSenses_DtTmIns
end
go
print 'creating trigger TR_LexEntry_MainEntriesOrSenses_DtTmIns'
go
CREATE TRIGGER [TR_LexEntry_MainEntriesOrSenses_DtTmIns]	ON [LexEntry_MainEntriesOrSenses] FOR INSERT AS 	UPDATE CmObject SET UpdDttm = GetDate() 		FROM CmObject co JOIN inserted ins ON co.[id] = ins.[src] 		IF @@error <> 0 BEGIN		Raiserror('TR_LexEntry_MainEntriesOrSenses_DtTmIns]: Unable to update CmObject', 16, 1)		GOTO LFail	END	RETURN		LFail:		ROLLBACK TRAN		RETURN
GO

-- Add TR_LexEntry_MainEntriesOrSenses_DtTmDel trigger if it is missing.
if object_id('TR_LexEntry_MainEntriesOrSenses_DtTmDel') is not null begin
	print 'removing trigger TR_LexEntry_MainEntriesOrSenses_DtTmDel'
	drop trigger TR_LexEntry_MainEntriesOrSenses_DtTmDel
end
go
print 'creating trigger TR_LexEntry_MainEntriesOrSenses_DtTmDel'
go
CREATE TRIGGER [TR_LexEntry_MainEntriesOrSenses_DtTmDel]	ON [LexEntry_MainEntriesOrSenses] FOR DELETE AS 	UPDATE CmObject SET UpdDttm = GetDate() 		FROM CmObject co JOIN deleted del ON co.[id] = del.[src] 		IF @@error <> 0 BEGIN		Raiserror('TR_LexEntry_MainEntriesOrSenses_DtTmDel]: Unable to update CmObject', 16, 1)		GOTO LFail	END	RETURN		LFail:		ROLLBACK TRAN		RETURN
GO

-- TR_CmFile_ObjDel_Del is missing CmMedia update in the migrated db.
exec CreateDeleteObj 47
-- TR_CmLocation_ObjDel_Del  is missing LexPronunciation update in the migrated db
exec CreateDeleteObj 12
-- TR_LgWritingSystem_ObjDel_Del in merged DB has extra ReversalIndexEntry updates.
exec CreateDeleteObj 24

-- CreateObject_LexEntry. migrated version has ImportResidue2 in variable names.
exec DefineCreateProc$ 5002
-- CreateObject_LexSense. migrated version has ImportResidue2 in variable names.
exec DefineCreateProc$ 5016
-- CreateObject_PhEnvironment. migrated version has StringRepresentation2
exec DefineCreateProc$ 5097
-- CreateObject_ScrImportP6Project. migrated version has old ICULocale_fmt
exec DefineCreateProc$ 3014
-- CreateObject_ScrImportSFFiles. migrated version has old ICULocale_fmt
exec DefineCreateProc$ 3015

-- FindOrCreateCmAgent. migrated is missing a READUNCOMMITTED
if object_id('FindOrCreateCmAgent') is not null
	drop proc FindOrCreateCmAgent
go
print 'creating proc FindOrCreateCmAgent'
go

create proc FindOrCreateCmAgent
	@agentName nvarchar(4000),
	@isHuman bit,
	@version  nvarchar(4000)
as
	DECLARE
		@retVal INT,
		@fIsNocountOn INT,
		@agentID int

	set @agentID = null

	-- determine if NO COUNT is currently set to ON
	set @fIsNocountOn = @@options & 512
	if @fIsNocountOn = 0 set nocount on

	select @agentID=aa.Id
	from CmAgent_ aa (readuncommitted)
	join CmAgent_Name aan (readuncommitted) on aan.Obj = aa.Id and aan.Txt=@agentName
	join LanguageProject lp (readuncommitted) On lp.Id = aa.Owner$
	where aa.Human=@isHuman and aa.Version=@version

	-- Found extant one, so return it.
	if @agentID is not null
	begin
		set @retVal = 0
		goto FinishFinal
	end

	--== Need to make a new one ==--
	DECLARE @uid uniqueidentifier,
		@nTrnCnt INT,
		@sTranName VARCHAR(50),
		@wsEN int,
		@lpID int

	-- We don't need to wory about transactions, since the call to CreateObject_CmAgent
	-- wiil create waht is needed, and rool it back, if the creation fails.

	SELECT @wsEN=Obj
	FROM LgWritingSystem_Name (readuncommitted)
	WHERE Txt='English'

	SELECT TOP 1 @lpID=ID
	FROM LanguageProject (readuncommitted)
	ORDER BY ID

	exec @retVal = CreateObject_CmAgent
		@wsEN, @agentName,
		null,
		@isHuman,
		@version,
		@lpID,
		6001038, -- owning flid for CmAgent in LanguageProject
		null,
		@agentID out,
		@uid out

	if @retVal <> 0
	begin
		-- There was an error in CreateObject_CmAgent
		set @retVal = 1
		GOTO FinishClearID
	end

	SET @retVal = 0
	GOTO FinishFinal

FinishClearID:
	set @agentID = 0
	GOTO FinishFinal

FinishFinal:
	if @fIsNocountOn = 0 set nocount off
	select @agentID
	return @retVal

go

-- GetObjInOwnershipPathWithId$. migrated had serializable. new had repeatableread
if object_id('fnGetObjInOwnershipPathWithId$') is not null begin
	print 'removing function fnGetObjInOwnershipPathWithId$'
	drop function [fnGetObjInOwnershipPathWithId$]
end
go
print 'creating function fnGetObjInOwnershipPathWithId$'
go
create function [fnGetObjInOwnershipPathWithId$] (
	@objId int=null,
	@hXMLDocObjList int=null,
	@riid int )
returns @ObjInfo table (
	[ObjId]		int		not null,
	[ObjClass]	int		null,
	[InheritDepth]	int		null		default(0),
	[OwnerDepth]	int		null		default(0),
	[RelObjId]	int		null,
	[RelObjClass]	int		null,
	[RelObjField]	int		null,
	[RelOrder]	int		null,
	[RelType]	int		null,
	[OrdKey]	varbinary(250)	null		default(0)
)
as
begin
	declare	@iOwner int, @iOwnerClass int, @iCurObjId int, @iPrevObjId int

	-- determine if an object was supplied as an argument, if one was not use ObjInfoTbl$ as the list of objects
	if @objId is not null begin

		-- get the class of the specified object
		insert into @ObjInfo (ObjId, ObjClass, InheritDepth, OwnerDepth, ordkey)
		select	@objId, co.[Class$], null, null, null
		from	[CmObject] co (readuncommitted)
		where	co.[Id] = @objId
		if @@error <> 0 goto LFail
	end
	else begin

		-- parse the XML list of Object IDs and insert them into the table variable
		insert into @ObjInfo (ObjId, ObjClass, OrdKey)
		select	i.[Id], co.[Class$],
			-- calculate the order key even if @fCalcOrdKey = 0 because the overhead is very small here
			convert(varbinary, coalesce(co.[Owner$], 0)) +
			convert(varbinary, coalesce(co.[OwnFlid$], 0)) +
			convert(varbinary, coalesce(co.[OwnOrd$], 0))
		from	openxml (@hXMLDocObjList, '/root/Obj') with ([Id] int) i
			join [CmObject] co (readuncommitted) on co.[Id] = i.[Id]
		if @@error <> 0 goto LFail
	end

	select	@iCurObjId=min(ObjId)
	from	@ObjInfo

	while @iCurObjId is not null begin
		set @iPrevObjId = @iCurObjId

		-- loop up (objects that own the specified objects) through the ownership hierarchy until the specified type (class=riid) of
		-- 	owning object is found or the top of the ownership hierarchy is reached
		set @iOwnerClass = 0
		while @iOwnerClass <> @riid begin
			select top 1
				@iOwner = co.[Owner$],
				@iOwnerClass = f.[Class]
			from	[CmObject] co (readuncommitted)
					join [Field$] f on f.[id] = co.[OwnFlid$]
			where 	co.[id] = @iCurObjId

			if @@rowcount > 0 set @iCurObjId = @iOwner
			else begin
				set @iCurObjId = null
				break
			end
		end

		if @iCurObjId is not null begin
			-- update the ObjInfoTbl$ so that specified object(s) is/are related to the specified type of
			--    object (class=riid) that owns it
			update	@ObjInfo
			set	[RelObjId]=@iOwner,
				[RelObjClass]=(
					select co.[Class$]
					from [CmObject] co (readuncommitted)
					where co.[id]=@iOwner)
			where	[ObjId]=@iPrevObjId
			if @@error <> 0 goto LFail
		end

		-- if the user specified an object there was only one object to process and we can therefore
		--    break out of the loop
		if @objId is not null break

		select	@iCurObjId=min(ObjId)
		from	@ObjInfo
		where	[ObjId] > @iPrevObjId
	end

	return
LFail:
	delete @ObjInfo
	return
end
go

-- Import_NewScrBookJRP. migrated used DeleteObject$ while new used DeleteObj$
if exists (select *
			 from sysobjects
			where name = 'Import_NewScrBookJRP')
	drop proc Import_NewScrBookJRP
go
print 'creating proc Import_NewScrBookJRP'
go

create proc Import_NewScrBookJRP
	@hvoScripture	int,
	@nBookNumber	int,
	@hvoBook	int = null output,
	@hvoBookTitle	int = null output
as
	declare @clid int, @flid int, @guid uniqueidentifier,
		@err int, @nTrnCnt int, @sTranName varchar(50),
		@fIsNocountOn int, @ord int, @hvoScrBookRef int

	set @fIsNocountOn = @@options & 512
	if @fIsNocountOn = 0 set nocount on

	-- Determine if a transaction already exists; if one does then create a savepoint, otherwise create a
	-- transaction
	set @nTrnCnt = @@trancount
	set @sTranName = 'NewScrBookJRP_tr' + convert(varchar(8), @@nestlevel)
	if @nTrnCnt = 0 begin tran @sTranName
	else save tran @sTranName

	-- Determine the ScrBookRef corresponding to this book and the relative position
	-- of this book in the ScrBook table.
	set @hvoScrBookRef = 0
	select @hvoScrBookRef = [id]
	from ScrBookRef_
	where OwnOrd$ = @nBookNumber
	if @hvoScrBookRef = 0 begin
		set @err = 55678
		raiserror('No matching ScrBookRef: %d', 16, 1, @nBookNumber)
		goto LFail
	end

	set @flid = 3001001 -- Scripture_ScriptureBooks
	set @ord = 0
	select @ord = OwnOrd$, @hvoBook = [id]
	from ScrBook_
	where BookId = @hvoScrBookRef

	if @ord > 0 begin
		-- Delete the existing book
		exec DeleteObj$ @hvoBook
-- REVIEW TomB: Should we be calling DeletOwnSeq here instead in order to preserve other book info?
	end
	else begin
		-- Select the lowest ord for any existing book beyond the one we want
		-- to create.
		select	@ord = coalesce(max(bk.[OwnOrd$])+1, 1)
		from	[ScrBook_] bk with (serializable)
		join	ScrBookRef_ on ScrBookRef_.[id] = bk.BookId
		and	ScrBookRef_.OwnOrd$ < @nBookNumber
		where	bk.[Owner$] = @hvoScripture
			and bk.[OwnFlid$] = @flid
	end

	-- Create the new ScrBook (base) object
	exec CreateObject_ScrBook
	@ScrBook_Name_ws = NULL, @ScrBook_Name_txt = NULL,
	@ScrBook_Abbrev_ws = NULL, @ScrBook_Abbrev_txt = NULL,
	@Owner = @hvoScripture,
	@OwnFlid = @flid,
	@StartObj = NULL,
	@NewObjId = @hvoBook output,
	@NewObjGuid = NULL

	set @guid = NewId()
	insert [CmObject] ([Guid$], [Class$], [Owner$], [OwnFlid$], [OwnOrd$])
	values(@guid, @clid, @hvoScripture, @flid, @ord)
	if @@error <> 0 begin
		set @err = @@error
		goto LFail
	end
	set @hvoBook = @@identity

	-- Create the new Title (base) object
	set @clid = 14 -- StText
	set @flid = 3002004 -- Scripture_ScriptureBooks
	set @guid = NewId()
	insert [CmObject] ([Guid$], [Class$], [Owner$], [OwnFlid$], [OwnOrd$])
	values(@guid, @clid, @hvoBook, @flid, NULL)
	if @@error <> 0 begin
		set @err = @@error
		goto LFail
	end
	set @hvoBookTitle = @@identity

	-- Insert into ScrBook
	insert [ScrBook] ([Id], [BookId])
	values(@hvoBook, @hvoScrBookRef)
	if @@error <> 0 begin
		set @err = @@error
		raiserror('Unable to add a row to ScrBook: ID=%d', 16, 1, @hvoBook)
		goto LFail
	end

	-- Insert into StText
	-- ENHANCE TomB: Implement Right-to-left
	insert [StText] ([Id], [RightToLeft])
	values(@hvoBookTitle, 0)
	if @@error <> 0 begin
		set @err = @@error
		raiserror('Unable to add a row to StText: ID=%d', 16, 1, @hvoBookTitle)
		goto LFail
	end

	-- if nocount was turned on turn it off
	if @fIsNocountOn = 0 set nocount off

	-- if a transaction was created within this procedure commit it
	if @nTrnCnt = 0 commit tran @sTranName
	return 0

LFail:
	-- if nocount was turned on turn it off
	if @fIsNocountOn = 0 set nocount off

	rollback tran @sTranName
	return @err
GO

-- MakeMissingAnalysesFromLexicion. migrated missing readuncommitted
if object_id('MakeMissingAnalysesFromLexicion') is not null begin
	drop proc MakeMissingAnalysesFromLexicion
end
go
print 'creating proc MakeMissingAnalysesFromLexicion'
go

CREATE  proc MakeMissingAnalysesFromLexicion
	@paraid int,
	@ws int
as

declare wf_cur cursor local static forward_only read_only for

select distinct wf.id wfid, mff.obj fid, ls.id lsid, msta.id msaid, lsg.Txt gloss, msta.PartOfSpeech pos
	from CmBaseAnnotation_ cba (readuncommitted)
	join WfiWordform wf (readuncommitted) on  cba.BeginObject = @paraid and cba.InstanceOf = wf.id -- annotations of this paragraph that are wordforms
	left outer join WfiAnalysis_ wa (readuncommitted) on wa.owner$ = wf.id
	-- if the above produced anything, with the restriction on wa.owner being null below, they are wordforms we want
	join WfiWordform_Form wff (readuncommitted) on wff.obj = wf.id
	join MoForm_Form mff (readuncommitted) on wff.Txt = mff.txt and mff.ws = wff.ws
	-- now we have ones whose form matches an MoForm in the same ws
	join CmObject mfo (readuncommitted) on mfo.id = mff.obj
	join CmObject leo (readuncommitted) on leo.id = mfo.owner$
	join LexSense_ ls (readuncommitted) on ls.owner$ = leo.id
	left outer join LexSense_Gloss lsg (readuncommitted) on lsg.obj = ls.id and lsg.ws = @ws
	left outer join MoStemMsa msta (readuncommitted) on msta.id = ls.MorphoSyntaxAnalysis
	-- combines with left outer join above for effect of
		-- "not exists (select * from WfiAnalysis_ wa where wa.owner$ = wf.id)"
	-- (that is, we want wordforms that have no analyses)
	-- but is faster
	where wa.owner$ is null

open wf_cur

declare @wfid int, @formid int, @senseid int,  @msaid int, @pos int
declare @gloss nvarchar(1000)
declare @NewObjGuid uniqueidentifier,
	@NewObjTimestamp int

-- 5062002 5062002
-- 5059011 5059011
-- 5059010 5059010
-- 5060001 50600001
fetch wf_cur into @wfid, @formid, @senseid, @msaid, @gloss, @pos
while @@fetch_status = 0 begin
	declare @analysisid int
	declare @mbid int
	declare @wgid int
	exec CreateObject_WfiAnalysis @wfid, 5062002, null, @analysisid out, @NewObjGuid out, 0, @NewObjTimestamp
	exec CreateObject_WfiMorphBundle null, null, null, @analysisid, 5059011, null, @mbid out, @NewObjGuid out, 0, @NewObjTimestamp
	exec CreateObject_WfiGloss @ws, @gloss, @analysisid, 5059010, null, @wgid out, @NewObjGuid out, 0, @NewObjTimestamp
	update WfiMorphBundle set Morph = @formid, Msa = @msaid, Sense = @senseid where id = @mbid
	update WfiAnalysis set Category = @pos where id = @analysisid
	fetch wf_cur into @wfid, @formid, @senseid, @msaid, @gloss, @pos
end
close wf_cur
deallocate wf_cur
go

-- Regenerate ReplaceRefColl_class_property stored procs to change serializable to repeatableread
exec DefineReplaceRefCollProc$ 'CmBaseAnnotation_OtherObjects'
exec DefineReplaceRefCollProc$ 'CmIndirectAnnotation_AppliesTo'
exec DefineReplaceRefCollProc$ 'CmOverlay_PossItems'
exec DefineReplaceRefCollProc$ 'CmPerson_PlacesOfResidence'
exec DefineReplaceRefCollProc$ 'CmPerson_Positions'
exec DefineReplaceRefCollProc$ 'CmPossibility_Researchers'
exec DefineReplaceRefCollProc$ 'CmPossibility_Restrictions'
exec DefineReplaceRefCollProc$ 'CmSemanticDomain_OcmRefs'
exec DefineReplaceRefCollProc$ 'CmSemanticDomain_RelatedDomains'
exec DefineReplaceRefCollProc$ 'FsDisjunctiveValue_Value'
exec DefineReplaceRefCollProc$ 'LanguageProject_AnalysisWritingSystems'
exec DefineReplaceRefCollProc$ 'LanguageProject_VernacularWritingSystems'
exec DefineReplaceRefCollProc$ 'LanguageProject_WordformLookupLists'
exec DefineReplaceRefCollProc$ 'LexicalDatabase_AllomorphIndex'
exec DefineReplaceRefCollProc$ 'LexicalDatabase_LexicalFormIndex'
exec DefineReplaceRefCollProc$ 'LexSense_AnthroCodes'
exec DefineReplaceRefCollProc$ 'LexSense_Appendixes'
exec DefineReplaceRefCollProc$ 'LexSense_DomainTypes'
exec DefineReplaceRefCollProc$ 'LexSense_ReversalEntries'
exec DefineReplaceRefCollProc$ 'LexSense_SemanticDomains'
exec DefineReplaceRefCollProc$ 'LexSense_ThesaurusItems'
exec DefineReplaceRefCollProc$ 'LexSense_UsageTypes'
exec DefineReplaceRefCollProc$ 'MoAffixAllomorph_PhoneEnv'
exec DefineReplaceRefCollProc$ 'MoAffixForm_InflectionClasses'
exec DefineReplaceRefCollProc$ 'MoCompoundRule_ToProductivityRestrictions'
exec DefineReplaceRefCollProc$ 'MoDerivationalAffixMsa_FromProductivityRestrictions'
exec DefineReplaceRefCollProc$ 'MoDerivationalAffixMsa_ToProductivityRestrictions'
exec DefineReplaceRefCollProc$ 'MoDerivationalStepMsa_ProductivityRestrictions'
exec DefineReplaceRefCollProc$ 'MoInflectionalAffixMsa_FromProductivityRestrictions'
exec DefineReplaceRefCollProc$ 'MoInflectionalAffixMsa_Slots'
exec DefineReplaceRefCollProc$ 'MoMorphologicalData_AnalyzingAgents'
exec DefineReplaceRefCollProc$ 'MoStemAllomorph_PhoneEnv'
exec DefineReplaceRefCollProc$ 'MoStemMsa_ProductivityRestrictions'
exec DefineReplaceRefCollProc$ 'PartOfSpeech_BearableFeatures'
exec DefineReplaceRefCollProc$ 'PartOfSpeech_InflectableFeatures'
exec DefineReplaceRefCollProc$ 'PhNCSegments_Segments'
exec DefineReplaceRefCollProc$ 'RnAnalysis_SupersededBy'
exec DefineReplaceRefCollProc$ 'RnEvent_Locations'
exec DefineReplaceRefCollProc$ 'RnEvent_Sources'
exec DefineReplaceRefCollProc$ 'RnEvent_TimeOfEvent'
exec DefineReplaceRefCollProc$ 'RnEvent_Weather'
exec DefineReplaceRefCollProc$ 'RnGenericRecord_AnthroCodes'
exec DefineReplaceRefCollProc$ 'RnGenericRecord_CrossReferences'
exec DefineReplaceRefCollProc$ 'RnGenericRecord_PhraseTags'
exec DefineReplaceRefCollProc$ 'RnGenericRecord_Reminders'
exec DefineReplaceRefCollProc$ 'RnGenericRecord_Researchers'
exec DefineReplaceRefCollProc$ 'RnGenericRecord_Restrictions'
exec DefineReplaceRefCollProc$ 'RnGenericRecord_SeeAlso'
exec DefineReplaceRefCollProc$ 'RnRoledParticipants_Participants'
exec DefineReplaceRefCollProc$ 'StTxtPara_ObjRefs'
exec DefineReplaceRefCollProc$ 'UserAppFeatureActivated_UserConfigAccount'
exec DefineReplaceRefCollProc$ 'WfiAnalysis_Stems'
exec DefineReplaceRefCollProc$ 'WfiWordSet_Cases'
exec DefineReplaceRefCollProc$ 'WordformLookupItem_AnthroCodes'
exec DefineReplaceRefCollProc$ 'WordformLookupItem_ThesaurusItems'
go


-- Regenerate ReplaceRefSeq_class_property stored procs to change serializable to repeatableread
exec DefineReplaceRefSeqProc$ 'FsFeatureStructureType_Features', 59004
exec DefineReplaceRefSeqProc$ 'LanguageProject_CurrentAnalysisWritingSystems', 6001019
exec DefineReplaceRefSeqProc$ 'LanguageProject_CurrentPronunciationWritingSystems', 6001020
exec DefineReplaceRefSeqProc$ 'LanguageProject_CurrentVernacularWritingSystems', 6001018
exec DefineReplaceRefSeqProc$ 'LexEntry_MainEntriesOrSenses', 5002019
exec DefineReplaceRefSeqProc$ 'LexReference_Targets', 5120002
exec DefineReplaceRefSeqProc$ 'MoAffixAllomorph_Position', 5027005
exec DefineReplaceRefSeqProc$ 'MoAllomorphAdhocCoProhibition_Allomorphs', 5101001
exec DefineReplaceRefSeqProc$ 'MoAllomorphAdhocCoProhibition_RestOfAllomorphs', 5101003
exec DefineReplaceRefSeqProc$ 'MoInflAffixTemplate_PrefixSlots', 5037006
exec DefineReplaceRefSeqProc$ 'MoInflAffixTemplate_Slots', 5037003
exec DefineReplaceRefSeqProc$ 'MoInflAffixTemplate_SuffixSlots', 5037007
exec DefineReplaceRefSeqProc$ 'MoInsertPhones_Content', 5068001
exec DefineReplaceRefSeqProc$ 'MoMorphemeAdhocCoProhibition_Morphemes', 5102001
exec DefineReplaceRefSeqProc$ 'MoMorphemeAdhocCoProhibition_RestOfMorphemes', 5102003
exec DefineReplaceRefSeqProc$ 'MoMorphoSyntaxAnalysis_Components', 5041001
exec DefineReplaceRefSeqProc$ 'MoMorphoSyntaxAnalysis_GlossBundle', 5041003
exec DefineReplaceRefSeqProc$ 'PhSequenceContext_Members', 5083001
exec DefineReplaceRefSeqProc$ 'PhSimpleContextNC_MinusConstraints', 5086003
exec DefineReplaceRefSeqProc$ 'PhSimpleContextNC_PlusConstraints', 5086002
exec DefineReplaceRefSeqProc$ 'RnAnalysis_CounterEvidence', 4005006
exec DefineReplaceRefSeqProc$ 'RnAnalysis_SupportingEvidence', 4005005
exec DefineReplaceRefSeqProc$ 'ScrBookGroup_Books', 3007002
exec DefineReplaceRefSeqProc$ 'ScrScriptureNote_Categories', 3018002
exec DefineReplaceRefSeqProc$ 'StTxtPara_TextObjects', 16004
exec DefineReplaceRefSeqProc$ 'WfiAnalysis_CompoundRuleApps', 5059012
exec DefineReplaceRefSeqProc$ 'WfiAnalysis_InflectionalTemplateApps', 5059013
go

-- Add StartTrace$ if it is missing.
if object_id('StartTrace$') is not null begin
	print 'removing proc StartTrace$'
	drop procedure [StartTrace$]
end
go
print 'creating procedure StartTrace$'
go

CREATE PROCEDURE [StartTrace$]
	--( Some variables/parameters not Hungarian because of code copied
	--( from Profiler
	@TraceId INT OUTPUT,
	@nReturnCode INT OUTPUT,
	@nTraceType INT = 0,
	@nTraceOptions INT = 2, --( 2 = TRACE_FILE_ROLLOVER. See BOL
	@nvcTracePath NVARCHAR(245) = N'C:\',
	@bnMaxMbFileSize BIGINT = 1,
	@dtStopTime DATETIME = NULL
AS

	DECLARE
		@nvcTraceFile NVARCHAR(245),
		@on BIT,
		@nvcErrMsg NVARCHAR(50),
		@nvcCommand NVARCHAR(512)

	 --( sp_trace_create attaches .trc to the end of a file name.
	IF @nTraceType = 0
		SET @nvcTraceFile = @nvcTracePath + N'FwPlain'
	ELSE IF @nTraceType = 1
		SET @nvcTraceFile = @nvcTracePath + N'FwExpanded'
	ELSE BEGIN
		SET @nvcErrMsg = N'StartTrace: bad Trace type'
		GOTO Fail
	END


	--== Delete Old Trace if exists ==--

	--( This won't work if the trace is still running. You need to
	--( stop the trace first. Chances are the Trace ID is 1.

	SET @nvcCommand = 'if exist ' + @nvcTraceFile + '.trc del ' + @nvcTraceFile + '.trc'
	EXEC @nReturnCode = master.dbo.xp_cmdshell @nvcCommand, NO_OUTPUT
	IF NOT @nReturnCode = 0 BEGIN --( If not 0, then it will be 1
		SET @nvcErrMsg = N'StartTrace: Delete ' + @nvcTraceFile + N'.trc failed '
		GOTO Fail
	END

	--== Create the New Trace ==--

	EXEC @nReturnCode = sp_trace_create
		@TraceID OUTPUT,
		@nTraceOptions,
		@nvcTraceFile,
		@bnMaxMbFileSize,
		@dtStopTime

	IF NOT @nReturnCode = 0 BEGIN
		SET @nvcErrMsg = N'StartTrace: See Books Online for error return code ' +
			CONVERT(NVARCHAR(2), @nReturnCode)
		GOTO Fail
	END

	SET @on = 1

	--( FwPlain, a genric trace file
	IF @nTraceType = 0 BEGIN
		exec sp_trace_setevent @TraceID, 10, 1, @on
		exec sp_trace_setevent @TraceID, 10, 6, @on
		exec sp_trace_setevent @TraceID, 10, 9, @on
		exec sp_trace_setevent @TraceID, 10, 10, @on
		exec sp_trace_setevent @TraceID, 10, 11, @on
		exec sp_trace_setevent @TraceID, 10, 12, @on
		exec sp_trace_setevent @TraceID, 10, 13, @on
		exec sp_trace_setevent @TraceID, 10, 14, @on
		exec sp_trace_setevent @TraceID, 10, 16, @on
		exec sp_trace_setevent @TraceID, 10, 17, @on
		exec sp_trace_setevent @TraceID, 10, 18, @on
		exec sp_trace_setevent @TraceID, 12, 1, @on
		exec sp_trace_setevent @TraceID, 12, 6, @on
		exec sp_trace_setevent @TraceID, 12, 9, @on
		exec sp_trace_setevent @TraceID, 12, 10, @on
		exec sp_trace_setevent @TraceID, 12, 11, @on
		exec sp_trace_setevent @TraceID, 12, 12, @on
		exec sp_trace_setevent @TraceID, 12, 13, @on
		exec sp_trace_setevent @TraceID, 12, 14, @on
		exec sp_trace_setevent @TraceID, 12, 16, @on
		exec sp_trace_setevent @TraceID, 12, 17, @on
		exec sp_trace_setevent @TraceID, 12, 18, @on
		exec sp_trace_setevent @TraceID, 14, 1, @on
		exec sp_trace_setevent @TraceID, 14, 6, @on
		exec sp_trace_setevent @TraceID, 14, 9, @on
		exec sp_trace_setevent @TraceID, 14, 10, @on
		exec sp_trace_setevent @TraceID, 14, 11, @on
		exec sp_trace_setevent @TraceID, 14, 12, @on
		exec sp_trace_setevent @TraceID, 14, 13, @on
		exec sp_trace_setevent @TraceID, 14, 14, @on
		exec sp_trace_setevent @TraceID, 14, 16, @on
		exec sp_trace_setevent @TraceID, 14, 17, @on
		exec sp_trace_setevent @TraceID, 14, 18, @on
		exec sp_trace_setevent @TraceID, 15, 1, @on
		exec sp_trace_setevent @TraceID, 15, 6, @on
		exec sp_trace_setevent @TraceID, 15, 9, @on
		exec sp_trace_setevent @TraceID, 15, 10, @on
		exec sp_trace_setevent @TraceID, 15, 11, @on
		exec sp_trace_setevent @TraceID, 15, 12, @on
		exec sp_trace_setevent @TraceID, 15, 13, @on
		exec sp_trace_setevent @TraceID, 15, 14, @on
		exec sp_trace_setevent @TraceID, 15, 16, @on
		exec sp_trace_setevent @TraceID, 15, 17, @on
		exec sp_trace_setevent @TraceID, 15, 18, @on
		exec sp_trace_setevent @TraceID, 17, 1, @on
		exec sp_trace_setevent @TraceID, 17, 6, @on
		exec sp_trace_setevent @TraceID, 17, 9, @on
		exec sp_trace_setevent @TraceID, 17, 10, @on
		exec sp_trace_setevent @TraceID, 17, 11, @on
		exec sp_trace_setevent @TraceID, 17, 12, @on
		exec sp_trace_setevent @TraceID, 17, 13, @on
		exec sp_trace_setevent @TraceID, 17, 14, @on
		exec sp_trace_setevent @TraceID, 17, 16, @on
		exec sp_trace_setevent @TraceID, 17, 17, @on
		exec sp_trace_setevent @TraceID, 17, 18, @on
	END

	ELSE IF @nTraceType = 1 BEGIN
		exec sp_trace_setevent @TraceID, 10, 1, @on
		exec sp_trace_setevent @TraceID, 10, 9, @on
		exec sp_trace_setevent @TraceID, 10, 11, @on
		exec sp_trace_setevent @TraceID, 10, 12, @on
		exec sp_trace_setevent @TraceID, 10, 13, @on
		exec sp_trace_setevent @TraceID, 10, 14, @on
		exec sp_trace_setevent @TraceID, 10, 16, @on
		exec sp_trace_setevent @TraceID, 10, 17, @on
		exec sp_trace_setevent @TraceID, 10, 18, @on
		exec sp_trace_setevent @TraceID, 10, 21, @on
		exec sp_trace_setevent @TraceID, 10, 31, @on
		exec sp_trace_setevent @TraceID, 10, 34, @on
		exec sp_trace_setevent @TraceID, 14, 1, @on
		exec sp_trace_setevent @TraceID, 14, 9, @on
		exec sp_trace_setevent @TraceID, 14, 11, @on
		exec sp_trace_setevent @TraceID, 14, 12, @on
		exec sp_trace_setevent @TraceID, 14, 13, @on
		exec sp_trace_setevent @TraceID, 14, 14, @on
		exec sp_trace_setevent @TraceID, 14, 16, @on
		exec sp_trace_setevent @TraceID, 14, 17, @on
		exec sp_trace_setevent @TraceID, 14, 18, @on
		exec sp_trace_setevent @TraceID, 14, 21, @on
		exec sp_trace_setevent @TraceID, 14, 31, @on
		exec sp_trace_setevent @TraceID, 14, 34, @on
		exec sp_trace_setevent @TraceID, 15, 1, @on
		exec sp_trace_setevent @TraceID, 15, 9, @on
		exec sp_trace_setevent @TraceID, 15, 11, @on
		exec sp_trace_setevent @TraceID, 15, 12, @on
		exec sp_trace_setevent @TraceID, 15, 13, @on
		exec sp_trace_setevent @TraceID, 15, 14, @on
		exec sp_trace_setevent @TraceID, 15, 16, @on
		exec sp_trace_setevent @TraceID, 15, 17, @on
		exec sp_trace_setevent @TraceID, 15, 18, @on
		exec sp_trace_setevent @TraceID, 15, 21, @on
		exec sp_trace_setevent @TraceID, 15, 31, @on
		exec sp_trace_setevent @TraceID, 15, 34, @on
		exec sp_trace_setevent @TraceID, 16, 1, @on
		exec sp_trace_setevent @TraceID, 16, 9, @on
		exec sp_trace_setevent @TraceID, 16, 11, @on
		exec sp_trace_setevent @TraceID, 16, 12, @on
		exec sp_trace_setevent @TraceID, 16, 13, @on
		exec sp_trace_setevent @TraceID, 16, 14, @on
		exec sp_trace_setevent @TraceID, 16, 16, @on
		exec sp_trace_setevent @TraceID, 16, 17, @on
		exec sp_trace_setevent @TraceID, 16, 18, @on
		exec sp_trace_setevent @TraceID, 16, 21, @on
		exec sp_trace_setevent @TraceID, 16, 31, @on
		exec sp_trace_setevent @TraceID, 16, 34, @on
		exec sp_trace_setevent @TraceID, 17, 1, @on
		exec sp_trace_setevent @TraceID, 17, 9, @on
		exec sp_trace_setevent @TraceID, 17, 11, @on
		exec sp_trace_setevent @TraceID, 17, 12, @on
		exec sp_trace_setevent @TraceID, 17, 13, @on
		exec sp_trace_setevent @TraceID, 17, 14, @on
		exec sp_trace_setevent @TraceID, 17, 16, @on
		exec sp_trace_setevent @TraceID, 17, 17, @on
		exec sp_trace_setevent @TraceID, 17, 18, @on
		exec sp_trace_setevent @TraceID, 17, 21, @on
		exec sp_trace_setevent @TraceID, 17, 31, @on
		exec sp_trace_setevent @TraceID, 17, 34, @on
		exec sp_trace_setevent @TraceID, 21, 1, @on
		exec sp_trace_setevent @TraceID, 21, 9, @on
		exec sp_trace_setevent @TraceID, 21, 11, @on
		exec sp_trace_setevent @TraceID, 21, 12, @on
		exec sp_trace_setevent @TraceID, 21, 13, @on
		exec sp_trace_setevent @TraceID, 21, 14, @on
		exec sp_trace_setevent @TraceID, 21, 16, @on
		exec sp_trace_setevent @TraceID, 21, 17, @on
		exec sp_trace_setevent @TraceID, 21, 18, @on
		exec sp_trace_setevent @TraceID, 21, 21, @on
		exec sp_trace_setevent @TraceID, 21, 31, @on
		exec sp_trace_setevent @TraceID, 21, 34, @on
		exec sp_trace_setevent @TraceID, 22, 1, @on
		exec sp_trace_setevent @TraceID, 22, 9, @on
		exec sp_trace_setevent @TraceID, 22, 11, @on
		exec sp_trace_setevent @TraceID, 22, 12, @on
		exec sp_trace_setevent @TraceID, 22, 13, @on
		exec sp_trace_setevent @TraceID, 22, 14, @on
		exec sp_trace_setevent @TraceID, 22, 16, @on
		exec sp_trace_setevent @TraceID, 22, 17, @on
		exec sp_trace_setevent @TraceID, 22, 18, @on
		exec sp_trace_setevent @TraceID, 22, 21, @on
		exec sp_trace_setevent @TraceID, 22, 31, @on
		exec sp_trace_setevent @TraceID, 22, 34, @on
		exec sp_trace_setevent @TraceID, 33, 1, @on
		exec sp_trace_setevent @TraceID, 33, 9, @on
		exec sp_trace_setevent @TraceID, 33, 11, @on
		exec sp_trace_setevent @TraceID, 33, 12, @on
		exec sp_trace_setevent @TraceID, 33, 13, @on
		exec sp_trace_setevent @TraceID, 33, 14, @on
		exec sp_trace_setevent @TraceID, 33, 16, @on
		exec sp_trace_setevent @TraceID, 33, 17, @on
		exec sp_trace_setevent @TraceID, 33, 18, @on
		exec sp_trace_setevent @TraceID, 33, 21, @on
		exec sp_trace_setevent @TraceID, 33, 31, @on
		exec sp_trace_setevent @TraceID, 33, 34, @on
		exec sp_trace_setevent @TraceID, 34, 1, @on
		exec sp_trace_setevent @TraceID, 34, 9, @on
		exec sp_trace_setevent @TraceID, 34, 11, @on
		exec sp_trace_setevent @TraceID, 34, 12, @on
		exec sp_trace_setevent @TraceID, 34, 13, @on
		exec sp_trace_setevent @TraceID, 34, 14, @on
		exec sp_trace_setevent @TraceID, 34, 16, @on
		exec sp_trace_setevent @TraceID, 34, 17, @on
		exec sp_trace_setevent @TraceID, 34, 18, @on
		exec sp_trace_setevent @TraceID, 34, 21, @on
		exec sp_trace_setevent @TraceID, 34, 31, @on
		exec sp_trace_setevent @TraceID, 34, 34, @on
		exec sp_trace_setevent @TraceID, 35, 1, @on
		exec sp_trace_setevent @TraceID, 35, 9, @on
		exec sp_trace_setevent @TraceID, 35, 11, @on
		exec sp_trace_setevent @TraceID, 35, 12, @on
		exec sp_trace_setevent @TraceID, 35, 13, @on
		exec sp_trace_setevent @TraceID, 35, 14, @on
		exec sp_trace_setevent @TraceID, 35, 16, @on
		exec sp_trace_setevent @TraceID, 35, 17, @on
		exec sp_trace_setevent @TraceID, 35, 18, @on
		exec sp_trace_setevent @TraceID, 35, 21, @on
		exec sp_trace_setevent @TraceID, 35, 31, @on
		exec sp_trace_setevent @TraceID, 35, 34, @on
		exec sp_trace_setevent @TraceID, 36, 1, @on
		exec sp_trace_setevent @TraceID, 36, 9, @on
		exec sp_trace_setevent @TraceID, 36, 11, @on
		exec sp_trace_setevent @TraceID, 36, 12, @on
		exec sp_trace_setevent @TraceID, 36, 13, @on
		exec sp_trace_setevent @TraceID, 36, 14, @on
		exec sp_trace_setevent @TraceID, 36, 16, @on
		exec sp_trace_setevent @TraceID, 36, 17, @on
		exec sp_trace_setevent @TraceID, 36, 18, @on
		exec sp_trace_setevent @TraceID, 36, 21, @on
		exec sp_trace_setevent @TraceID, 36, 31, @on
		exec sp_trace_setevent @TraceID, 36, 34, @on
		exec sp_trace_setevent @TraceID, 37, 1, @on
		exec sp_trace_setevent @TraceID, 37, 9, @on
		exec sp_trace_setevent @TraceID, 37, 11, @on
		exec sp_trace_setevent @TraceID, 37, 12, @on
		exec sp_trace_setevent @TraceID, 37, 13, @on
		exec sp_trace_setevent @TraceID, 37, 14, @on
		exec sp_trace_setevent @TraceID, 37, 16, @on
		exec sp_trace_setevent @TraceID, 37, 17, @on
		exec sp_trace_setevent @TraceID, 37, 18, @on
		exec sp_trace_setevent @TraceID, 37, 21, @on
		exec sp_trace_setevent @TraceID, 37, 31, @on
		exec sp_trace_setevent @TraceID, 37, 34, @on
		exec sp_trace_setevent @TraceID, 41, 1, @on
		exec sp_trace_setevent @TraceID, 41, 9, @on
		exec sp_trace_setevent @TraceID, 41, 11, @on
		exec sp_trace_setevent @TraceID, 41, 12, @on
		exec sp_trace_setevent @TraceID, 41, 13, @on
		exec sp_trace_setevent @TraceID, 41, 14, @on
		exec sp_trace_setevent @TraceID, 41, 16, @on
		exec sp_trace_setevent @TraceID, 41, 17, @on
		exec sp_trace_setevent @TraceID, 41, 18, @on
		exec sp_trace_setevent @TraceID, 41, 21, @on
		exec sp_trace_setevent @TraceID, 41, 31, @on
		exec sp_trace_setevent @TraceID, 41, 34, @on
		exec sp_trace_setevent @TraceID, 50, 1, @on
		exec sp_trace_setevent @TraceID, 50, 9, @on
		exec sp_trace_setevent @TraceID, 50, 11, @on
		exec sp_trace_setevent @TraceID, 50, 12, @on
		exec sp_trace_setevent @TraceID, 50, 13, @on
		exec sp_trace_setevent @TraceID, 50, 14, @on
		exec sp_trace_setevent @TraceID, 50, 16, @on
		exec sp_trace_setevent @TraceID, 50, 17, @on
		exec sp_trace_setevent @TraceID, 50, 18, @on
		exec sp_trace_setevent @TraceID, 50, 21, @on
		exec sp_trace_setevent @TraceID, 50, 31, @on
		exec sp_trace_setevent @TraceID, 50, 34, @on
		exec sp_trace_setevent @TraceID, 53, 1, @on
		exec sp_trace_setevent @TraceID, 53, 9, @on
		exec sp_trace_setevent @TraceID, 53, 11, @on
		exec sp_trace_setevent @TraceID, 53, 12, @on
		exec sp_trace_setevent @TraceID, 53, 13, @on
		exec sp_trace_setevent @TraceID, 53, 14, @on
		exec sp_trace_setevent @TraceID, 53, 16, @on
		exec sp_trace_setevent @TraceID, 53, 17, @on
		exec sp_trace_setevent @TraceID, 53, 18, @on
		exec sp_trace_setevent @TraceID, 53, 21, @on
		exec sp_trace_setevent @TraceID, 53, 31, @on
		exec sp_trace_setevent @TraceID, 53, 34, @on
		exec sp_trace_setevent @TraceID, 55, 1, @on
		exec sp_trace_setevent @TraceID, 55, 9, @on
		exec sp_trace_setevent @TraceID, 55, 11, @on
		exec sp_trace_setevent @TraceID, 55, 12, @on
		exec sp_trace_setevent @TraceID, 55, 13, @on
		exec sp_trace_setevent @TraceID, 55, 14, @on
		exec sp_trace_setevent @TraceID, 55, 16, @on
		exec sp_trace_setevent @TraceID, 55, 17, @on
		exec sp_trace_setevent @TraceID, 55, 18, @on
		exec sp_trace_setevent @TraceID, 55, 21, @on
		exec sp_trace_setevent @TraceID, 55, 31, @on
		exec sp_trace_setevent @TraceID, 55, 34, @on
		exec sp_trace_setevent @TraceID, 61, 1, @on
		exec sp_trace_setevent @TraceID, 61, 9, @on
		exec sp_trace_setevent @TraceID, 61, 11, @on
		exec sp_trace_setevent @TraceID, 61, 12, @on
		exec sp_trace_setevent @TraceID, 61, 13, @on
		exec sp_trace_setevent @TraceID, 61, 14, @on
		exec sp_trace_setevent @TraceID, 61, 16, @on
		exec sp_trace_setevent @TraceID, 61, 17, @on
		exec sp_trace_setevent @TraceID, 61, 18, @on
		exec sp_trace_setevent @TraceID, 61, 21, @on
		exec sp_trace_setevent @TraceID, 61, 31, @on
		exec sp_trace_setevent @TraceID, 61, 34, @on
		exec sp_trace_setevent @TraceID, 67, 1, @on
		exec sp_trace_setevent @TraceID, 67, 9, @on
		exec sp_trace_setevent @TraceID, 67, 11, @on
		exec sp_trace_setevent @TraceID, 67, 12, @on
		exec sp_trace_setevent @TraceID, 67, 13, @on
		exec sp_trace_setevent @TraceID, 67, 14, @on
		exec sp_trace_setevent @TraceID, 67, 16, @on
		exec sp_trace_setevent @TraceID, 67, 17, @on
		exec sp_trace_setevent @TraceID, 67, 18, @on
		exec sp_trace_setevent @TraceID, 67, 21, @on
		exec sp_trace_setevent @TraceID, 67, 31, @on
		exec sp_trace_setevent @TraceID, 67, 34, @on
		exec sp_trace_setevent @TraceID, 68, 1, @on
		exec sp_trace_setevent @TraceID, 68, 9, @on
		exec sp_trace_setevent @TraceID, 68, 11, @on
		exec sp_trace_setevent @TraceID, 68, 12, @on
		exec sp_trace_setevent @TraceID, 68, 13, @on
		exec sp_trace_setevent @TraceID, 68, 14, @on
		exec sp_trace_setevent @TraceID, 68, 16, @on
		exec sp_trace_setevent @TraceID, 68, 17, @on
		exec sp_trace_setevent @TraceID, 68, 18, @on
		exec sp_trace_setevent @TraceID, 68, 21, @on
		exec sp_trace_setevent @TraceID, 68, 31, @on
		exec sp_trace_setevent @TraceID, 68, 34, @on
		exec sp_trace_setevent @TraceID, 69, 1, @on
		exec sp_trace_setevent @TraceID, 69, 9, @on
		exec sp_trace_setevent @TraceID, 69, 11, @on
		exec sp_trace_setevent @TraceID, 69, 12, @on
		exec sp_trace_setevent @TraceID, 69, 13, @on
		exec sp_trace_setevent @TraceID, 69, 14, @on
		exec sp_trace_setevent @TraceID, 69, 16, @on
		exec sp_trace_setevent @TraceID, 69, 17, @on
		exec sp_trace_setevent @TraceID, 69, 18, @on
		exec sp_trace_setevent @TraceID, 69, 21, @on
		exec sp_trace_setevent @TraceID, 69, 31, @on
		exec sp_trace_setevent @TraceID, 69, 34, @on
		exec sp_trace_setevent @TraceID, 70, 1, @on
		exec sp_trace_setevent @TraceID, 70, 9, @on
		exec sp_trace_setevent @TraceID, 70, 11, @on
		exec sp_trace_setevent @TraceID, 70, 12, @on
		exec sp_trace_setevent @TraceID, 70, 13, @on
		exec sp_trace_setevent @TraceID, 70, 14, @on
		exec sp_trace_setevent @TraceID, 70, 16, @on
		exec sp_trace_setevent @TraceID, 70, 17, @on
		exec sp_trace_setevent @TraceID, 70, 18, @on
		exec sp_trace_setevent @TraceID, 70, 21, @on
		exec sp_trace_setevent @TraceID, 70, 31, @on
		exec sp_trace_setevent @TraceID, 70, 34, @on
		exec sp_trace_setevent @TraceID, 71, 1, @on
		exec sp_trace_setevent @TraceID, 71, 9, @on
		exec sp_trace_setevent @TraceID, 71, 11, @on
		exec sp_trace_setevent @TraceID, 71, 12, @on
		exec sp_trace_setevent @TraceID, 71, 13, @on
		exec sp_trace_setevent @TraceID, 71, 14, @on
		exec sp_trace_setevent @TraceID, 71, 16, @on
		exec sp_trace_setevent @TraceID, 71, 17, @on
		exec sp_trace_setevent @TraceID, 71, 18, @on
		exec sp_trace_setevent @TraceID, 71, 21, @on
		exec sp_trace_setevent @TraceID, 71, 31, @on
		exec sp_trace_setevent @TraceID, 71, 34, @on
		exec sp_trace_setevent @TraceID, 72, 1, @on
		exec sp_trace_setevent @TraceID, 72, 9, @on
		exec sp_trace_setevent @TraceID, 72, 11, @on
		exec sp_trace_setevent @TraceID, 72, 12, @on
		exec sp_trace_setevent @TraceID, 72, 13, @on
		exec sp_trace_setevent @TraceID, 72, 14, @on
		exec sp_trace_setevent @TraceID, 72, 16, @on
		exec sp_trace_setevent @TraceID, 72, 17, @on
		exec sp_trace_setevent @TraceID, 72, 18, @on
		exec sp_trace_setevent @TraceID, 72, 21, @on
		exec sp_trace_setevent @TraceID, 72, 31, @on
		exec sp_trace_setevent @TraceID, 72, 34, @on
		exec sp_trace_setevent @TraceID, 74, 1, @on
		exec sp_trace_setevent @TraceID, 74, 9, @on
		exec sp_trace_setevent @TraceID, 74, 11, @on
		exec sp_trace_setevent @TraceID, 74, 12, @on
		exec sp_trace_setevent @TraceID, 74, 13, @on
		exec sp_trace_setevent @TraceID, 74, 14, @on
		exec sp_trace_setevent @TraceID, 74, 16, @on
		exec sp_trace_setevent @TraceID, 74, 17, @on
		exec sp_trace_setevent @TraceID, 74, 18, @on
		exec sp_trace_setevent @TraceID, 74, 21, @on
		exec sp_trace_setevent @TraceID, 74, 31, @on
		exec sp_trace_setevent @TraceID, 74, 34, @on
		exec sp_trace_setevent @TraceID, 75, 1, @on
		exec sp_trace_setevent @TraceID, 75, 9, @on
		exec sp_trace_setevent @TraceID, 75, 11, @on
		exec sp_trace_setevent @TraceID, 75, 12, @on
		exec sp_trace_setevent @TraceID, 75, 13, @on
		exec sp_trace_setevent @TraceID, 75, 14, @on
		exec sp_trace_setevent @TraceID, 75, 16, @on
		exec sp_trace_setevent @TraceID, 75, 17, @on
		exec sp_trace_setevent @TraceID, 75, 18, @on
		exec sp_trace_setevent @TraceID, 75, 21, @on
		exec sp_trace_setevent @TraceID, 75, 31, @on
		exec sp_trace_setevent @TraceID, 75, 34, @on
		exec sp_trace_setevent @TraceID, 76, 1, @on
		exec sp_trace_setevent @TraceID, 76, 9, @on
		exec sp_trace_setevent @TraceID, 76, 11, @on
		exec sp_trace_setevent @TraceID, 76, 12, @on
		exec sp_trace_setevent @TraceID, 76, 13, @on
		exec sp_trace_setevent @TraceID, 76, 14, @on
		exec sp_trace_setevent @TraceID, 76, 16, @on
		exec sp_trace_setevent @TraceID, 76, 17, @on
		exec sp_trace_setevent @TraceID, 76, 18, @on
		exec sp_trace_setevent @TraceID, 76, 21, @on
		exec sp_trace_setevent @TraceID, 76, 31, @on
		exec sp_trace_setevent @TraceID, 76, 34, @on
		exec sp_trace_setevent @TraceID, 77, 1, @on
		exec sp_trace_setevent @TraceID, 77, 9, @on
		exec sp_trace_setevent @TraceID, 77, 11, @on
		exec sp_trace_setevent @TraceID, 77, 12, @on
		exec sp_trace_setevent @TraceID, 77, 13, @on
		exec sp_trace_setevent @TraceID, 77, 14, @on
		exec sp_trace_setevent @TraceID, 77, 16, @on
		exec sp_trace_setevent @TraceID, 77, 17, @on
		exec sp_trace_setevent @TraceID, 77, 18, @on
		exec sp_trace_setevent @TraceID, 77, 21, @on
		exec sp_trace_setevent @TraceID, 77, 31, @on
		exec sp_trace_setevent @TraceID, 77, 34, @on
		exec sp_trace_setevent @TraceID, 78, 1, @on
		exec sp_trace_setevent @TraceID, 78, 9, @on
		exec sp_trace_setevent @TraceID, 78, 11, @on
		exec sp_trace_setevent @TraceID, 78, 12, @on
		exec sp_trace_setevent @TraceID, 78, 13, @on
		exec sp_trace_setevent @TraceID, 78, 14, @on
		exec sp_trace_setevent @TraceID, 78, 16, @on
		exec sp_trace_setevent @TraceID, 78, 17, @on
		exec sp_trace_setevent @TraceID, 78, 18, @on
		exec sp_trace_setevent @TraceID, 78, 21, @on
		exec sp_trace_setevent @TraceID, 78, 31, @on
		exec sp_trace_setevent @TraceID, 78, 34, @on
		exec sp_trace_setevent @TraceID, 79, 1, @on
		exec sp_trace_setevent @TraceID, 79, 9, @on
		exec sp_trace_setevent @TraceID, 79, 11, @on
		exec sp_trace_setevent @TraceID, 79, 12, @on
		exec sp_trace_setevent @TraceID, 79, 13, @on
		exec sp_trace_setevent @TraceID, 79, 14, @on
		exec sp_trace_setevent @TraceID, 79, 16, @on
		exec sp_trace_setevent @TraceID, 79, 17, @on
		exec sp_trace_setevent @TraceID, 79, 18, @on
		exec sp_trace_setevent @TraceID, 79, 21, @on
		exec sp_trace_setevent @TraceID, 79, 31, @on
		exec sp_trace_setevent @TraceID, 79, 34, @on
		exec sp_trace_setevent @TraceID, 80, 1, @on
		exec sp_trace_setevent @TraceID, 80, 9, @on
		exec sp_trace_setevent @TraceID, 80, 11, @on
		exec sp_trace_setevent @TraceID, 80, 12, @on
		exec sp_trace_setevent @TraceID, 80, 13, @on
		exec sp_trace_setevent @TraceID, 80, 14, @on
		exec sp_trace_setevent @TraceID, 80, 16, @on
		exec sp_trace_setevent @TraceID, 80, 17, @on
		exec sp_trace_setevent @TraceID, 80, 18, @on
		exec sp_trace_setevent @TraceID, 80, 21, @on
		exec sp_trace_setevent @TraceID, 80, 31, @on
		exec sp_trace_setevent @TraceID, 80, 34, @on
		exec sp_trace_setevent @TraceID, 100, 1, @on
		exec sp_trace_setevent @TraceID, 100, 9, @on
		exec sp_trace_setevent @TraceID, 100, 11, @on
		exec sp_trace_setevent @TraceID, 100, 12, @on
		exec sp_trace_setevent @TraceID, 100, 13, @on
		exec sp_trace_setevent @TraceID, 100, 14, @on
		exec sp_trace_setevent @TraceID, 100, 16, @on
		exec sp_trace_setevent @TraceID, 100, 17, @on
		exec sp_trace_setevent @TraceID, 100, 18, @on
		exec sp_trace_setevent @TraceID, 100, 21, @on
		exec sp_trace_setevent @TraceID, 100, 31, @on
		exec sp_trace_setevent @TraceID, 100, 34, @on
	END

	--( Set a filter
	IF @nTraceType = 0
		exec sp_trace_setfilter @TraceID, 10, 0, 7, N'SQL Profiler'

	--== Start the Trace ==--

	EXEC @nReturnCode = sp_trace_setstatus @TraceID, 1

	IF NOT @nReturnCode = 0 BEGIN
		SET @nvcErrMsg = N'StartTrace: Couldn''t start the trace with sp_trace_setstatus'
		GOTO Fail
	END

	GOTO Finish

Fail:
	RAISERROR (@nvcErrMsg, 16, 1)
	SELECT ErrorCode = @nReturnCode

	--( Stop the trace
	EXEC sp_trace_setstatus @TraceID, 0
	--( Close the trace
	EXEC sp_trace_setstatus @TraceID, 2

Finish:
GO

-- Add WasParsingDataModified if it is missing.
if object_id('WasParsingDataModified') is not null begin
	print 'removing proc WasParsingDataModified'
	drop proc WasParsingDataModified
end
print 'creating proc WasParsingDataModified'
go

CREATE PROC [WasParsingDataModified]
			@stampCompare TIMESTAMP
AS
	SELECT TOP 1 Id
	FROM CmObject co (readuncommitted)
	WHERE co.UpdStmp > @stampCompare
		AND (co.Class$ BETWEEN 5026 AND 5045
			OR co.Class$ IN
			(4, -- FsComplexFeature 4
			49, -- FsFeatureSystem 49
			50, -- FsClosedFeature 50
			51, -- FsClosedValue 51
			53, -- FsComplexValue 53
			57, -- FsFeatureStructure 57
			59, -- FsFeatureStructureType 59
			65, -- FsSymbolicFeatureValue 65
			5001, -- MoStemMsa 5001
			5002, -- LexEntry 5002
			5005, -- LexicalDatabase 5005
			5049, -- PartOfSpeech 5049
			5092, -- PhPhoneme 5092
			5095, -- PhNCSegments 5095
			5097, -- PhEnvironment 5097
			5098, -- PhCode 5098
			5099, -- PhPhonologicalData 5099
			5101, -- MoAllomorphAdhocCoProhibition 5101
			5102, -- MoMorphemeAdhocCoProhibition 5102
			5110, -- MoAdhocCoProhibitionGroup 5110
			5117 -- MoUnclassifiedAffixMsa 5117
			))
GO

-- Delete these obsolete stored procedures if they are present
if exists (select * from sysobjects where id = object_id(N'CreateObject_ScrSriptureNote')
	and objectproperty(id, N'IsProcedure') = 1)
		drop procedure CreateObject_ScrSriptureNote
if exists (select * from sysobjects where id = object_id(N'CreateObject_CmAnnotation')
	and objectproperty(id, N'IsProcedure') = 1)
		drop procedure CreateObject_CmAnnotation
if exists (select * from sysobjects where id = object_id(N'CreateObject_LexRefEntryOrSense')
	and objectproperty(id, N'IsProcedure') = 1)
		drop procedure CreateObject_LexRefEntryOrSense
if exists (select * from sysobjects where id = object_id(N'CreateObject_ScrImportFootnoteSettings')
	and objectproperty(id, N'IsProcedure') = 1)
		drop procedure CreateObject_ScrImportFootnoteSettings
GO

-- Add missing readuncommitted to fnGetParseCountRange
if object_id('fnGetParseCountRange') is not null begin
	print 'removing function fnGetParseCountRange'
	drop function [fnGetParseCountRange]
end
go
print 'creating function fnGetParseCountRange'
go

CREATE FUNCTION [fnGetParseCountRange] (
	@nAgentId INT,
	@nWritingSystem INT,
	@nAccepted BIT,
	@nRangeMin INT,
	@nRangeMax INT)
RETURNS @tblWfiWordFormsCount TABLE (
	[Id] INT,
	--( See the notes under string tables in FwCore.sql about the
	--( COLLATE clause.
	Txt NVARCHAR(4000) COLLATE Latin1_General_BIN,
	EvalCount INT)
AS
BEGIN

	--( See Class Diagram CmAgent in the doc.
	--(-------------------------------------------
	--( CmAgentEvaluation.Target -->
	--(		CmObject --( subclassed as )-->
	--(		WfiWordForm or WfiAnalysis
	--(
	--(	WfiWordForm.Analyses -->
	--(		WfiAnalysis
	--(-------------------------------------------
	--( The Target of CmAgentEvaluation may either
	--( be a WfiWordForm, or a WfiAnalysis owned
	--( by a WfiWordForm. We want the latter.

	IF @nRangeMax != 0 BEGIN

		IF @nAccepted IS NULL

			INSERT INTO @tblWfiWordFormsCount
			SELECT wordformform.[Obj], wordformform.Txt, COUNT(wordformform.[Obj]) AS EvalCount
			FROM CmAgentEvaluation agenteval (READUNCOMMITTED)
			JOIN CmObject oagenteval (READUNCOMMITTED) ON oagenteval.[Id] = agenteval.[Id]
				AND oagenteval.[Owner$] = @nAgentId
			--( Don't need to join WfiAnalysis or WfiAnalysis_ here
			JOIN CmObject oanalysis (READUNCOMMITTED) ON oanalysis.[Id] = agenteval.[Target]
			JOIN WfiWordForm_Form wordformform (READUNCOMMITTED) ON wordformform.Obj = oanalysis.[Owner$]
				AND wordformform.ws = @nWritingSystem --( WfiWordForm_Form is actually MultiTxt$ with flid
			GROUP BY wordformform.[Obj], wordformform.Txt
			HAVING COUNT(wordformform.[Obj]) BETWEEN @nRangeMin AND @nRangeMax
			ORDER BY wordformform.Txt

		ELSE

			INSERT INTO @tblWfiWordFormsCount
			SELECT wordformform.[Obj], wordformform.Txt, COUNT(wordformform.[Obj]) AS EvalCount
			FROM CmAgentEvaluation agenteval (READUNCOMMITTED)
			JOIN CmObject oagenteval (READUNCOMMITTED) ON oagenteval.[Id] = agenteval.[Id]
				AND oagenteval.[Owner$] = @nAgentId
			--( Don't need to join WfiAnalysis or WfiAnalysis_ here
			JOIN CmObject oanalysis (READUNCOMMITTED) ON oanalysis.[Id] = agenteval.[Target]
			JOIN WfiWordForm_Form wordformform (READUNCOMMITTED) ON wordformform.Obj = oanalysis.[Owner$]
				AND wordformform.ws = @nWritingSystem --( WfiWordForm_Form is actually MultiTxt$ with flid
			WHERE agenteval.accepted = @nAccepted
			GROUP BY wordformform.[Obj], wordformform.Txt
			HAVING COUNT(wordformform.[Obj]) BETWEEN @nRangeMin AND @nRangeMax
			ORDER BY wordformform.Txt

	END
	ELSE --( IF @nRangeMax = 0

		--( 0 Parses:	wordform has an evaluation, but analyses--if
		--(				any--don't have evaluations

		--( Randy Regnier:
		--( I think it will have an evaluation, but for cases where the
		--( parser couldn't come up with any parses at all, I add a CmBaseAnnotation,
		--( and set its InstanceOfRAHvo and BeginObjectRAHvo to the HVO of the wordform.
		--( The CompDetails of the annotation will say "Analysis Failure".
		--( <snip>
		--( John Thomson: Which 'it' will have an evaluation?
		--( <snip>
		--( RR: We add evaluations to both the wordform and any parses retruned by the
		--( parser. In the case of no parses being returned, we jsut add an evaluation
		--( top the wordform, along with the annotation.

		INSERT INTO @tblWfiWordFormsCount
		SELECT wordformform.[Obj], wordformform.Txt, 0 AS EvalCount
		FROM WfiWordForm_Form wordformform (READUNCOMMITTED)
		JOIN CmAgentEvaluation agenteval (readuncommitted) ON agenteval.Target = wordformform.Obj
		JOIN CmObject oagenteval (READUNCOMMITTED) ON oagenteval.[Id] = agenteval.[Id]
			AND oagenteval.[Owner$] = @nAgentId
		LEFT OUTER JOIN CmObject oAnalysis (readuncommitted) ON oAnalysis.Owner$ = wordformform.Obj
		LEFT OUTER JOIN CmAgentEvaluation aneval (readuncommitted) ON aneval.Target = oanalysis.[Id]
		WHERE aneval.Target IS NULL

	RETURN
END
GO

SET QUOTED_IDENTIFIER OFF
GO
SET ANSI_NULLS ON
GO

-------------------------------------------------------------------------------
-- Finish or roll back transaction as applicable
-------------------------------------------------------------------------------
DECLARE @dbVersion int
SELECT @dbVersion = [DbVer] FROM [Version$]
IF @dbVersion = 200146
BEGIN
	UPDATE [Version$] SET [DbVer] = 200147
	COMMIT TRANSACTION
	PRINT 'database updated to version 200147'
END

ELSE
BEGIN
	ROLLBACK TRANSACTION
	PRINT 'Update aborted: this works only if DbVer = 200146 (DbVer = ' +
		convert(varchar, @dbVersion) + ')'
END
GO
