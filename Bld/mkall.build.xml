<?xml version="1.0" encoding="UTF-8"?>
<!-- Include for make all C++ code of FieldWorks -->
<!--
	This include file contains all the targets that used to be in mkall.bat
	We had to replace mkall.bat because in order to run C# test directly with
	the project to which they belong.

	Eventually this file should go away when the C++ files will be built
	by NAnt.
-->
<project name="mkall" default="mkall" xmlns="http://fieldworks.sil.org/nant/fwnant.xsd" >
	<!-- -->
	<target name="mkall-jenkins" description="mkall target for Jenkins CI" depends="mkall">
		<if test="${property::exists('fw-build-error')}">
				<fail message="${fw-build-error}"/>
		</if>
	</target>
	<!-- generic targets -->
	<target name="mkall" description="Make all of FieldWorks" depends="initLinux">
		<tstamp/>
		<call target="mkall-internal" failonerror="false" cascade="false"/>
		<tstamp/>
		<if test="${fw-mkall-internal-error and (not property::exists('fw-build-error'))}">
			<property name="fw-build-error" value="********* mkall failed ********"/>
		</if>
		<call target="EncConvertersDlls" failonerror="false"/>
	</target>
	<!-- -->
	<target name="mkall-internal" description="Make all of FieldWorks - don't call directly">
		<!-- set ${fw-mkall-internal-error} to true and at the end to false. If batch file fails,
			${fw-mkall-internal-error} will remain true, so we know if anything happened -->
		<property name="fw-mkall-internal-error" value="true"/>
		<call target="icudlls" failonerror="false" cascade="false"/>
		<call target="mkall-internal-core" cascade="false"/>
		<property name="fw-mkall-internal-error" value="false"/>
	</target>
	<!-- -->
	<target name="mkall-internal-core" description="Make all of FieldWorks - don't call directly"
		depends="FDOBrowser,LexTextExe,allTe,UnicodeCharEditor,mkall-tst">
		<!--
			Only put exes in the 'depends' of this target.
			Those exes (and their related dlls can worry about the finer points of what they depend on,
			either as compile time dependencies or as runtime dependencies.
			[Note: The ordering of the non-test exes is chronological.
			That is, they are listed in the order in which they were brought online in the new architecture.]
		-->
	</target>
	<!-- -->
	<target name="FDOBrowser" description="Build FDO Browser project." depends="BasicUtils,COMInterfaces,DetailControls,FDO,Framework,FwUtils,ObjectBrowser,Widgets,xCoreInterfaces,XMLViews">
		<call target="FDOBrowser-nodep" cascade="false"/>
	</target>
	<target name="FDOBrowser-nodep">
		<property name="dir.srcProj" value="${fwroot}/Src/FDOBrowser"/>
		<call target="vsconvert-convert"/>
		<!-- I think the manifest file is needed only on MS Windows. -->
		<property name="executable" value="${dir.outputBase}/FDOBrowser.exe" unless="${platform::is-unix()}"/>
		<call target="regfree" cascade="true" unless="${platform::is-unix()}"/>
	</target>
	<!-- -->
	<target name="mkall-errorhandling" description="Call mkall, but handles errors">
		<call target="mkall-internal" failonerror="false" cascade="false"/>
		<if test="${fw-mkall-internal-error}">
			<if test="${property::exists('fw-build-error')}">
				<property name="fw-build-error" value="${fw-build-error}; mkall (${config}) failed"/>
			</if>
			<if test="${not property::exists('fw-build-error')}">
				<property name="fw-build-error" value="mkall (${config}) failed"/>
			</if>
		</if>
	</target>
	<!-- -->
	<target name="mkall-localize" description="both mkall and localize"
		depends="mkall,localize">
		<echo message="Finished 'mkall-localize' target."/>
	</target>
	<!-- -->
	<target name="mkall-localize-errorhandling" description="both mkall-errorhandling and localize"
		depends="mkall-errorhandling,localize">
		<echo message="Finished 'mkall-localize-errorhandling' target."/>
	</target>
	<!--
		C++ tests are compiled always with debug turned on,
		so there's no reason to run them in release builds.
	-->
	<target name="mkall-tst" depends="mkGenLib-tst,mkfwk-tst,mklg-tst,mkvw-tst" />
	<!-- -->
	<!-- special targets -->
	<target name="XceedZipDll" description="Register the Xceed Zip DLL">
		<!-- NB: Only one of these will be run. -->
		<comregisterex file="${fwroot}/DistFiles/XceedZip.dll" failonerror="false" unless="${clean}"/>
		<comregisterex file="${fwroot}/DistFiles/XceedZip.dll" failonerror="false" unregister="true" if="${clean}"/>
	</target>
	<!-- This was added because the automatic reference copy process when building a
		project ends up with different read/write permissions on copied files on different
		machines. The build machine failed because it was copying two files and the
		first was read-only, so it didn't copy the second. So to get around this intermittent
		problem we can add files to this target to copy files early on. -->
	<!-- Some machines fail to automatic copy some of these dlls without being listed here. -->
	<target name="CopyDlls" description="Copy Dlls to output directory">
		<copy todir="${dir.outputBase}">
			<fileset>
				<include name="${fwroot}/Bin/Interop.MSXML2.dll"/>
				<include name="${fwroot}/Bin/Interop.SHDocVw.dll"/>
				<include name="${fwroot}/Bin/AxInterop.SHDocVw.dll"/>
				<include name="${fwroot}/Bin/MsHtmHstInterop.dll"/>
				<include name="${fwroot}/DistFiles/Commons.Xml.Relaxng.dll"/>
				<include name="${dir.fwoutputlibBase}/ScrChecksInterfaces.dll"/>
				<include name="${fwroot}/DistFiles/FormLanguageSwitch.dll"/>
				<!-- The next one is required to avoid crashes on dev machine when exporting LIFT
					It's also required by the install compiler for Utilities.dll -->
				<include name="${fwroot}/DistFiles/LinqBridge.dll"/>
				<include name="${fwroot}/DistFiles/icu.net.dll"/>
				<include name="${fwroot}/DistFiles/Patr100.dll"/>

				<!-- This group are all needed for the Paratext control that allows us to display
				USFM resources. For our own code, ScriptureObjects.dll doesn't need to
				be copied, because we register it, but Nathan's code finds it another way.-->
				<include name="${fwroot}/DistFiles/FormattedEditor.dll" unless="${property::exists('remakele')}"/>
				<include name="${fwroot}/DistFiles/HelpSystem.dll" unless="${property::exists('remakele')}"/>
				<include name="${fwroot}/DistFiles/HtmlEditor.dll" unless="${property::exists('remakele')}"/>
				<include name="${fwroot}/DistFiles/LanguageEngine.dll" unless="${property::exists('remakele')}"/>
				<include name="${fwroot}/DistFiles/log4net.dll"/>
				<include name="${fwroot}/DistFiles/NetLoc.dll" unless="${property::exists('remakele')}"/>
				<include name="${fwroot}/DistFiles/ParatextShared.dll" unless="${property::exists('remakele')}"/>
				<include name="${fwroot}/DistFiles/ScriptureObjects.dll" unless="${property::exists('remakele')}"/>
				<include name="${fwroot}/DistFiles/ScriptureTextFile.dll" unless="${property::exists('remakele')}"/>
				<include name="${fwroot}/DistFiles/Utilities.dll" unless="${property::exists('remakele')}"/>
				<include name="${fwroot}/DistFiles/wrtXML.dll" unless="${property::exists('remakele')}"/>
				<include name="${fwroot}/DistFiles/XceedZip.dll"/>
				<include name="${fwroot}/Bin/NUnit/bin/lib/nunit.core.interfaces.dll"/>
				<include name="${fwroot}/DistFiles/Interop.SCRIPTUREOBJECTSLib.dll"/>
				<include name="${fwroot}/DistFiles/Interop.LANGUAGEENGINELib.dll"/>
				<include name="${fwroot}/DistFiles/Interop.SCRIPTURETEXTFILELib.dll"/>
			</fileset>
		</copy>
		<attrib readonly="false">
			<fileset basedir="${dir.outputBase}">
				<include name="Interop.MSXML2.dll"/>
				<include name="Interop.SHDocVw.dll"/>
				<include name="AxInterop.SHDocVw.dll"/>
				<include name="MsHtmHstInterop.dll"/>
				<include name="Commons.Xml.Relaxng.dll"/>
				<include name="ScrChecksInterfaces.dll"/>
				<include name="FormLanguageSwitch.dll"/>
				<include name="LinqBridge.dll"/>
				<include name="icu.net.dll"/>
				<!-- This group are all needed for the Paratext control that allows us to display
				USFM resources. For our own code, ScriptureObjects.dll doesn't need to
				be copied, because we register it, but Nathan's code finds it another way.-->
				<include name="FormattedEditor.dll"/>
				<include name="HelpSystem.dll"/>
				<include name="HtmlEditor.dll"/>
				<include name="LanguageEngine.dll"/>
				<include name="log4net.dll"/>
				<include name="NetLoc.dll"/>
				<include name="ParatextShared.dll"/>
				<include name="ScriptureObjects.dll"/>
				<include name="ScriptureTextFile.dll"/>
				<include name="Utilities.dll"/>
				<include name="wrtXML.dll"/>
				<include name="XceedZip.dll"/>
				<include name="nunit.core.interfaces.dll"/>
				<include name="Interop.SCRIPTUREOBJECTSLib.dll"/>
				<include name="Interop.LANGUAGEENGINELib.dll"/>
				<include name="Interop.SCRIPTURETEXTFILELib.dll"/>
			</fileset>
		</attrib>
	</target>
	<target name="EncConvertersDlls" description="Copy the EncodingConverters files">
		<choose>
			<when test="${platform::is-unix()}">
				<copy todir="${dir.outputBase}">
					<fileset basedir="${dir.fwoutputlibPlatformBase}">
						<include name="SilEncConverters40.dll"/>
						<include name="SilEncConverters40.dll.mdb"/>
						<include name="ECInterfaces.dll"/>
						<include name="ECInterfaces.dll.mdb"/>
						<include name="AIGuesserEC.dll"/>
						<include name="AIGuesserEC.dll.mdb"/>
						<include name="CcEC.dll"/>
						<include name="CcEC.dll.mdb"/>
						<include name="IcuEC.dll"/>
						<include name="IcuEC.dll.mdb"/>
						<include name="libIcuConvEC.so.1.0"/>
						<include name="libIcuConvEC_64.so.1.0"/>
						<include name="libIcuRegexEC.so.1.0"/>
						<include name="libIcuRegexEC_64.so.1.0"/>
						<include name="libIcuTranslitEC.so.1.0"/>
						<include name="libIcuTranslitEC_64.so.1.0"/>
						<include name="libPyScriptEncConverter.so.1.0"/>
						<include name="libPyScriptEncConverter_64.so.1.0"/>
						<include name="PerlExpressionEC.dll"/>
						<include name="PerlExpressionEC.dll.mdb"/>
						<include name="PyScriptEC.dll"/>
						<include name="PyScriptEC.dll.mdb"/>
					</fileset>
				</copy>
				<copy todir="${dir.outputBase}">
					<fileset basedir="${dir.fwoutputlibPlatform}">
						<include name="SilEncConverters40.dll.config"/>
						<include name="IcuEC.dll.config"/>
						<include name="PyScriptEC.dll.config"/>
					</fileset>
				</copy>
				<mkdir dir="${dir.outputBase}/EC/Plugins" verbose="${verbose}"/>
				<copy todir="${dir.outputBase}/EC/Plugins">
					<fileset basedir="${dir.fwoutputlibPlatform}/ECPlugins">
						<include name="AI 4.0.0.0 Plugin Details.xml"/>
						<include name="CC 4.0.0.0 Plugin Details.xml"/>
						<include name="EC 4.0.0.0 Plugin Details.xml"/>
						<include name="IcuEC 4.0.0.0 Plugin Details.xml"/>
						<include name="PerlEC 4.0.0.0 Plugin Details.xml"/>
						<include name="PythonEC 4.0.0.0 Plugin Details.xml"/>
					</fileset>
				</copy>
			</when>
			<otherwise>
				<copy todir="${dir.outputBase}">
					<fileset basedir="${dir.fwoutputlibBase}">
						<include name="SilEncConverters40.dll"/>
						<include name="SilEncConverters40.pdb"/>
						<include name="ECInterfaces.dll"/>
						<include name="ECInterfaces.pdb"/>
						<include name="AIGuesserEC.dll"/>
						<include name="AIGuesserEC.pdb"/>
						<include name="CcEC.dll"/>
						<include name="CcEC.dll.mdb"/>
						<include name="IcuEC.dll"/>
						<include name="IcuEC.pdb"/>
						<include name="IcuConvEC.dll"/>
						<include name="IcuConvEC.pdb"/>
						<include name="IcuRegexEC.dll"/>
						<include name="IcuRegexEC.pdb"/>
						<include name="IcuTranslitEC.dll"/>
						<include name="IcuTranslitEC.pdb"/>
						<include name="PyScriptEncConverter.dll"/>
						<include name="PyScriptEncConverter.pdb"/>
						<include name="PerlExpressionEC.dll"/>
						<include name="PerlExpressionEC.pdb"/>
						<include name="PyScriptEC.dll"/>
						<include name="PyScriptEC.pdb"/>
						<include name="SilIndicEncConverters40.dll"/>
						<include name="SilIndicEncConverters40.pdb"/>
					</fileset>
				</copy>
				<mkdir dir="${dir.outputBase}/EC/Plugins" verbose="${verbose}"/>
				<copy todir="${dir.outputBase}/EC/Plugins">
					<fileset basedir="${dir.fwoutputlib}/release/ECPlugins">
						<include name="AI 4.0.0.0 Plugin Details.xml"/>
						<include name="CC 4.0.0.0 Plugin Details.xml"/>
						<include name="EC 4.0.0.0 Plugin Details.xml"/>
						<include name="IcuEC 4.0.0.0 Plugin Details.xml"/>
						<include name="PerlEC 4.0.0.0 Plugin Details.xml"/>
						<include name="PythonEC 4.0.0.0 Plugin Details.xml"/>
						<include name="SIEC 4.0.0.0 Plugin Details.xml"/>
					</fileset>
				</copy>
			</otherwise>
		</choose>
	</target>
	<target name="copy-nmockDll" description="Copy the nmock files. This gets around something bizarre that breaks the build machine. remakefw ends up copying the dll, but mkall doesn't even though both use buildtest.">
		<copy todir="${dir.outputBase}">
			<fileset basedir="${fwroot}/Bin/nmock/">
				<include name="nmock.*"/>
			</fileset>
		</copy>
	</target>
  <target name="copy-uiAutomation" description="Copy the UIAutomation files. Apparently needed by NMock.DynamicMock to mock SimpleRootSite controls">
	<copy todir="${dir.outputBase}">
	  <fileset basedir="${fwroot}/DistFiles/">
		<include name="UIAutomationProvider.dll"/>
		<include name="UIAutomationTypes.dll"/>
		<include name="WindowsBase.dll"/>
	  </fileset>
	</copy>
  </target>
	<!-- -->
	<!-- projects common to C++ and C# -->
	<target name="mkdp" depends="linuxLibs" description="DebugProcs">
		<call target="mkdp-nodep" cascade="false"/>
	</target>
	<target name="mkdp-nodep" description="DebugProcs">
		<if test="${not bld-release}">
			<property name="batch-file" value="mkdp" unless="${platform::is-unix()}"/>
			<property name="batch-file" value="DebugProcs" if="${platform::is-unix()}"/>
			<call target="call-batch"/>
		</if>
	</target>
	<!-- -->
	<target name="mkGenLib" description="GenericLib"
		depends="mkdp">
		<call target="mkGenLib-nodep" cascade="false"/>
	</target>
	<target name="mkGenLib-nodep" description="GenericLib">
		<property name="output-is-lib" value="true"/>
		<property name="batch-file" value="mkGenLib" unless="${platform::is-unix()}"/>
		<property name="batch-file" value="Generic" if="${platform::is-unix()}"/>
		<call target="call-batch"/>
		<property name="output-is-lib" value="false"/>
	</target>
	<!-- -->
	<target name="icudlls">
		<if test="${showTargetsRunInReport}">
			<property name="appTargName" value="icudlls"/>
			<call target="appendTargetName"/>
		</if>
		<!-- Only one of these two will be done. -->
		<call target="copy-icudlls" unless="${clean}" cascade="false"/>
		<call target="clean-icudlls" if="${clean}" cascade="false"/>
	</target>
	<!-- -->
	<target name="copy-icudlls" description="Copy ICU dlls to an accessible place">
		<copy todir="${dir.outputBase}">
			<fileset basedir="${dir.fwoutputlibBase}">
				<include name="icu*.dll"/>
				<include name="icu*.pdb"/>
			</fileset>
		</copy>
		<copy todir="${dir.outputBase}">
			<fileset basedir="${dir.fwoutputlib}">
				<include name="icu*.dll"/>
			</fileset>
		</copy>
		<delete dir="${dir.fwdistfiles}/SIL/Repository" failonerror="false" if="${platform::is-unix()}"/>
		<choose>
			<when test="${user::is-admin() or platform::is-unix()}">
				<writeregistry hive="LocalMachine" key="SOFTWARE\SIL\FieldWorks\${fwversion}.0\RootCodeDir" value="${dir.fwdistfiles}" verbose="${verbose}"/>
				<writeregistry hive="LocalMachine" key="SOFTWARE\SIL\FieldWorks\${fwversion}.0\RootDataDir" value="${dir.fwdistfiles}" verbose="${verbose}" />
				<writeregistry hive="LocalMachine" key="SOFTWARE\SIL\FieldWorks\${fwversion}.0\ProjectsDir" value="${path::combine(dir.fwdistfiles, 'Projects')}" verbose="${verbose}" />
				<writeregistry hive="LocalMachine" key="SOFTWARE\SIL\Icu40DataDir" value="${dir.icuData}" verbose="${verbose}" />
				<writeregistry hive="LocalMachine" key="SOFTWARE\SIL\Icu40Dir" value="${dir.icu}"
					 verbose="${verbose}" />
				<property name="tmpLib" value="${path::combine(fwroot, 'Lib')}"/>
				<property name="tmp" value="${path::combine(tmpLib, 'Release')}"/>
				<writeregistry hive="LocalMachine" key="SOFTWARE\SIL\SilEncConverters40\RootDir" value="${tmp}" verbose="${verbose}"  unless="${platform::is-unix()}"/>
				<writeregistry hive="LocalMachine" key="SOFTWARE\SIL\SilEncConverters40\PluginDir" value="${path::combine(tmp, 'Plugins')}" verbose="${verbose}" unless="${platform::is-unix()}"/>
				<writeregistry hive="LocalMachine" key="SOFTWARE\SIL\SilEncConverters40\RootDir" value="${dir.outputBase}" verbose="${verbose}"  if="${platform::is-unix()}"/>
				<writeregistry hive="LocalMachine" key="SOFTWARE\SIL\SilEncConverters40\PluginDir" value="${path::combine(dir.outputBase, 'EC/Plugins')}" verbose="${verbose}" if="${platform::is-unix()}"/>
			</when>
			<otherwise>
				<readregistry property="rootCodeDir" hive="LocalMachine" key="SOFTWARE\SIL\FieldWorks\${fwversion}.0\RootCodeDir" failonerror="false" verbose="${verbose}"/>
				<readregistry property="rootDataDir" hive="LocalMachine" key="SOFTWARE\SIL\FieldWorks\${fwversion}.0\RootDataDir" failonerror="false" verbose="${verbose}"/>
				<readregistry property="projectsDir" hive="LocalMachine" key="SOFTWARE\SIL\FieldWorks\${fwversion}.0\ProjectsDir" failonerror="false" verbose="${verbose}"/>
				<readregistry property="icu40DataDir" hive="LocalMachine" key="SOFTWARE\SIL\Icu40DataDir" failonerror="false" verbose="${verbose}"/>
				<readregistry property="icu40Dir" hive="LocalMachine" key="SOFTWARE\SIL\Icu40Dir" failonerror="false" verbose="${verbose}"/>
				<readregistry property="ecRootDir" hive="LocalMachine" key="SOFTWARE\SIL\SilEncConverters40\RootDir" failonerror="false" verbose="${verbose}"/>
				<readregistry property="ecPluginDir" hive="LocalMachine" key="SOFTWARE\SIL\SilEncConverters40\PluginDir" failonerror="false" verbose="${verbose}"/>
				<property name="updateRegistry" value="${not property::exists('rootCodeDir') or not property::exists('rootDataDir') or not property::exists('projectsDir')
						  or not property::exists('icu40DataDir') or not property::exists('icu40Dir') or not property::exists('ecRootDir')
						  or not property::exists('ecPluginDir')}" verbose="${verbose}"/>
				<property name="updateRegistry" value="${rootCodeDir != dir.fwdistfiles or rootDataDir != dir.fwdistfiles or projectsDir != path::combine(dir.fwdistfiles, 'Projects')
						  or icu40DataDir != dir.icuData or icu40Dir != dir.icu or ecRootDir != path::combine(path::combine(fwroot, 'Lib'), 'Release')
						  or ecPluginDir != path::combine(path::combine(path::combine(fwroot, 'Lib'), 'Release'), 'Plugins')}"
						  unless="${updateRegistry}" verbose="${verbose}"/>

				<if test="${updateRegistry}">
					<echo message='reg.exe add HKLM/SOFTWARE/SIL/FieldWorks/${fwversion}.0 /v RootCodeDir /d "${dir.fwdistfiles}" /f
'
						  file="${dir.outputBase}/updateRegistry.cmd" append="false" verbose="${verbose}"/>
					<echo message='reg.exe add HKLM/SOFTWARE/SIL/FieldWorks/${fwversion}.0 /v RootDataDir /d "${dir.fwdistfiles}" /f
'
						  file="${dir.outputBase}/updateRegistry.cmd" append="true" verbose="${verbose}"/>
					<property name="tmp" value="${path::combine(dir.fwdistfiles, 'Projects')}"/>
					<echo message='reg.exe add HKLM/SOFTWARE/SIL/FieldWorks/${fwversion}.0 /v ProjectsDir /d "${tmp}" /f
'
						  file="${dir.outputBase}/updateRegistry.cmd" append="true" verbose="${verbose}"/>

					<echo message='reg.exe add HKLM/SOFTWARE/SIL /v Icu40DataDir /d "${dir.icuData}" /f
'
						  file="${dir.outputBase}/updateRegistry.cmd" append="true" verbose="${verbose}"/>
					<echo message='reg.exe add HKLM/SOFTWARE/SIL /v Icu40Dir /d "${dir.icu}" /f
'
						  file="${dir.outputBase}/updateRegistry.cmd" append="true" verbose="${verbose}"/>

					<property name="tmpLib" value="${path::combine(fwroot, 'Lib')}"/>
					<property name="tmp" value="${path::combine(tmpLib, 'Release')}"/>
					<echo message='reg.exe add HKLM\SOFTWARE\SIL\SilEncConverters40 /v RootDir /d "${tmp}" /f
'
						  file="${dir.outputBase}\updateRegistry.cmd" append="true" verbose="${verbose}"/>

					<property name="tmp" value="${path::combine(tmp, 'Plugins')}"/>
					<echo message='reg.exe add HKLM\SOFTWARE\SIL\SilEncConverters40 /v PluginDir /d "${tmp}" /f
'
						  file="${dir.outputBase}\updateRegistry.cmd" append="true" verbose="${verbose}"/>

					<property name="cmdFileContent" value=""/>
					<loadfile file="${dir.outputBase}/updateRegistry.cmd" property="cmdFileContent" if="${verbose}"/>
					<echo message="Content of batch file ${dir.outputBase}/updateRegistry.cmd:" if="${verbose}"/>
					<echo message="${cmdFileContent}" if="${verbose}"/>
					<echo message="" if="${verbose}"/>

					<echo message="Writing settings to registry"/>
					<exec program="${nant::get-base-directory()}/tasks/elevator.exe"
						  commandline='"${dir.outputBase}/updateRegistry.cmd"'/>
				</if>
			</otherwise>
		</choose>
	</target>
	<!-- -->
	<target name="clean-icudlls" description="Delete copied ICU dlls">
		<delete failonerror="false">
			<fileset basedir="${dir.outputBase}/">
				<include name="icu*.dll"/>
				<include name="icu*.pdb"/>
			</fileset>
		</delete>
	</target>
	<!-- -->
	<target name="mkfwk" description="FwKernel" depends="mkGenLib,GenerateFilesFromModel">
		<call target="mkfwk-nodep" cascade="false"/>
	</target>
	<target name="mkfwk-nodep" description="FwKernel">
		<property name="batch-file" value="mkfwk" unless="${platform::is-unix()}"/>
		<property name="batch-file" value="Kernel" if="${platform::is-unix()}"/>
		<call target="call-batch"/>
	</target>
	<!-- -->
	<target name="ManagedVwDrawRootBuffered" description="ManagedVwDrawRootBuffered" depends="COMInterfaces,BasicUtils">
		<call target="ManagedVwDrawRootBuffered-nodep" cascade="false"/>
	</target>
	<target name="ManagedVwDrawRootBuffered-nodep">
		<property name="dir.srcProj" value="${fwroot}/Src/ManagedVwDrawRootBuffered"/>
		<call target="vsconvert-convert"/>
		<echo message="97199458-10C7-49da-B3AE-EA922EA64859 libManagedComBridge.so ManagedVwDrawRootBuffered.dll SIL.FieldWorks.Views.VwDrawRootBuffered
"
			file="${dir.outputBase}/ManagedVwDrawRootBuffered.compmap" append="false"
			if="${platform::is-unix()}"/>
		<echo message="D9E9D65F-E81F-439e-8010-5B22BAEBB92D libManagedComBridge.so
"
			file="${dir.outputBase}/ManagedVwDrawRootBuffered.compmap" append="true"
			if="${platform::is-unix()}"/>
		<call target="rebuild-compmap" cascade="true" if="${platform::is-unix()}"/>
	</target>
	<!-- -->
	<target name="KeyboardSwitcher" description="KeyboardSwitcher" depends="COMInterfaces,BasicUtils">
			<call target="KeyboardSwitcher-nodep" cascade="false"/>
	</target>
	<target name="KeyboardSwitcher-nodep">
		<property name="dir.srcProj" value="${fwroot}/Src/Common/KeyboardSwitcher"/>
		<call target="vsconvert-convert"/>
		<echo message="4ED1E8bC-DAdE-11DE-B350-0019DBf4566E libManagedComBridge.so KeyboardSwitcher.dll SIL.FieldWorks.Views.KeyboardSwitcher
"
			file="${dir.outputBase}/KeyboardSwitcher.compmap" append="false"
			if="${platform::is-unix()}"/>
		<echo message="4D2BC310-DADF-11DE-9E3A-0019DBF4566E libManagedComBridge.so
"
			file="${dir.outputBase}/KeyboardSwitcher.compmap" append="true"
			if="${platform::is-unix()}"/>
		<call target="rebuild-compmap" cascade="true" if="${platform::is-unix()}"/>
	</target>
	<!-- -->
	<target name="Keyboarding" description="Keyboard utils"
		depends="COMInterfaces,KeyboardSwitcher">
			<call target="Keyboarding-nodep" cascade="false"/>
	</target>
	<target name="Keyboarding-nodep">
		<property name="dir.srcProj" value="${fwroot}/Src/Common/Keyboarding"/>
		<call target="vsconvert-convert"/>
	</target>
	<!-- -->
	<target name="ManagedLgIcuCollator" description="ManagedLgIcuCollator" depends="COMInterfaces,BasicUtils">
			<call target="ManagedLgIcuCollator-nodep" cascade="false" if="${platform::is-unix()}"/>
	</target>
	<target name="ManagedLgIcuCollator-nodep">
		<property name="dir.srcProj" value="${fwroot}/Src/ManagedLgIcuCollator"/>
		<call target="vsconvert-convert"/>
			<echo message="e771361c-ff54-4120-9525-98a0b7a9accf libManagedComBridge.so ManagedLgIcuCollator.dll SIL.FieldWorks.Language.ManagedLgIcuCollator
"
			file="${dir.outputBase}/ManagedLgIcuCollator.compmap" append="false"
			if="${platform::is-unix()}"/>
		<call target="rebuild-compmap" cascade="true" if="${platform::is-unix()}"/>
	</target>
	<!-- -->
	<target name="ManagedVwWindow" description="ManagedVwWindow" depends="COMInterfaces,BasicUtils">
			<call target="ManagedVwWindow-nodep" cascade="false" if="${platform::is-unix()}"/>
	</target>
	<target name="ManagedVwWindow-nodep">
		<property name="dir.srcProj" value="${fwroot}/Src/ManagedVwWindow"/>
		<call target="vsconvert-convert"/>
		<echo message="3fb0fcd2-ac55-42a8-b580-73b89a2b6215 libManagedComBridge.so ManagedVwWindow.dll SIL.FieldWorks.Views.ManagedVwWindow
"
			file="${dir.outputBase}/ManagedVwWindow.compmap" append="false"
			if="${platform::is-unix()}"/>
		<echo message="8856396c-63a9-4bc7-ad47-87ec8b6ef5a4 libManagedComBridge.so
"
			file="${dir.outputBase}/ManagedVwWindow.compmap" append="true"
			if="${platform::is-unix()}"/>
		<call target="rebuild-compmap" cascade="true" if="${platform::is-unix()}"/>
	</target>
	<!-- -->
	<target name="mklg" description="Language" depends="mkfwk,ManagedLgIcuCollator,GenerateFilesFromModel">
		<call target="mklg-nodep" cascade="false"/>
	</target>
	<target name="mklg-nodep" description="Language">
		<property name="batch-file" value="mklg" unless="${platform::is-unix()}"/>
		<property name="batch-file" value="Language" if="${platform::is-unix()}"/>
		<call target="call-batch"/>
	</target>
	<!-- -->
	<target name="mkvw" description="Views" depends="mklg,mktlbs,KeyboardSwitcher,GenerateFilesFromModel">
		<call target="mkvw-nodep" cascade="false"/>
	</target>
	<target name="mkvw-nodep" description="Views">
		<property name="batch-file" value="mkvw" unless="${platform::is-unix()}"/>
		<property name="batch-file" value="views" if="${platform::is-unix()}"/>
		<call target="call-batch"/>
	</target>
	<!-- -->
	<target name="mktlbs" description="TLB for Language,Views,FwKernel"
		depends="Version" unless="${platform::is-unix()}">
		<!-- TODO-Linux: not ported yet - maybe need to do this one? -->
		<!-- These properties are passed to command line, so we have to use backslash on Windows. -->
		<!-- (or do a path::combine) -->
		<property name="bld_makefile" value="${fwroot}\Src\Language\Language.mak"/>
		<property name="bld_targets" value="dirs ${dir.fwoutputCommon}\LanguageTlb.tlb"/>
		<call target="call-make"/>

		<property name="bld_makefile" value="${fwroot}\Src\Kernel\FwKernel.mak"/>
		<property name="bld_targets" value="dirs ${dir.fwoutputCommon}\FwKernelTlb.tlb"/>
		<call target="call-make"/>

		<property name="bld_makefile" value="${fwroot}\Src\views\Views.mak"/>
		<property name="bld_targets" value="dirs ${dir.fwoutputCommon}\ViewsTlb.tlb"/>
		<call target="call-make"/>
	</target>
	<target name="call-make">
		<exec program="nmake"
			commandline="/nologo /f ${bld_makefile} ${bld_targets}"
			workingdir="${fwroot}" verbose="${verbose}">
			<environment>
				<variable name="BUILD_ROOT" value="${fwroot}"/>
				<variable name="BUILD_TYPE" value="${build-type}"/>
				<variable name="BUILD_CONFIG" value="${config}"/>
				<variable name="BUILD4UX" value="${build4ux}"/>
				<variable name="ANAL_TYPE" value="performance" if="${property::exists('performance')}"/>
			</environment>
		</exec>
	</target>
	<!-- -->
	<target name="Version" description="Create version info for C++ projects">
		<if test="${not file::up-to-date(path::combine(fwroot, 'Src/bldinc.h'), path::combine(dir.fwoutputCommon, 'bldinc.h'))}">
			<mkdir dir="${dir.fwoutputCommon}"/>
			<versionex output="${dir.fwoutputCommon}/bldinc.h">
				<sources>
					<include name="${fwroot}/Src/bldinc.h"/>
				</sources>
			</versionex>
		</if>
	</target>
	<!-- -->
	<target name="register-So" description="Register ScriptureOjects and ECOjects files"
		depends="">
		<property name="dir.PTSOBase" value="${fwroot}/DistFiles"/>
		<choose unless="${platform::is-unix()}">
			<when test="${user::is-admin()}">
				<!-- register the Paratext ScriptureObjects.dll -->
				<echo message="Register the Paratext ScriptureObject.dll File in: ${dir.PTSOBase}"/>
				<exec program="regsvr32.exe" commandline="/s ${dir.PTSOBase}/ScriptureObjects.dll"/>
			</when>
			<otherwise>
				<copy file="${dir.PTSOBase}/ScriptureObjects.dll" todir="${path::get-temp-path()}"/>
				<checksum algorithm="MD5">
					<fileset>
						<include name="${path::combine(path::get-temp-path(), 'ScriptureObjects.dll')}"/>
					</fileset>
				</checksum>
				<property name="SOChanged" value="true"/>
				<if test="${file::exists(dir.PTSOBase + '\ScriptureObjects.dll.MD5')}">
					<loadfile property="newSo" file="${path::combine(path::get-temp-path(), 'ScriptureObjects.dll')}"/>
					<loadfile property="oldSo" file="${dir.PTSOBase}\ScriptureObjects.dll.MD5" />
					<property name="SOChanged" value="${newSo != oldSo}"/>
				</if>
				<!-- If ScriptureObjects didn't change then we have nothing to do. Otherwise we register with admin privileges -->
				<if test="${SOChanged}">
					<echo message="Register the Paratext ScriptureObject.dll File in: ${dir.PTSOBase} with admin privileges"/>
					<exec program="${nant::get-base-directory()}/tasks/elevator.exe"
						  commandline="regsvr32.exe /s ${dir.PTSOBase}/ScriptureObjects.dll"/>
					<copy file="${path::combine(path::get-temp-path(), 'ScriptureObjects.dll.MD5')}"
						  todir="${dir.PTSOBase}"/>
				</if>
			</otherwise>
		</choose>
	</target>
	<!-- -->
	<!-- We NEED to build some type libraries very early on without compiling the entire DLL
		they represent due to circular build dependencies.  Life is simpler if we go ahead and
		build the Interop DLLs as well at this time.
	<target name="mkall-tlb" description="Build Type Libraries"
		depends="mkecob-tlb"/>-->
	<!-- -->
	<!-- Libraries -->
	<target name="mkWidgLib" description="Widget Library" depends="mkvw,FwCoreDlgs">
		<call target="mkWidgLib-nodep" cascade="false"/>
	</target>
	<target name="mkWidgLib-nodep" description="Widget Library">
		<!-- TODO-Linux: not ported yet -->
		<property name="output-is-lib" value="true"/>
		<property name="batch-file" value="mkWidgLib"/>
		<call target="call-batch" unless="${platform::is-unix()}"/>
		<property name="output-is-lib" value="false"/>
	</target>
	<!-- -->
	<target name="mkgrc" description="Graphite compiler" depends="mkGenLib,mkfwk">
		<call target="mkgrc-nodep" cascade="false"/>
	</target>
	<target name="mkgrc-nodep" description="Graphite compiler">
		<!-- TODO-Linux: not ported yet -->
		<property name="batch-file" value="mkgrc"/>
		<call target="call-batch" unless="${platform::is-unix()}"/>
	</target>
	<!-- -->
	<target name="mkgre" description="Graphite engine" depends="mkGenLib,mkfwk,mkvw">
		<call target="mkgre-nodep" cascade="false"/>
	</target>
	<target name="mkgre-nodep" description="Graphite engine">
		<property name="batch-file" value="mkgre" unless="${platform::is-unix()}"/>
		<property name="batch-file" value="Graphite-GrEngine" if="${platform::is-unix()}"/>
		<call target="call-batch"/>
	</target>
	<!-- -->
	<!-- Tests -->
	<target name="mktsth" description="Tests" depends="mkGenLib">
		<call target="mktsth-nodep" cascade="false"/>
	</target>
	<target name="mktsth-nodep" description="Tests" unless="${platform::is-unix()}">
		<!-- TODO-Linux: not ported yet -->
		<property name="batch-file" value="mktsth"/>
		<call target="call-batch" unless="${bld-release}"/>
	</target>
	<!-- -->
	<target name="mktstw" description="Tests" depends="mkGenLib,mkWidgLib">
		<call target="mktstw-nodep" cascade="false"/>
	</target>
	<target name="mktstw-nodep" description="Tests" unless="${platform::is-unix()}">
		<!-- TODO-Linux: not ported yet -->
		<property name="batch-file" value="mktstw"/>
		<call target="call-batch" unless="${bld-release}"/>
	</target>
	<!-- -->
	<target name="mkGenLib-tst" description="Tests"
		depends="mkGenLib">
		<call target="mkGenLib-tst-nodep" cascade="false"/>
	</target>
	<target name="mkGenLib-tst-nodep" description="Tests">
		<property name="batch-file" value="mkGenLib-tst" unless="${platform::is-unix()}"/>
		<property name="batch-file" value="generic" if="${platform::is-unix()}"/>
		<property name="test-exe" value="GenericLib"/>
		<call target="run-cpptest" unless="${bld-release}"/>
	</target>
	<!-- -->
	<target name="mkfwk-tst" description="Tests" depends="mkfwk">
		<call target="mkfwk-tst-nodep" cascade="false"/>
	</target>
	<target name="mkfwk-tst-nodep" description="Tests">
		<property name="batch-file" value="mkfwk-tst" unless="${platform::is-unix()}"/>
		<property name="batch-file" value="kernel" if="${platform::is-unix()}"/>
		<property name="test-exe" value="FwKernel"/>
		<call target="run-cpptest" unless="${bld-release}"/>
	</target>
	<!-- -->
	<target name="mklg-tst" description="Tests" depends="mklg,mkfwk,mkgre">
		<call target="mklg-tst-nodep" cascade="false"/>
	</target>
	<target name="mklg-tst-nodep" description="Tests">
		<property name="batch-file" value="mklg-tst" unless="${platform::is-unix()}"/>
		<property name="batch-file" value="language" if="${platform::is-unix()}"/>
		<property name="test-exe" value="Language"/>
		<call target="run-cpptest" unless="${bld-release}"/>
	</target>
	<!-- -->
	<target name="mkvw-tst" description="Tests"
		depends="mkvw,mkgre">
		<call target="mkvw-tst-nodep" cascade="false"/>
	</target>
	<target name="mkvw-tst-nodep" description="Tests">
		<property name="batch-file" value="mkvw-tst" unless="${platform::is-unix()}"/>
		<property name="batch-file" value="views" if="${platform::is-unix()}"/>
		<property name="test-exe" value="Views"/>
		<call target="run-cpptest" unless="${bld-release}"/>
	</target>
	<!-- -->
	<!-- ************************************************************************************ -->
	<!-- Do not add anything below this line -->
	<!-- Additional helper targets -->
	<target name="run-cpptest" description="Builds and runs a C++ test">
		<property name="test-exe-path" value="${dir.outputBase}\test${test-exe}.exe" unless="${platform::is-unix()}"/>
		<property name="test-exe-path" value="${dir.outputBase}/test${test-exe}" if="${platform::is-unix()}"/>
		<delete file="${test-exe-path}-failed-results.xml" failonerror="false" />

		<!-- build the tests -->
		<if test="${not property::exists('batch-working-dir')}">
			<property name="batch-working-dir" value="${fwroot}/Bin"/>
		</if>
		<exec program="cmd.exe" commandline="/c ${fwroot}/Bin/testWrapper.cmd ${batch-file}.bat DONTRUN"
			workingdir="${batch-working-dir}"
			  unless="${platform::is-unix()}"/>
		<exec program="make" commandline="${batch-file}-Test"
			workingdir="${fwroot}" verbose="${verbose}"
			if="${platform::is-unix()}"/>
		<!-- I think the manifest file is needed only on MS Windows. -->
		<property name="executable" value="${test-exe-path}" unless="${platform::is-unix()}"/>
		<call target="regfree" cascade="true" unless="${platform::is-unix()}"/>

		<call target="run-cpptest-internal" failonerror="false"/>

		<if test="${fw-test-core-error}">
			<move file="${test-exe-path}-results.xml" tofile="${test-exe-path}-failed-results.xml" failonerror="false" />
			<property name="fw-test-error" value="${fw-test-error};${batch-file}" if="${property::exists('fw-test-error')}"/>
			<property name="fw-test-error" value="${batch-file}" unless="${property::exists('fw-test-error')}"/>
			<echo message="********* At least one test for ${batch-file} failed ********" />
		</if>
	</target>
	<!-- -->
	<target name="run-cpptest-internal" description="Run the tests. Shouldn't be called directly">
		<!--Set ${{fw-test-core-error}} to true and at the end to false. If batch file fails,
					${{fw-test-core-error}} will remain true, so we know if anything happened-->
		<property name="fw-test-core-error" value="true" />

		<uptodate property="done" verbose="${verbose}">
			<sourcefiles>
				<include name="${test-exe-path}"/>
				<include name="${dir.outputBase}/${test-exe}.dll"/>
			</sourcefiles>
			<targetfiles>
				<include name="${test-exe-path}-results.xml"/>
			</targetfiles>
		</uptodate>
		<if test="${not done or forcetests or property::exists('noCompare')}">
			<unitpp path="${test-exe-path}" verbose="${verbose}" if="${doTest}" />
		</if>
		<property name="fw-test-core-error" value="false" />
	</target>
	<!-- -->
	<target name="call-batch" description="Calls a batch file">
		<tstamp/>
		<if test="${not platform::is-unix()}">
			<property name="fw-call-batch-error" value="false"/>
			<call target="call-batch-internal" failonerror="false" unless="${clean}"/>
			<if test="${fw-call-batch-error}">
				<if test="${not property::exists('fw-build-error')}">
					<property name="fw-build-error" value="********* ${batch-file}.bat failed ********"/>
					<fail message="${fw-build-error}"/>
				</if>
			</if>
		</if>
		<if test="${platform::is-unix()}">
			<exec program="make" commandline="${batch-file}-clean"
				workingdir="${fwroot}" verbose="${verbose}"
				if="${build-action == 'cc' or clean}"/>
			<exec program="make" commandline="${batch-file}-nodep"
				workingdir="${fwroot}" verbose="${verbose}"
				unless="${clean}"/>
			<call target="rebuild-compmap" unless="${clean}"/>
		</if>
	</target>
	<!-- -->
	<target name="call-batch-internal" description="Calls a batch file">
		<!-- set ${fw-build-core-error} to true and at the end to false. If batch file fails,
			${fw-build-core-error} will remain true, so we know if anything happened -->
		<property name="fw-call-batch-error" value="true"/>
		<property name="extra-params" value=""/>
		<if test="${property::exists('cpp-extra-params')}">
			<property name="extra-params" value="${cpp-extra-params}"/>
		</if>
		<property name="_output-dir" value="${dir.outputBase}"/>
		<property name="_output-dir" value="${dir.fwoutputlibBase}" if="${output-is-lib}"/>
		<if test="${not property::exists('batch-working-dir')}">
			<property name="batch-working-dir" value="${fwroot}/bin"/>
		</if>
		<if test="${showTargetsRunInReport}">
			<property name="appTargName" value="${batch-file}"/>
			<call target="appendTargetName"/>
		</if>
		<!-- if we're running as a limited user (Vista with UAC enabled) we have to register the DLL in HKCU -->
		<setenv name="REGSVR_OPTS" value="/n /i:user" unless="${user::is-admin()}"/>
		<setenv name="ISLUA" value="1" unless="${user::is-admin()}"/>
		<exec program="cmd.exe" commandline="/c ${fwroot}/Bin/wrapper.cmd ${_output-dir} ${dir.fwoutputCommon} ${dir.fwobj} ${batch-file}.bat ${build-type} ${build-action} ${extra-params}"
			workingdir="${batch-working-dir}" verbose="${verbose}"/>
		<property name="fw-call-batch-error" value="false"/>
	</target>
</project>
