<?xml version="1.0" encoding="UTF-8"?>
<!-- Include for make all C++ code of FieldWorks -->
<!--
	This include file contains all the targets that used to be in mkall.bat
	We had to replace mkall.bat because in order to run C# test directly with
	the project to which they belong.

	Eventually this file should go away when the C++ files will be built
	by NAnt.
-->
<project name="mkall" default="mkall" xmlns="http://fieldworks.sil.org/nant/fwnant.xsd" >
	<!-- -->
	<target name="mkall-jenkins" description="mkall target for Jenkins CI" depends="mkall">
		<if test="${property::exists('fw-build-error')}">
				<fail message="${fw-build-error}"/>
		</if>
	</target>
	<!-- generic targets -->
	<target name="mkall" description="Make all of FieldWorks" depends="initLinux">
		<tstamp/>
		<call target="mkall-internal" failonerror="false" cascade="false"/>
		<tstamp/>
		<if test="${fw-mkall-internal-error and (not property::exists('fw-build-error'))}">
			<property name="fw-build-error" value="********* mkall failed ********"/>
		</if>
	</target>
	<!-- -->
	<target name="mkall-internal" description="Make all of FieldWorks - don't call directly">
		<!-- set ${fw-mkall-internal-error} to true and at the end to false. If batch file fails,
			${fw-mkall-internal-error} will remain true, so we know if anything happened -->
		<property name="fw-mkall-internal-error" value="true"/>
		<call target="icudlls" failonerror="false" cascade="false"/>
		<call target="mkall-internal-core" cascade="false"/>
		<property name="fw-mkall-internal-error" value="false"/>
	</target>
	<!-- -->
	<target name="mkall-internal-core" description="Make all of FieldWorks - don't call directly"
		depends="FDOBrowser,LexTextExe,allTe,UnicodeCharEditor,MigrateSqlDbs,mkall-tst">
		<!--
			Only put exes in the 'depends' of this target.
			Those exes (and their related dlls can worry about the finer points of what they depend on,
			either as compile time dependencies or as runtime dependencies.
			[Note: The ordering of the non-test exes is chronological.
			That is, they are listed in the order in which they were brought online in the new architecture.]
		-->
	</target>
	<!-- -->
	<target name="FDOBrowser" description="Build FDO Browser project." depends="BasicUtils,COMInterfaces,DetailControls,FDO,FwControls,Framework,FwUtils,ObjectBrowser,Widgets,xCoreInterfaces,XMLViews">
		<call target="FDOBrowser-nodep" cascade="false"/>
	</target>
	<target name="FDOBrowser-nodep">
		<property name="dir.srcProj" value="${fwroot}/Src/FDOBrowser"/>
		<call target="vsconvert-convert"/>
		<!-- I think the manifest file is needed only on MS Windows. -->
		<property name="executable" value="${dir.outputBase}/FDOBrowser.exe" unless="${platform::is-unix()}"/>
		<call target="regfree" cascade="true" unless="${platform::is-unix()}"/>
	</target>
	<!-- -->
	<target name="mkall-errorhandling" description="Call mkall, but handles errors">
		<call target="mkall-internal" failonerror="false" cascade="false"/>
		<if test="${fw-mkall-internal-error}">
			<if test="${property::exists('fw-build-error')}">
				<property name="fw-build-error" value="${fw-build-error}; mkall (${config}) failed"/>
			</if>
			<if test="${not property::exists('fw-build-error')}">
				<property name="fw-build-error" value="mkall (${config}) failed"/>
			</if>
		</if>
	</target>
	<!-- -->
	<target name="mkall-localize" description="both mkall and localize"
		depends="mkall,localize">
		<echo message="Finished 'mkall-localize' target."/>
	</target>
	<!-- -->
	<target name="mkall-localize-errorhandling" description="both mkall-errorhandling and localize"
		depends="mkall-errorhandling,localize">
		<echo message="Finished 'mkall-localize-errorhandling' target."/>
	</target>
	<!--
		C++ tests are compiled always with debug turned on,
		so there's no reason to run them in release builds.
	-->
	<target name="mkall-tst" depends="mkGenLib-tst,mkfwk-tst,mklg-tst,mkvw-tst" />
	<!-- -->
	<!-- special targets -->
	<target name="XceedZipDll" description="Register the Xceed Zip DLL">
		<!-- NB: Only one of these will be run. -->
		<comregisterex file="${fwroot}/DistFiles/XceedZip.dll" failonerror="false" unless="${clean}"/>
		<comregisterex file="${fwroot}/DistFiles/XceedZip.dll" failonerror="false" unregister="true" if="${clean}"/>
	</target>
	<!-- This was added because the automatic reference copy process when building a
		project ends up with different read/write permissions on copied files on different
		machines. The build machine failed because it was copying two files and the
		first was read-only, so it didn't copy the second. So to get around this intermittent
		problem we can add files to this target to copy files early on. -->
	<!-- Some machines fail to automatic copy some of these dlls without being listed here. -->
	<target name="CopyDlls" description="Copy Dlls to output directory">
		<copy todir="${dir.outputBase}">
			<fileset>
				<include name="${fwroot}/Bin/Interop.MSXML2.dll"/>
				<include name="${fwroot}/Bin/Interop.SHDocVw.dll"/>
				<include name="${fwroot}/Bin/AxInterop.SHDocVw.dll"/>
				<include name="${fwroot}/Bin/MsHtmHstInterop.dll"/>
				<include name="${fwroot}/DistFiles/Commons.Xml.Relaxng.dll"/>
				<include name="${dir.fwoutputlibBase}/ScrChecksInterfaces.dll"/>
				<include name="${fwroot}/DistFiles/FormLanguageSwitch.dll"/>
				<!-- The next one is required to avoid crashes on dev machine when exporting LIFT
					It's also required by the install compiler for Utilities.dll -->
				<include name="${fwroot}/DistFiles/LinqBridge.dll"/>
				<include name="${fwroot}/DistFiles/icu.net.dll"/>
				<include name="${fwroot}/DistFiles/Patr100.dll"/>

				<!-- This group are all needed for the Paratext control that allows us to display
				USFM resources. For our own code, ScriptureObjects.dll doesn't need to
				be copied, because we register it, but Nathan's code finds it another way.-->
				<include name="${fwroot}/DistFiles/FormattedEditor.dll" unless="${property::exists('remakele')}"/>
				<include name="${fwroot}/DistFiles/HelpSystem.dll" unless="${property::exists('remakele')}"/>
				<include name="${fwroot}/DistFiles/HtmlEditor.dll" unless="${property::exists('remakele')}"/>
				<include name="${fwroot}/DistFiles/LanguageEngine.dll" unless="${property::exists('remakele')}"/>
				<include name="${fwroot}/DistFiles/log4net.dll"/>
				<include name="${fwroot}/DistFiles/NetLoc.dll" unless="${property::exists('remakele')}"/>
				<include name="${fwroot}/DistFiles/ParatextShared.dll" unless="${property::exists('remakele')}"/>
				<include name="${fwroot}/DistFiles/ScriptureObjects.dll" unless="${property::exists('remakele')}"/>
				<include name="${fwroot}/DistFiles/ScriptureTextFile.dll" unless="${property::exists('remakele')}"/>
				<include name="${fwroot}/DistFiles/Utilities.dll" unless="${property::exists('remakele')}"/>
				<include name="${fwroot}/DistFiles/wrtXML.dll" unless="${property::exists('remakele')}"/>
				<include name="${fwroot}/DistFiles/XceedZip.dll"/>
				<include name="${fwroot}/Bin/NUnit/bin/lib/nunit.core.interfaces.dll"/>
				<include name="${fwroot}/DistFiles/Interop.SCRIPTUREOBJECTSLib.dll"/>
				<include name="${fwroot}/DistFiles/Interop.LANGUAGEENGINELib.dll"/>
				<include name="${fwroot}/DistFiles/Interop.SCRIPTURETEXTFILELib.dll"/>
			</fileset>
		</copy>
		<attrib readonly="false">
			<fileset basedir="${dir.outputBase}">
				<include name="Interop.MSXML2.dll"/>
				<include name="Interop.SHDocVw.dll"/>
				<include name="AxInterop.SHDocVw.dll"/>
				<include name="MsHtmHstInterop.dll"/>
				<include name="Commons.Xml.Relaxng.dll"/>
				<include name="ScrChecksInterfaces.dll"/>
				<include name="FormLanguageSwitch.dll"/>
				<include name="LinqBridge.dll"/>
				<include name="icu.net.dll"/>
				<!-- This group are all needed for the Paratext control that allows us to display
				USFM resources. For our own code, ScriptureObjects.dll doesn't need to
				be copied, because we register it, but Nathan's code finds it another way.-->
				<include name="FormattedEditor.dll"/>
				<include name="HelpSystem.dll"/>
				<include name="HtmlEditor.dll"/>
				<include name="LanguageEngine.dll"/>
				<include name="log4net.dll"/>
				<include name="NetLoc.dll"/>
				<include name="ParatextShared.dll"/>
				<include name="ScriptureObjects.dll"/>
				<include name="ScriptureTextFile.dll"/>
				<include name="Utilities.dll"/>
				<include name="wrtXML.dll"/>
				<include name="XceedZip.dll"/>
				<include name="nunit.core.interfaces.dll"/>
				<include name="Interop.SCRIPTUREOBJECTSLib.dll"/>
				<include name="Interop.LANGUAGEENGINELib.dll"/>
				<include name="Interop.SCRIPTURETEXTFILELib.dll"/>
			</fileset>
		</attrib>
	</target>
	<target name="EncConvertersDlls" description="Copy and Register the EncodingConverters files">
		<copy todir="${dir.outputBase}">
			<fileset basedir="${dir.fwoutputlibBase}">
				<include name="SilEncConverters40.dll"/>
				<include name="SilEncConverters40.pdb"/>
				<include name="ECInterfaces.dll"/>
				<include name="ECInterfaces.pdb"/>
			</fileset>
		</copy>
		<!-- I (KZ) switched to an external call to regsvr32 because comregisterex was doing strange things.
			When registering with regsvr32 we call u_init in CIcuECModule which locks cnvalias.icu. Then
			we call u_cleanup in DllRegisterServer which releases the lock, and finally CIcuECModule which
			currently does not call u_cleanup. When using comregisterex, we call u_init, then CIcuECModule
			destructor, then another u_init, then u_cleanup in DllRegisterServer, but at this point cnvalias.icu
			is still locked, apparently because the first u_init was called on a different thread that isn't released
			until nant stops. This breaks the build process because we can't call IcuData to reset the ICU
			directory prior to checking or building installers. The error can be seen by running a temporary
			nant target: <target name="testLockedIcu" depends="EncConvertersDlls"><call target="IcuData"
			cascade="true"/></target> Note that this is not an issue if we have u_cleanup in the
			CIcuECModule destructor, but this apparently causes other problems. -->
		<!-- NB: Only one of these will be run. -->
		<!--comregisterex file="${dir.fwoutputlibBase}/IcuEC40a.dll" failonerror="false" unless="${clean}"/-->
		<!--comregisterex file="/s/u ${dir.fwoutputlibBase}/IcuEC40a.dll" failonerror="false" unregister="true" if="${clean}"/-->
		<property name="args" value="" if="${user::is-admin()}"/>
		<property name="args" value="/c" unless="${user::is-admin()}"/>
		<property name="dir" value="${config}" if="${user::is-admin()}"/>
		<property name="dir" value="release" unless="${user::is-admin()}"/>
		<choose>
			<when test="${user::is-admin()}">
				<regasm unregister="${clean}" codebase="true" verbose="${verbose}" failonerror="false">
					<assemblies>
						<include name="${dir.outputBase}/SilEncConverters40.dll"/>
						<include name="${dir.fwoutputlib}/${dir}/AIGuesserEC.dll"/>
					</assemblies>
				</regasm>
				<exec program="regsvr32.exe" commandline="/s ${fwroot}/Lib/${dir}/IcuEC40a.dll" failonerror="false" unless="${clean}" verbose="true"/>
				<exec program="regsvr32.exe" commandline="/u /s ${fwroot}/Lib/${dir}/IcuEC40a.dll" failonerror="false" if="${clean}"/>
			</when>
			<otherwise>
			<if test="${not platform::is-unix()}">
				<regasm assembly="${dir.outputBase}\SilEncConverters40.dll"
						regfile="${dir.outputBase}\SilEncConverters40.reg" unregister="false" failonerror="false"/>
				<importregistry regfile="${dir.outputBase}\SilEncConverters40.reg"
								unregister="false" peruser="true" failonerror="false"/>
				<delete file="${dir.outputBase}\SilEncConverters40.reg" failonerror="false"/>
				<regasm assembly="${fwroot}\Lib\${dir}\AIGuesserEC.dll"
						regfile="${dir.outputBase}\AIGuesserEC.reg" unregister="false" failonerror="false"/>
				<importregistry regfile="${dir.outputBase}\AIGuesserEC.reg"
								unregister="false" peruser="true" failonerror="false"/>
				<delete file="${dir.outputBase}\AIGuesserEC.reg" failonerror="false"/>
				<!-- IcuEC40a.dll tries to put some files under HKLM so we can't use regsvrex.exe -->
				<exec program="${nant::get-base-directory()}/tasks/elevator.exe"
					  commandline="regsvr32.exe /u /s ${fwroot}\Lib\${dir}\IcuEC40a.dll"
					  failonerror="false" if="${clean}"/>
				<if test="${not clean}">
					<copy file="${fwroot}\Lib\${dir}\IcuEC40a.dll" todir="${path::get-temp-path()}"/>
					<checksum algorithm="MD5">
						<fileset>
							<include name="${path::combine(path::get-temp-path(), 'IcuEC40a.dll')}"/>
						</fileset>
					</checksum>
					<property name="IcuEcChanged" value="true"/>
					<if test="${file::exists(fwroot + '\Lib\' + dir + '\IcuEC40a.dll.MD5')}">
						<loadfile property="newIcuEc" file="${path::combine(path::get-temp-path(), 'IcuEC40a.dll')}"/>
						<loadfile property="oldIcuEc" file="${fwroot}\Lib\${dir}\IcuEC40a.dll.MD5" />
						<property name="IcuEcChanged" value="${newIcuEc != oldIcuEc}"/>
					</if>
					<!-- If IcuEC40a didn't change then we have nothing to do. Otherwise we register with admin privileges -->
					<if test="${IcuEcChanged}">
						<echo message="Register IcuEC40a.dll file with admin privileges"/>
						<exec program="${nant::get-base-directory()}/tasks/elevator.exe"
							  commandline="regsvr32.exe /s ${fwroot}\Lib\${dir}\IcuEC40a.dll" failonerror="false"/>
						<copy file="${path::combine(path::get-temp-path(), 'IcuEC40a.dll.MD5')}" todir="${fwroot}\Lib\${dir}"/>
					</if>
				</if>
			</if> <!-- not is unix-->
			</otherwise>
		</choose>
		</target>
	<target name="copy-nmockDll" description="Copy the nmock files. This gets around something bizarre that breaks the build machine. remakefw ends up copying the dll, but mkall doesn't even though both use buildtest.">
		<copy todir="${dir.outputBase}">
			<fileset basedir="${fwroot}/Bin/nmock/">
				<include name="nmock.*"/>
			</fileset>
		</copy>
	</target>
  <target name="copy-uiAutomation" description="Copy the UIAutomation files. Apparently needed by NMock.DynamicMock to mock SimpleRootSite controls">
	<copy todir="${dir.outputBase}">
	  <fileset basedir="${fwroot}/DistFiles/">
		<include name="UIAutomationProvider.dll"/>
		<include name="UIAutomationTypes.dll"/>
		<include name="WindowsBase.dll"/>
	  </fileset>
	</copy>
  </target>
	<!-- -->
	<!-- projects common to C++ and C# -->
	<target name="mkdp" depends="linuxLibs,GenerateFilesFromModel" description="DebugProcs">
		<call target="mkdp-nodep" cascade="false"/>
	</target>
	<target name="mkdp-nodep" description="DebugProcs">
		<if test="${not bld-release}">
			<property name="batch-file" value="mkdp" unless="${platform::is-unix()}"/>
			<property name="batch-file" value="DebugProcs" if="${platform::is-unix()}"/>
			<call target="call-batch"/>
		</if>
	</target>
	<!-- -->
	<target name="mkGenLib" description="GenericLib"
		depends="mkdp">
		<call target="mkGenLib-nodep" cascade="false"/>
	</target>
	<target name="mkGenLib-nodep" description="GenericLib">
		<property name="output-is-lib" value="true"/>
		<property name="batch-file" value="mkGenLib" unless="${platform::is-unix()}"/>
		<property name="batch-file" value="Generic" if="${platform::is-unix()}"/>
		<call target="call-batch"/>
		<property name="output-is-lib" value="false"/>
	</target>
	<!-- -->
	<target name="icudlls">
		<if test="${showTargetsRunInReport}">
			<property name="appTargName" value="icudlls"/>
			<call target="appendTargetName"/>
		</if>
		<!-- Only one of these two will be done. -->
		<call target="copy-icudlls" unless="${clean}" cascade="false"/>
		<call target="clean-icudlls" if="${clean}" cascade="false"/>
	</target>
	<!-- -->
	<target name="copy-icudlls" description="Copy ICU dlls to an accessible place">
		<copy todir="${dir.outputBase}">
			<fileset basedir="${dir.fwoutputlibBase}">
				<include name="icu*.dll"/>
				<include name="icu*.pdb"/>
			</fileset>
		</copy>
		<copy todir="${dir.outputBase}">
			<fileset basedir="${dir.fwoutputlib}">
				<include name="icu*.dll"/>
			</fileset>
		</copy>
		<choose>
			<when test="${user::is-admin() or platform::is-unix()}">
				<writeregistry hive="LocalMachine" key="SOFTWARE\SIL\FieldWorks\${fwversion}.0\RootCodeDir" value="${dir.fwdistfiles}" verbose="${verbose}"/>
				<writeregistry hive="LocalMachine" key="SOFTWARE\SIL\FieldWorks\${fwversion}.0\RootDataDir" value="${dir.fwdistfiles}" verbose="${verbose}" />
				<writeregistry hive="LocalMachine" key="SOFTWARE\SIL\FieldWorks\${fwversion}.0\ProjectsDir" value="${path::combine(dir.fwdistfiles, 'Projects')}" verbose="${verbose}" />
				<writeregistry hive="LocalMachine" key="SOFTWARE\SIL\Icu40DataDir" value="${dir.icuData}" verbose="${verbose}" />
				<writeregistry hive="LocalMachine" key="SOFTWARE\SIL\Icu40Dir" value="${dir.icu}"
					 verbose="${verbose}" />
				<property name="tmpLib" value="${path::combine(fwroot, 'Lib')}"/>
				<property name="tmp" value="${path::combine(tmpLib, 'Release')}"/>
				<writeregistry hive="LocalMachine" key="SOFTWARE\SIL\SilEncConverters40\RootDir" value="${tmp}" verbose="${verbose}" />
				<writeregistry hive="LocalMachine" key="SOFTWARE\SIL\SilEncConverters40\DeveloperPluginDir" value="${path::combine(path::combine(tmp, 'EC'), 'Plugins')}" verbose="${verbose}" />
			</when>
			<otherwise>
				<readregistry property="rootCodeDir" hive="LocalMachine" key="SOFTWARE\SIL\FieldWorks\${fwversion}.0\RootCodeDir" failonerror="false" verbose="${verbose}"/>
				<readregistry property="rootDataDir" hive="LocalMachine" key="SOFTWARE\SIL\FieldWorks\${fwversion}.0\RootDataDir" failonerror="false" verbose="${verbose}"/>
				<readregistry property="projectsDir" hive="LocalMachine" key="SOFTWARE\SIL\FieldWorks\${fwversion}.0\ProjectsDir" failonerror="false" verbose="${verbose}"/>
				<readregistry property="icu40DataDir" hive="LocalMachine" key="SOFTWARE\SIL\Icu40DataDir" failonerror="false" verbose="${verbose}"/>
				<readregistry property="icu40Dir" hive="LocalMachine" key="SOFTWARE\SIL\Icu40Dir" failonerror="false" verbose="${verbose}"/>
				<readregistry property="ecRootDir" hive="LocalMachine" key="SOFTWARE\SIL\SilEncConverters40\RootDir" failonerror="false" verbose="${verbose}"/>
				<readregistry property="ecPluginDir" hive="LocalMachine" key="SOFTWARE\SIL\SilEncConverters40\PluginDir" failonerror="false" verbose="${verbose}"/>
				<property name="updateRegistry" value="${not property::exists('rootCodeDir') or not property::exists('rootDataDir') or not property::exists('projectsDir')
						  or not property::exists('icu40DataDir') or not property::exists('icu40Dir') or not property::exists('ecRootDir')
						  or not property::exists('ecPluginDir')}" verbose="${verbose}"/>
				<property name="updateRegistry" value="${rootCodeDir != dir.fwdistfiles or rootDataDir != dir.fwdistfiles or projectsDir != path::combine(dir.fwdistfiles, 'Projects')
						  or icu40DataDir != dir.icuData or icu40Dir != dir.icu or ecRootDir != path::combine(path::combine(fwroot, 'Lib'), 'Release')
						  or ecPluginDir != path::combine(path::combine(path::combine(path::combine(fwroot, 'Lib'), 'Release'), 'EC'), 'Plugins')}"
						  unless="${updateRegistry}" verbose="${verbose}"/>

				<if test="${updateRegistry}">
					<echo message='reg.exe add HKLM/SOFTWARE/SIL/FieldWorks/${fwversion}.0 /v RootCodeDir /d "${dir.fwdistfiles}" /f
'
						  file="${dir.outputBase}/updateRegistry.cmd" append="false" verbose="${verbose}"/>
					<echo message='reg.exe add HKLM/SOFTWARE/SIL/FieldWorks/${fwversion}.0 /v RootDataDir /d "${dir.fwdistfiles}" /f
'
						  file="${dir.outputBase}/updateRegistry.cmd" append="true" verbose="${verbose}"/>
					<property name="tmp" value="${path::combine(dir.fwdistfiles, 'Projects')}"/>
					<echo message='reg.exe add HKLM/SOFTWARE/SIL/FieldWorks/${fwversion}.0 /v ProjectsDir /d "${tmp}" /f
'
						  file="${dir.outputBase}/updateRegistry.cmd" append="true" verbose="${verbose}"/>

					<echo message='reg.exe add HKLM/SOFTWARE/SIL /v Icu40DataDir /d "${dir.icuData}" /f
'
						  file="${dir.outputBase}/updateRegistry.cmd" append="true" verbose="${verbose}"/>
					<echo message='reg.exe add HKLM/SOFTWARE/SIL /v Icu40Dir /d "${dir.icu}" /f
'
						  file="${dir.outputBase}/updateRegistry.cmd" append="true" verbose="${verbose}"/>

					<property name="tmpLib" value="${path::combine(fwroot, 'Lib')}"/>
					<property name="tmp" value="${path::combine(tmpLib, 'Release')}"/>
					<echo message='reg.exe add HKLM\SOFTWARE\SIL\SilEncConverters40 /v RootDir /d "${tmp}" /f
'
						  file="${dir.outputBase}\updateRegistry.cmd" append="true" verbose="${verbose}"/>

					<property name="tmp" value="${path::combine(path::combine(tmp, 'EC'), 'Plugins')}"/>
					<echo message='reg.exe add HKLM\SOFTWARE\SIL\SilEncConverters40 /v PluginDir /d "${tmp}" /f
'
						  file="${dir.outputBase}\updateRegistry.cmd" append="true" verbose="${verbose}"/>

					<property name="cmdFileContent" value=""/>
					<loadfile file="${dir.outputBase}/updateRegistry.cmd" property="cmdFileContent" if="${verbose}"/>
					<echo message="Content of batch file ${dir.outputBase}/updateRegistry.cmd:" if="${verbose}"/>
					<echo message="${cmdFileContent}" if="${verbose}"/>
					<echo message="" if="${verbose}"/>

					<echo message="Writing settings to registry"/>
					<exec program="${nant::get-base-directory()}/tasks/elevator.exe"
						  commandline='"${dir.outputBase}/updateRegistry.cmd"'/>
				</if>
			</otherwise>
		</choose>
	</target>
	<!-- -->
	<target name="clean-icudlls" description="Delete copied ICU dlls">
		<delete failonerror="false">
			<fileset basedir="${dir.outputBase}/">
				<include name="icu*.dll"/>
				<include name="icu*.pdb"/>
			</fileset>
		</delete>
	</target>
	<!-- -->
	<target name="mkfwk" description="FwKernel" depends="mkGenLib">
		<call target="mkfwk-nodep" cascade="false"/>
	</target>
	<target name="mkfwk-nodep" description="FwKernel">
		<property name="batch-file" value="mkfwk" unless="${platform::is-unix()}"/>
		<property name="batch-file" value="Kernel" if="${platform::is-unix()}"/>
		<call target="call-batch"/>
	</target>
	<!-- -->
	<target name="ManagedVwDrawRootBuffered" description="ManagedVwDrawRootBuffered" depends="COMInterfaces,BasicUtils">
		<call target="ManagedVwDrawRootBuffered-nodep" cascade="false"/>
	</target>
	<target name="ManagedVwDrawRootBuffered-nodep">
		<property name="dir.srcProj" value="${fwroot}/Src/ManagedVwDrawRootBuffered"/>
		<call target="vsconvert-convert"/>
		<echo message="97199458-10C7-49da-B3AE-EA922EA64859 libManagedComBridge.so ManagedVwDrawRootBuffered.dll SIL.FieldWorks.Views.VwDrawRootBuffered
"
			file="${dir.outputBase}/ManagedVwDrawRootBuffered.compmap" append="false"
			if="${platform::is-unix()}"/>
		<echo message="D9E9D65F-E81F-439e-8010-5B22BAEBB92D libManagedComBridge.so
"
			file="${dir.outputBase}/ManagedVwDrawRootBuffered.compmap" append="true"
			if="${platform::is-unix()}"/>
		<call target="rebuild-compmap" cascade="true" if="${platform::is-unix()}"/>
	</target>
	<!-- -->
	<target name="KeyboardSwitcher" description="KeyboardSwitcher" depends="COMInterfaces,BasicUtils">
			<call target="KeyboardSwitcher-nodep" cascade="false"/>
	</target>
	<target name="KeyboardSwitcher-nodep">
		<property name="dir.srcProj" value="${fwroot}/Src/Common/KeyboardSwitcher"/>
		<call target="vsconvert-convert"/>
			<echo message="4ED1E8bC-DAdE-11DE-B350-0019DBf4566E libManagedComBridge.so KeyboardSwitcher.dll SIL.FieldWorks.Views.KeyboardSwitcher
"
			file="${dir.outputBase}/KeyboardSwitcher.compmap" append="false"
			if="${platform::is-unix()}"/>
		<echo message="4D2BC310-DADF-11DE-9E3A-0019DBF4566E libManagedComBridge.so
"
			file="${dir.outputBase}/KeyboardSwitcher.compmap" append="true"
			if="${platform::is-unix()}"/>
		<call target="rebuild-compmap" cascade="true" if="${platform::is-unix()}"/>
	</target>
	<!-- -->
	<target name="ManagedLgIcuCollator" description="ManagedLgIcuCollator" depends="COMInterfaces,BasicUtils">
			<call target="ManagedLgIcuCollator-nodep" cascade="false" if="${platform::is-unix()}"/>
	</target>
	<target name="ManagedLgIcuCollator-nodep">
		<property name="dir.srcProj" value="${fwroot}/Src/ManagedLgIcuCollator"/>
		<call target="vsconvert-convert"/>
			<echo message="e771361c-ff54-4120-9525-98a0b7a9accf libManagedComBridge.so ManagedLgIcuCollator.dll SIL.FieldWorks.Language.ManagedLgIcuCollator
"
			file="${dir.outputBase}/ManagedLgIcuCollator.compmap" append="false"
			if="${platform::is-unix()}"/>
		<call target="rebuild-compmap" cascade="true" if="${platform::is-unix()}"/>
	</target>
	<!-- -->
	<target name="ManagedVwWindow" description="ManagedVwWindow" depends="COMInterfaces,BasicUtils">
			<call target="ManagedVwWindow-nodep" cascade="false" if="${platform::is-unix()}"/>
	</target>
	<target name="ManagedVwWindow-nodep">
		<property name="dir.srcProj" value="${fwroot}/Src/ManagedVwWindow"/>
		<call target="vsconvert-convert"/>
		<echo message="3fb0fcd2-ac55-42a8-b580-73b89a2b6215 libManagedComBridge.so ManagedVwWindow.dll SIL.FieldWorks.Views.ManagedVwWindow
"
			file="${dir.outputBase}/ManagedVwWindow.compmap" append="false"
			if="${platform::is-unix()}"/>
		<echo message="8856396c-63a9-4bc7-ad47-87ec8b6ef5a4 libManagedComBridge.so
"
			file="${dir.outputBase}/ManagedVwWindow.compmap" append="true"
			if="${platform::is-unix()}"/>
		<call target="rebuild-compmap" cascade="true" if="${platform::is-unix()}"/>
	</target>
	<!-- -->
	<target name="mklg" description="Language" depends="mkfwk,ManagedLgIcuCollator">
		<call target="mklg-nodep" cascade="false"/>
	</target>
	<target name="mklg-nodep" description="Language">
		<property name="batch-file" value="mklg" unless="${platform::is-unix()}"/>
		<property name="batch-file" value="Language" if="${platform::is-unix()}"/>
		<call target="call-batch"/>
	</target>
	<!-- -->
	<target name="mkvw" description="Views" depends="mklg,mktlbs,KeyboardSwitcher,GenerateFilesFromModel">
		<call target="mkvw-nodep" cascade="false"/>
	</target>
	<target name="mkvw-nodep" description="Views">
		<property name="batch-file" value="mkvw" unless="${platform::is-unix()}"/>
		<property name="batch-file" value="views" if="${platform::is-unix()}"/>
		<call target="call-batch"/>
	</target>
	<!-- -->
	<target name="mktlbs" description="TLB for Language,Views,FwKernel"
		depends="Version" unless="${platform::is-unix()}">
		<!-- TODO-Linux: not ported yet - maybe need to do this one? -->
		<!-- These properties are passed to command line, so we have to use backslash on Windows. -->
		<!-- (or do a path::combine) -->
		<property name="bld_makefile" value="${fwroot}\Src\Language\Language.mak"/>
		<property name="bld_targets" value="dirs ${dir.fwoutputCommon}\LanguageTlb.tlb"/>
		<call target="call-make"/>

		<property name="bld_makefile" value="${fwroot}\Src\Kernel\FwKernel.mak"/>
		<property name="bld_targets" value="dirs ${dir.fwoutputCommon}\FwKernelTlb.tlb"/>
		<call target="call-make"/>

		<property name="bld_makefile" value="${fwroot}\Src\views\Views.mak"/>
		<property name="bld_targets" value="dirs ${dir.fwoutputCommon}\ViewsTlb.tlb"/>
		<call target="call-make"/>

		<property name="bld_makefile" value="${fwroot}\Src\Cellar\FwCellar.mak"/>
		<property name="bld_targets" value="dirs ${dir.fwoutputCommon}\FwCellarTlb.tlb"/>
		<call target="call-make"/>
	</target>
	<target name="call-make">
		<exec program="nmake"
			commandline="/nologo /f ${bld_makefile} ${bld_targets}"
			workingdir="${fwroot}" verbose="${verbose}">
			<environment>
				<variable name="BUILD_ROOT" value="${fwroot}"/>
				<variable name="BUILD_TYPE" value="${build-type}"/>
				<variable name="BUILD_CONFIG" value="${config}"/>
				<variable name="BUILD4UX" value="${build4ux}"/>
				<variable name="ANAL_TYPE" value="performance" if="${property::exists('performance')}"/>
			</environment>
		</exec>
	</target>
	<!-- -->
	<target name="Version" description="Create version info for C++ projects">
		<if test="${not file::up-to-date(path::combine(fwroot, 'Src/bldinc.h'), path::combine(dir.fwoutputCommon, 'bldinc.h'))}">
			<mkdir dir="${dir.fwoutputCommon}"/>
			<versionex output="${dir.fwoutputCommon}/bldinc.h">
				<sources>
					<include name="${fwroot}/Src/bldinc.h"/>
				</sources>
			</versionex>
		</if>
	</target>
	<!-- -->
	<!-- We NEED to build some type libraries very early on without compiling the entire DLL
		they represent due to circular build dependencies.  Life is simpler if we go ahead and
		build the Interop DLLs as well at this time.
	<target name="mkall-tlb" description="Build Type Libraries"
		depends="mkecob-tlb"/>-->
	<!-- -->
	<!-- Libraries -->
	<target name="mkWidgLib" description="Widget Library" depends="mkvw,FwCoreDlgs">
		<call target="mkWidgLib-nodep" cascade="false"/>
	</target>
	<target name="mkWidgLib-nodep" description="Widget Library">
		<!-- TODO-Linux: not ported yet -->
		<property name="output-is-lib" value="true"/>
		<property name="batch-file" value="mkWidgLib"/>
		<call target="call-batch" unless="${platform::is-unix()}"/>
		<property name="output-is-lib" value="false"/>
	</target>
	<!-- -->
	<target name="mkgrc" description="Graphite compiler" depends="mkGenLib,mkfwk">
		<call target="mkgrc-nodep" cascade="false"/>
	</target>
	<target name="mkgrc-nodep" description="Graphite compiler">
		<!-- TODO-Linux: not ported yet -->
		<property name="batch-file" value="mkgrc"/>
		<call target="call-batch" unless="${platform::is-unix()}"/>
	</target>
	<!-- -->
	<target name="mkgre" description="Graphite engine" depends="mkGenLib,mkfwk,mkvw">
		<call target="mkgre-nodep" cascade="false"/>
	</target>
	<target name="mkgre-nodep" description="Graphite engine">
		<property name="batch-file" value="mkgre" unless="${platform::is-unix()}"/>
		<property name="batch-file" value="Graphite-GrEngine" if="${platform::is-unix()}"/>
		<call target="call-batch"/>
	</target>
	<!-- -->
	<target name="mkwp" description="WorldPad" depends="mkGenLib,mkfwk,mkvw,FwCoreDlgs,mkWidgLib">
		<call target="mkwp-nodep" cascade="false"/>
	</target>
	<target name="mkwp-nodep" description="WorldPad">
		<property name="batch-file" value="mkwp" unless="${platform::is-unix()}"/>
		<property name="batch-file" value="WorldPad" if="${platform::is-unix()}"/>
		<call target="call-batch"/>
	</target>
	<!-- -->
	<!-- Tests -->
	<target name="mktsth" description="Tests" depends="mkGenLib">
		<call target="mktsth-nodep" cascade="false"/>
	</target>
	<target name="mktsth-nodep" description="Tests" unless="${platform::is-unix()}">
		<!-- TODO-Linux: not ported yet -->
		<property name="batch-file" value="mktsth"/>
		<call target="call-batch" unless="${bld-release}"/>
	</target>
	<!-- -->
	<target name="mktstw" description="Tests" depends="mkGenLib,mkWidgLib">
		<call target="mktstw-nodep" cascade="false"/>
	</target>
	<target name="mktstw-nodep" description="Tests" unless="${platform::is-unix()}">
		<!-- TODO-Linux: not ported yet -->
		<property name="batch-file" value="mktstw"/>
		<call target="call-batch" unless="${bld-release}"/>
	</target>
	<!-- -->
	<target name="mkGenLib-tst" description="Tests"
		depends="mkGenLib">
		<call target="mkGenLib-tst-nodep" cascade="false"/>
	</target>
	<target name="mkGenLib-tst-nodep" description="Tests">
		<property name="batch-file" value="mkGenLib-tst" unless="${platform::is-unix()}"/>
		<property name="batch-file" value="generic" if="${platform::is-unix()}"/>
		<property name="test-exe" value="GenericLib"/>
		<call target="run-cpptest" unless="${bld-release}"/>
	</target>
	<!-- -->
	<target name="mkfwk-tst" description="Tests" depends="mkfwk">
		<call target="mkfwk-tst-nodep" cascade="false"/>
	</target>
	<target name="mkfwk-tst-nodep" description="Tests">
		<property name="batch-file" value="mkfwk-tst" unless="${platform::is-unix()}"/>
		<property name="batch-file" value="kernel" if="${platform::is-unix()}"/>
		<property name="test-exe" value="FwKernel"/>
		<call target="run-cpptest" unless="${bld-release}"/>
	</target>
	<!-- -->
	<target name="mklg-tst" description="Tests" depends="mklg,mkfwk,mkgre">
		<call target="mklg-tst-nodep" cascade="false"/>
	</target>
	<target name="mklg-tst-nodep" description="Tests">
		<property name="batch-file" value="mklg-tst" unless="${platform::is-unix()}"/>
		<property name="batch-file" value="language" if="${platform::is-unix()}"/>
		<property name="test-exe" value="Language"/>
		<call target="run-cpptest" unless="${bld-release}"/>
	</target>
	<!-- -->
	<target name="mkvw-tst" description="Tests"
		depends="mkvw,mkgre">
		<call target="mkvw-tst-nodep" cascade="false"/>
	</target>
	<target name="mkvw-tst-nodep" description="Tests">
		<property name="batch-file" value="mkvw-tst" unless="${platform::is-unix()}"/>
		<property name="batch-file" value="views" if="${platform::is-unix()}"/>
		<property name="test-exe" value="Views"/>
		<call target="run-cpptest" unless="${bld-release}"/>
	</target>
	<!-- -->
	<!-- ************************************************************************************ -->
	<!-- Do not add anything below this line -->
	<!-- Additional helper targets -->
	<target name="run-cpptest" description="Builds and runs a C++ test">
		<property name="test-exe-path" value="${dir.outputBase}\test${test-exe}.exe" unless="${platform::is-unix()}"/>
		<property name="test-exe-path" value="${dir.outputBase}/test${test-exe}" if="${platform::is-unix()}"/>
		<delete file="${test-exe-path}-failed-results.xml" failonerror="false" />

		<!-- build the tests -->
		<if test="${not property::exists('batch-working-dir')}">
			<property name="batch-working-dir" value="${fwroot}/Bin"/>
		</if>
		<exec program="cmd.exe" commandline="/c ${fwroot}/Bin/testWrapper.cmd ${batch-file}.bat DONTRUN"
			workingdir="${batch-working-dir}"
			  unless="${platform::is-unix()}"/>
		<exec program="make" commandline="${batch-file}-Test"
			workingdir="${fwroot}" verbose="${verbose}"
			if="${platform::is-unix()}"/>
		<!-- I think the manifest file is needed only on MS Windows. -->
		<property name="executable" value="${test-exe-path}" unless="${platform::is-unix()}"/>
		<call target="regfree" cascade="true" unless="${platform::is-unix()}"/>

		<call target="run-cpptest-internal" failonerror="false"/>

		<if test="${fw-test-core-error}">
			<move file="${test-exe-path}-results.xml" tofile="${test-exe-path}-failed-results.xml" failonerror="false" />
			<property name="fw-test-error" value="${fw-test-error};${batch-file}" if="${property::exists('fw-test-error')}"/>
			<property name="fw-test-error" value="${batch-file}" unless="${property::exists('fw-test-error')}"/>
			<echo message="********* At least one test for ${batch-file} failed ********" />
		</if>
	</target>
	<!-- -->
	<target name="run-cpptest-internal" description="Run the tests. Shouldn't be called directly">
		<!--Set ${{fw-test-core-error}} to true and at the end to false. If batch file fails,
					${{fw-test-core-error}} will remain true, so we know if anything happened-->
		<property name="fw-test-core-error" value="true" />

		<uptodate property="done" verbose="${verbose}">
			<sourcefiles>
				<include name="${test-exe-path}"/>
				<include name="${dir.outputBase}/${test-exe}.dll"/>
			</sourcefiles>
			<targetfiles>
				<include name="${test-exe-path}-results.xml"/>
			</targetfiles>
		</uptodate>
		<if test="${not done or forcetests or property::exists('noCompare')}">
			<unitpp path="${test-exe-path}" verbose="${verbose}" if="${doTest}" />
		</if>
		<property name="fw-test-core-error" value="false" />
	</target>
	<!-- -->
	<target name="call-batch" description="Calls a batch file">
		<tstamp/>
		<if test="${not platform::is-unix()}">
			<property name="fw-call-batch-error" value="false"/>
			<call target="call-batch-internal" failonerror="false" unless="${clean}"/>
			<if test="${fw-call-batch-error}">
				<if test="${not property::exists('fw-build-error')}">
					<property name="fw-build-error" value="********* ${batch-file}.bat failed ********"/>
					<fail message="${fw-build-error}"/>
				</if>
			</if>
		</if>
		<if test="${platform::is-unix()}">
			<exec program="make" commandline="${batch-file}-clean"
				workingdir="${fwroot}" verbose="${verbose}"
				if="${build-action == 'cc' or clean}"/>
			<exec program="make" commandline="${batch-file}-nodep"
				workingdir="${fwroot}" verbose="${verbose}"
				unless="${clean}"/>
			<call target="rebuild-compmap" unless="${clean}"/>
		</if>
	</target>
	<!-- -->
	<target name="call-batch-internal" description="Calls a batch file">
		<!-- set ${fw-build-core-error} to true and at the end to false. If batch file fails,
			${fw-build-core-error} will remain true, so we know if anything happened -->
		<property name="fw-call-batch-error" value="true"/>
		<property name="extra-params" value=""/>
		<if test="${property::exists('cpp-extra-params')}">
			<property name="extra-params" value="${cpp-extra-params}"/>
		</if>
		<property name="_output-dir" value="${dir.outputBase}"/>
		<property name="_output-dir" value="${dir.fwoutputlibBase}" if="${output-is-lib}"/>
		<if test="${not property::exists('batch-working-dir')}">
			<property name="batch-working-dir" value="${fwroot}/bin"/>
		</if>
		<if test="${showTargetsRunInReport}">
			<property name="appTargName" value="${batch-file}"/>
			<call target="appendTargetName"/>
		</if>
		<!-- if we're running as a limited user (Vista with UAC enabled) we have to register the DLL in HKCU -->
		<setenv name="REGSVR_OPTS" value="/n /i:user" unless="${user::is-admin()}"/>
		<setenv name="ISLUA" value="1" unless="${user::is-admin()}"/>
		<exec program="cmd.exe" commandline="/c ${fwroot}/Bin/wrapper.cmd ${_output-dir} ${dir.fwoutputCommon} ${dir.fwobj} ${batch-file}.bat ${build-type} ${build-action} ${extra-params}"
			workingdir="${batch-working-dir}" verbose="${verbose}"/>
		<property name="fw-call-batch-error" value="false"/>
	</target>
</project>
