--------------------------
 GRAPHITE ENGINE OVERVIEW
--------------------------

The Graphite engine provides "smart" rendering for complex writing systems. It allows
for the following complex behaviors:

* contextual substitution, insertion, and deletion
* reordering
* creation of ligatures with defined components
* positioning based on attachment points or shifting and kerning
* accessing of glyph metrics
* rule-based line-breaking
* application of the Unicode bidirectional algorithm.
* selecting and editing in all of the above situations.

Interacting with the application

From the point of view of the calling application, there are two main classes that serve as the top-level interface. GrEngine is the class the represents an engine set up to render using a specific Graphite font. Given a range of text and associated character properties, it runs its processes and returns instances of GrSegment. A GrSegment represents a range of text that can be rendered by Graphite as a unit. Normally this would be one line of, or if there are changes in font, writing system, or style, several segments may be needed to make up one line. In no case does a segment ever consist of text displayed on more than one line. The calling application is responsible for laying out the segments into a reasonable paragraph.

In addition to GrEngine and GrSegment, there are two classes that must be provided by the application to supply key information; these serve as "call-back" classes. An instance of GrTextSource represents the text to be rendered--the range of characters and their associated style information. GrGraphics encapsulates a device context, and is used for the actual drawing routines, as well as to obtain font metric information needed by the engine. There are also a few data structures that must be defined; chief among these is LgCharRenderProps, which represents a collection of character properties. (Basic implementations of GrTextSource, GrGraphics, and other data items are available in the open-source code.)

Graphite fonts

The behavior of the Graphite engine for a given writing system is specified by special-purpose tables in a TrueType font. These tables are generated by compiling a GDL program. There are two ways to intialize an engine with a font. The Windows system registry provides a mapping from the font family name (eg, "SILDoulos UnicodeIPA") to font file (eg, "sildub3.ttf"). This mapping is stored in the registry under HKEY_LOCAL_MACHINE/Software/SIL/GraphiteFonts. Alternately, the engine can be initialized by passing a GrGraphics (graphics device wrapper) with the desired font selected into it, and the engine obtains the tables via a Windows API method. Eventually we expect the latter will be the preferred or only available approach.

Graphite processing

Processing in Graphite occurs in a series of passes. The first pass converts
Unicode characters from the underlying string to glyph IDs; all the remainder of the
processing happens in terms of glyph IDs. Each pass takes the output of the previous
pass as its own input, looks for patterns, and applies rules to make modifications
to the stream of glyphs. The final pass performs the final positioning of all glyphs.
The output of the engine is a "segment," a group of well-positioned glyphs that fits
properly in the available space, and also understands its relationship to the original
underlying string.

A class called GrTableManager is an important helper class to the engine. It keeps a
list of passes and manages the process of calling each pass. An important point to be
aware of is that processing occurs in small chunks. We DON'T run the whole string
through the first pass, then run all of the result through the second pass, etc. Instead,
we process just little bit of the first pass, and send the results on the second pass,
which does its processing and sends the results to the third pass, and so on. The mechanism
is driven by the final pass attempting to do its positioning, and repeatedly requesting a
little more input from the previous passes until it has filled up the available space or
successfully processed all the input.

The reason for using this approach is to allow us to avoid doing more work than necessary
in the case where we have a long string that will not fit on the line, and we need to
insert a line-break. We gradually process a little bit of each pass until the final
pass notices that the available space has been exceeded, and then it initiates a prcoess
called "backtracking." Backtracking involves finding a place to insert a linebreak, and
then "unwinding" the subsequent glyph streams so that we can redo the processing while taking
into account the inserted line-break. The trick is to unwind as little as possible but
enough that we retain the context for each pass. This requires careful bookkeeping, and
is managed by keeping track of "chunks." (It may also be necessary to backtrack more than
once before finding a line-break that will allow the segment to fit on the line.)
See 'WR Data Transform Engine.pdf' for more details on this process.

There are four kinds of passes: line-break passes, substitution passes, the bidi pass,
and positioning passes--implemented by corresponding subclasses of GrPass. They occur in
the order just listed. Substitution passes have the ability to substitute, insert, delete,
and reorder glyphs; positioning and line-break passes do not. The bidi pass (if any)
performs the Unicode bidi algorithm. (Many rendering systems do not have any line-break
passes or a bidi pass.)

Instances of class GrSlotStream contains the glyphs as they are being processed. Each
stream holds a sequence of GrSlotStates, where each slot contains one glyph. The slots
have pointers to slots in the previous streams to help keep track of the relationships
between the output and the input. They also have a number of instance variables that
represent "slot attributes" that are modified by the rules.

Pattern matching--determining which rules to fire--is achieved using finite state
machines (FSMs). Each pass has its own finite state machine. The columns in the FSM
correspond to classes of glyphs that are considered equivalent for the purposes of
matching, and the rows are the states to transition to. Each FSM has a table
assigning each glyph ID to a column in the table, and each final state indicates
which rules are considered to be matched. See 'WR FSM Design.pdf' for more details.

The effect of firing of the rules is done though a stack machine mechanism. There are
commands to perform subsitutions, look up glyph attributes, make mathematical
calculations, etc. See 'Stack Machine Commands.doc' for a complete list.

Another tricky aspect of the engine relates to cross-line-boundary contextualization.
In other words, the way a segment is rendered may be affected by the characters on
the previous or following line. In order to make this happen, there is a block of
information that is passed in when starting to create a new segment, which is
information from the previous segment. It tells the engine how much to "back up"
in order to take into account the stuff from the previous segment that will have
an effect. 'WR Data Transform Engine.pdf' also discusses this process.

To get a complete overview of the capabilities of the Graphite system, refer to 'GDL.pdf'.
