/*--------------------------------------------------------------------*//*:Ignore this sentence.
Copyright (c) 1999-2013 SIL International
This software is licensed under the LGPL, version 2.1 or later
(http://www.gnu.org/licenses/lgpl-2.1.html)

File: Language.idh
Responsibility: John Thomson
Last reviewed: Mid June, 2000. Several changes suggested, not yet all made or reviewed.

Description:
	The Language classes provide specifications and implementations of how text in various
	(language) writing systems behaves.

	Note: Language.idh is included in FwKernelTlb.idl. This is how it becomes available to C#
	programs. Therefore, to make a new or modified interface available without remakefw,
	you must cc mkfwk-nodep, than do a clean COMInterfaces-nodep, then build COMInterfaces-nopdep.

	The root (document) class is the LgWritingSystem class. Logically there ought
	possibly to be a LgLanguage class which owns a number of writing systems; but a Language
	has no computationally interesting behavior until it is encoded in a writing system, and it
	is useful to be able to install an writing system in isolation. We therefore decided not to
	implement Language as a distinct class, but just to have the LgWritingSystem class
	provide some basic documentation about its language.

	The language writing system class has a number of "engines." Each of these implements an
	interface for one area of functionality related to text manipulation.

	Note that writing systems as described in this document are not intended to model the
	linguistically interesting aspects of these concepts. They are specifically intended to
	model those aspects needed so that the computer can correctly manipulate data in the
	particular writing system.
-------------------------------------------------------------------------------*//*:End Ignore*/
// Indentation is as if all this were embedded in a library declaration.

	//:>****************************************************************************************
	//:>		Forward declarations
	//:>****************************************************************************************
	interface IRenderEngine;
	interface ILgCharacterPropertyEngine;
	interface ILgCollatingEngine;
	interface ICollation;
	interface ILgWritingSystem;
	interface ILgWritingSystemFactory;

	//:>****************************************************************************************
	//:>		Enumerations
	//:>****************************************************************************************

	// Line Breaking Character classes defined by Unicode.
	typedef [v1_enum] enum LgLBP
	{
				 // '*' indicates normative property
		klbpAI,  //  0   Ambiguous (Alphabetic or Ideographic)
		klbpAL,  //  1   Ordinary Alphabetic
		klbpB2,  //  2   Break Opportunity Before and After
		klbpBA,  //  3   Break Opportunity After
		klbpBB,  //  4   Break Opportunity Before
		klbpBK,  //  5 * Mandatory Break
		klbpCB,  //  6 * Contingent Break Opportunity
		klbpCL,  //  7   Closing
		klbpCM,  //  8 * Combining Marks
		klbpCR,  //  9 * Carriage Return
		klbpEX,  // 10   Exclamation
		klbpGL,  // 11 * Non-breaking ("Glue")
		klbpHY,  // 12   Hyphen
		klbpID,  // 13   Ideographic
		klbpIN,  // 14   Inseparable
		klbpIS,  // 15   Infix Separator (Numeric)
		klbpLF,  // 16 * Line Feed
		klbpNS,  // 17   Non Starter
		klbpNU,  // 18   Numeric
		klbpOP,  // 19   Opening
		klbpPO,  // 20   Postfix (Numeric)
		klbpPR,  // 21   Prefix (Numeric)
		klbpQU,  // 22   Ambiguous Quotation
		klbpSA,  // 23   Complex Context
		klbpSG,  // 24 * Surrogates
		klbpSP,  // 25 * Space
		klbpSY,  // 26   Symbols Allowing Breaks
		klbpXX,  // 27   Unknown (used for unassigned characters)
		klbpZW   // 28 * Zero Width Space
	} LgLBP;  // Hungarian lbp

	/*******************************************************************************************
		Interface ILgWritingSystem
		An LgWritingSystem represents one way of writing data in a particular language
		(or dialect). It has a number of engines which implement various aspects of writing
		system behavior.

		ENHANCE: May need some more 'documentation' type attributes, such as
		an author, region, country--what exactly is useful?

		@h3{When to implement}
		Clients should not implement this interface.

		@h3{When to use}
		Use this class when you need to get one of the engines or other bits of information
		it stores about an writing system. In some cases, if you need only one engine, it is
		simpler to ask the ${LgWritingSystemFactory} for it in a single step.

		Don't use an ILgWritingSystem when you just need to identify an writing system, but
		don't actually need any of the engines. Use the integer which stands for the writing
		system.

		@h3{How to obtain an instance}
		Normally, use the get_Engine method of an ${LgWritingSystemFactory}. This will create
		and writing system with all default engines if one does not already exist. To avoid
		this, use get_EngineOrNull instead.

		@h3{Hungarian: ws or wseng}
		(Note: use wseng when you need to distinguish the interface/object from the writing
		system's integer code, which uses ws as its Hungarian.)
	*******************************************************************************************/
	DeclareInterface(LgWritingSystem, Unknown, 9C0513AB-1AB9-4741-9C49-FA65FA83B7CC)
	{
		// The identifier for this writing system.
		[propget] HRESULT Id(
			[out, retval] BSTR *pbstr);

		// GET THE WRITING SYSTEM INTEGER that identifies this writing system to classes which
		// don't actually need to use its methods
		[propget] HRESULT Handle(
			[out, retval] int * pws);

		// Get the language name.
		[propget] HRESULT LanguageName(
			[out, retval] BSTR * pbstr);

		// Get the name of the spelling dictionary to use for this writing system.
		// Currently returns a generally-useful default, unless explicitly set to empty
		// to prevent this.
		[propget] HRESULT SpellCheckingId(
			[out, retval] BSTR *pbstr);

		// Get the primary direction, used for complex embedding; may have fragments like
		// numbers that go the other way internally.
		[propget] HRESULT RightToLeftScript(
			[out, retval] ComBool * pfRightToLeft);

		// Get the engine used to render text with the specified properties. At present only
		// font, bold, and italic properties are significant.
		// Font name may be '<default serif>' which produces a renderer suitable for the default
		// serif font.
		[propget] HRESULT Renderer(
			[in] IVwGraphics * pvg,
			[out, retval] IRenderEngine ** ppreneng);

		// Get the "serif font variation" string which is used, for instance, to specify
		// Graphite features.
		[propget] HRESULT DefaultFontFeatures(
			[out, retval] BSTR * pbstr);

		// Get the default serif font; usually used for the main body of text in a document.
		[propget] HRESULT DefaultFontName(
			[out, retval] BSTR * pbstr);

		// Apply any changes to the chrp before it is used for real: currently,
		// interpret the magic font names.
		HRESULT InterpretChrp(
			[in, out] LgCharRenderProps * pchrp);

		// Returns true to pass NFC text to the keyboard, otherwise we pass NFD.
		[propget] HRESULT UseNfcContext(
			[out, retval] ComBool * pUseNfc);

		// Return true if character is considered to be part of a word (by default, this
		// corresponds to Unicode general category Mc, Mn, and categories starting with L.
		[propget] HRESULT IsWordForming(
			[in] int ch,
			[out, retval] ComBool *pfRet);

		// The ICU locale for this writing system.
		[propget] HRESULT IcuLocale(
			[out, retval] BSTR *pbstr);
	};

	//:>****************************************************************************************
	//:>	These are the interfaces for the engines--the code that actually does the work.
	//:>****************************************************************************************

	//:>****************************************************************************************
	//:>	CoClass definitions.
	//:>****************************************************************************************

	// Flags used to specify variations on how to collate.
	// Default is all listed options off.
	// Except where noted, options are orthogonal and may be ORed together for combined
	// effect.
	// Unrecognized options are ignored. This allows for forwards compatibility: as we
	// introduce new options, older engines will continue to work but ignore them.
	// (An unrecognized option is any bit not used by any of the options defined here.)
	typedef [v1_enum] enum LgCollatingOptions
	{
		fcoDefault = 0,
		fcoIgnoreCase = 1,
		fcoDontIgnoreVariant = 2,
		fcoLim // max valid value.
	} LgCollatingOptions; // Hungarian colopt

	/*******************************************************************************************
		Interface ILgCollatingEngine
		A collating engine knows how to compare strings in the same writing system.

		@h3{When to implement}
		Clients should not normally implement this interface. There are standard implementations
		in Language.dll. A new implementation might possibly be made for a language with very
		unusual collating requirements, if none of the standard implementations can be
		configured to suit.

		@h3{When to use}
		Use this interface when you need to know whether a given string collates before or after
		another, or to create a list of keys that can be simply compared in order to sort a
		larger list.

		@h3{How to obtain an instance}
		Obtain a collating engine from the writing system using
		${LgWritingSystem#get_CollatingEngine}. Obtain a default Unicode collater from
		${LgWritingSystemFactory#get_DefaultCollater}.

		@h3{Hungarian: coleng}
	*******************************************************************************************/
	DeclareInterface(LgCollatingEngine, Unknown, D27A3D8C-D3FE-4E25-9097-8F4A1FB30361)
	{
		// Get a sort key which may be compared to any other sort key produced by this
		// object via a simple BSTR comparison. This is especially useful in large-scale
		// sorting, where the work to generate the key only needs to be done once per key
		[propget] HRESULT SortKey(
			[in] BSTR bstrValue,
			[in] LgCollatingOptions colopt,
			[out, retval] BSTR * pbstrKey);

		// Get a sort key which may be compared to any other sort key produced by this
		// object via a simple wcscmp comparison. This is especially useful in large-scale
		// sorting, where the work to generate the key only needs to be done once per key

		// @param cchMaxOut Available space in output buffer. If 0, the method just sets
		// *pchKey to the number required.
		// @exception ERROR_INSUFFICIENT_BUFFER if not enough space in output buffer (gives
		// needed amount in *pcchOut).
		[restricted] HRESULT SortKeyRgch(
			[in, size_is(cchIn)] const OLECHAR * pch,
			[in] int cchIn,
			[in] LgCollatingOptions colopt,
			[in] int cchMaxOut,
			[out, size_is(cchMaxOut)] OLECHAR * pchKey,
			[out] int * pcchOut);

		// Return in *pnVal (<0, 0, or >0) depending on whether the first string is
		// (less than, equal, or greater than) the second string passed. This in principle
		// creates a SortKey for each string using the SortKey method, then compares them.
		// Any actual implementation promises to give the same results as doing that.
		// However, the actual implementation may be more efficient than that, saving time
		// when only a single comparison is to be made involving each string.
		HRESULT Compare(
			[in] BSTR bstrValue1,
			[in] BSTR bstrValue2,
			[in] LgCollatingOptions colopt,
			[out, retval] int * pnVal);

		// Get the language writing system factory used with this collating engine object.
		[propget] HRESULT WritingSystemFactory(
			[out, retval] ILgWritingSystemFactory ** ppwsf);
		// Set the language writing system factory to use with this collating engine object.
		[propputref] HRESULT WritingSystemFactory(
			[in] ILgWritingSystemFactory * pwsf);

		// The next two methods are required by C# which doesn't know that BSTRs can be anything
		// but NUL-terminated UTF-16 strings.

		// Get a sort key which may be compared to any other sort key produced by this
		// object via a simple BSTR comparison. This is especially useful in large-scale
		// sorting, where the work to generate the key only needs to be done once per key
		[propget] HRESULT SortKeyVariant(
			[in] BSTR bstrValue,
			[in] LgCollatingOptions colopt,
			[out, retval] VARIANT * psaKey);		// will be a "safearray".

		// Return in *pnVal (<0, 0, or >0) depending on whether the first string is
		// (less than, equal, or greater than) the second string passed. This in principle
		// creates a SortKey for each string using the SortKey method, then compares them.
		// Any actual implementation promises to give the same results as doing that.
		// However, the actual implementation may be more efficient than that, saving time
		// when only a single comparison is to be made involving each string.
		HRESULT CompareVariant(
			[in] VARIANT saValue1,			// "safearray"
			[in] VARIANT saValue2,			// "safearray"
			[in] LgCollatingOptions colopt,
			[out, retval] int * pnVal);

		// Initialize the collating engine to the given locale.
		HRESULT Open(
			[in] BSTR bstrLocale);

		// Close and free the currently open collating engine, if any.
		HRESULT Close();

		// ENHANCE JohnT: we should have an Rgch version of Compare().
	};

	/*******************************************************************************************
		Interface ILgLineBreaker
		This interface is used to determine possible line break positions in a string.

		@h3{When to implement}
		Clients should not normally implement this interface. There are standard implementations
		in FwKernel.dll.

		@h3{When to use}
		Use this interface to determine possible line break positions in a string.

		@h3{How to obtain an instance}
		For now the only way is to create one using CoCreateInstance, with
		CLSID_LgLineBreaker.

		@h3{Hungarian: linbrk}
	*******************************************************************************************/
	DeclareInterface(LgLineBreaker, Unknown, F8D5FDE9-9695-4D63-8843-E27FD880BFF0)
	{
		HRESULT Initialize(
			[in] BSTR bstrLocale);

		// Get line breaking properties (from enumeration LgLBP) for an array of characters.
		// This passes an array in, and an array with the same number of elements out, to
		// improve efficiency when properties are required for a string of characters.
		// See @HTTP{www.unicode.org/unicode/reports/tr14/}.
		// @exception E_INVALIDARG if characters in input are not valid Unicode.
		[restricted] HRESULT GetLineBreakProps(
			[in, size_is(cchIn)] const OLECHAR * prgchIn,
			[in] int cchIn,
			[out, size_is(cchIn)] byte * prglbOut);

		// This combines the functions of ${#GetLineBreakProps} and ${#GetLineBreakStatus},
		// plus the ability to skip part of the string, and stop at break characters.
		//
		// The first two arguments define an array of characters as for ${#GetLineBreakProps}.
		// The output is basically what would be produced by passing the output of
		// that method as input to GetLineBreakStatus, with two exceptions:
		//
		// 1. We only want line break status info for characters from ichMin to ichLim.
		// (A larger array is passed in because we may need to look at preceding characters
		// to confidently know whether we can break after the char at ichMin.)
		//
		// 2. If we detect a character which forces a line or segment break in the range
		// ichMin..ichLim, we stop and do not return any info about subsequent characters.
		//
		// Also, we set *pichBreak to the index of the break character.
		// *pichBreak is set to -1 if we don't find a break character.
		// Break characters are things like CR, LF, TAB, or the embedded object character.
		[restricted] HRESULT GetLineBreakInfo(
			[in, size_is(cchIn)] const OLECHAR * prgchIn,
			[in] int cchIn,
			[in] int ichMin,
			[in] int ichLim,
			[out, size_is(ichLim - ichMin)] byte * prglbsOut,
			[out] int * pichBreak);

		// Gets the text that the LineBreakBefore and LineBreakAfter functions are using.  This
		// function is included for completion.
		HRESULT GetLineBreakText(
			[in] int cchMax,
			[out] OLECHAR * prgchOut,
			[out] int * pcchOut);
		// Sets the text for the LineBreakBefore and the LineBreakAfter functions to use.
		[propput] HRESULT LineBreakText(
			[in, size_is(cchMax)] OLECHAR * prgchIn,
			[in] int cchMax);

		// Finds the nearest line break immediately before the given index (ichIn).  The
		// function returns not only a location but the weight of the line break (currently not
		// implemented).  See http://www.unicode.org/unicode/reports/tr14/ for more information
		// on line breaking properties.
		HRESULT LineBreakBefore(
			[in] int ichIn,
			[out] int * pichOut,
			[out] LgLineBreak * plbWeight);

		// Finds the nearest line break immediately after the given index (ichIn).  The function
		// returns not only a location but the weight of the line break (currently not
		// implemented).  See http://www.unicode.org/unicode/reports/tr14/ for more information
		// on line breaking properties.
		HRESULT LineBreakAfter(
			[in] int ichIn,
			[out] int * pichOut,
			[out] LgLineBreak * plbWeight);
	};

	/*******************************************************************************************
		Interface ILgWritingSystemFactory
		Knows how to find an writing system engine from an writing system integer or an ICU
		Locale string.

		@h3{When to implement}
		Never implement this interface.

		@h3{When to use}
		Use this interface when you need to obtain writing systems and their engines.

		@h3{How to obtain an instance}

		@h3{Hungarian: wsf}
	*******************************************************************************************/
	DeclareInterface(LgWritingSystemFactory, Unknown, CC2BD14F-ACCE-4246-9192-9C29441A5A09)
	{
		// Get the actual writing system object for a given Id string.
		// The current implementation returns any existing writing system for that Id,
		// or creates one with default settings if one is not already known.
		// (Use ${#get_EngineOrNull} to avoid automatic creation of a new engine.)
		[propget] HRESULT Engine(
			[in] BSTR bstrId,
			[out, retval] ILgWritingSystem ** ppwseng);

		// Get the actual writing system object for a given code, or returns NULL if one does
		// not already exist.
		// (Use ${#get_Engine} if you prefer to have an writing system created automatically if
		// one does not already exist.)
		[propget] HRESULT EngineOrNull(
			[in] int ws,
			[out, retval] ILgWritingSystem ** ppwseng);

		// Get an writing system handle from an Id, or 0 if no such writing system exists.
		// Return S_FALSE if the writing system does not exist.
		HRESULT GetWsFromStr(
			[in] BSTR bstr,
			[out, retval] int * pws);
		// Get the Id for the writing system if it exists, or NULL if it doesn't.
		// Return S_FALSE if the writing system does not exist.
		HRESULT GetStrFromWs(
			[in] int ws,
			[out, retval] BSTR * pbstr);

		// Get the ICU locale for the writing system if it exists, or NULL if it doesn't.
		// Return S_FALSE if the writing system does not exist.
		HRESULT GetIcuLocaleFromWs(
			[in] int ws,
			[out, retval] BSTR * pbstr);

		// Get the number of writing systems currently installed in the system
		[propget] HRESULT NumberOfWs(
			[out, retval] int * pcws);
		// Get the list of writing systems currrently installed in the system.
		HRESULT GetWritingSystems(
			[out, size_is(cws)] int * rgws,
			[in] int cws);

		// Get the renderer for a particular WS
		[propget] HRESULT Renderer(
			[in] int ws,
			[in] IVwGraphics * pvg,
			[out, retval] IRenderEngine ** ppre);
		// Get the renderer for a particular Chrp
		[propget] HRESULT RendererFromChrp(
			[in] IVwGraphics * pvg,
			// should be [in, ref] possibly?
			[in, out] LgCharRenderProps * pchrp,
			[out, retval] IRenderEngine ** ppre);

		// Get the default user interface writing system.
		[propget] HRESULT UserWs(
			[out, retval] int * pws);
		// Set the default user interface writing system. This should usually be done very early in
		// the lifecycle of the WSF.
		[propput] HRESULT UserWs(
			[in] int ws);
	};

#ifndef NO_COCLASSES
/*************************************************************************************//*:Ignore
	CoClass definitions.
***********************************************************************************************/
	// A collater based on Unicode Techinical Report 10.
	DeclareCoClass(LgUnicodeCollater, 0D9900D2-1693-481F-AA70-7EA64F264EC4)
	{
		interface ILgCollatingEngine;
	};

	DeclareCoClass(LgLineBreaker, 94FBFA34-21E5-4A1E-B576-BA5D76CC051A)
	{
		interface ILgLineBreaker;
	};
#endif /*!NO_COCLASSES*/
