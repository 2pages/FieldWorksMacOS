/*--------------------------------------------------------------------*//*:Ignore this sentence.
Copyright (c) 1999-2013 SIL International
This software is licensed under the LGPL, version 2.1 or later
(http://www.gnu.org/licenses/lgpl-2.1.html)

File: Language.idh
Responsibility: John Thomson
Last reviewed: Mid June, 2000. Several changes suggested, not yet all made or reviewed.

Description:
	The Language classes provide specifications and implementations of how text in various
	(language) writing systems behaves.

	Note: Language.idh is included in FwKernelTlb.idl. This is how it becomes available to C#
	programs. Therefore, to make a new or modified interface available without remakefw,
	you must cc mkfwk-nodep, than do a clean COMInterfaces-nodep, then build COMInterfaces-nopdep.

	The root (document) class is the LgWritingSystem class. Logically there ought
	possibly to be a LgLanguage class which owns a number of writing systems; but a Language
	has no computationally interesting behavior until it is encoded in a writing system, and it
	is useful to be able to install an writing system in isolation. We therefore decided not to
	implement Language as a distinct class, but just to have the LgWritingSystem class
	provide some basic documentation about its language.

	The language writing system class has a number of "engines." Each of these implements an
	interface for one area of functionality related to text manipulation.

	Note that writing systems as described in this document are not intended to model the
	linguistically interesting aspects of these concepts. They are specifically intended to
	model those aspects needed so that the computer can correctly manipulate data in the
	particular writing system.
-------------------------------------------------------------------------------*//*:End Ignore*/
// Indentation is as if all this were embedded in a library declaration.

	//:>****************************************************************************************
	//:>		Forward declarations
	//:>****************************************************************************************
	interface IRenderEngine;
	interface ILgCharacterPropertyEngine;
	interface ILgCollatingEngine;
	interface ICollation;
	interface ILgWritingSystem;
	interface ILgWritingSystemFactory;

	//:>****************************************************************************************
	//:>		Enumerations
	//:>****************************************************************************************

	// Main types of characters, as defined by Unicode and used by the character
	// property engine.
	typedef [v1_enum] enum LgGeneralCharCategory
	{
		kccLu, // = Letter, Uppercase
		kccLl, // = Letter, Lowercase
		kccLt, // = Letter, Titlecase (e.g., Dz digraph as single code point)
		kccLm, // = Letter, Modifier
		kccLo, // = Letter, Other

		kccMn, // = Mark, Non-Spacing
		kccMc, // = Mark, Spacing Combining
		kccMe, // = Mark, Enclosing

		kccNd, // = Number, Decimal Digit
		kccNl, // = Number, Letter
		kccNo, // = Number, Other

		kccZs, // = Separator, Space
		kccZl, // = Separator, Line
		kccZp, // = Separator, Paragraph

		kccCc, // = Other, Control
		kccCf, // = Other, Format
		kccCs, // = Other, Surrogate
		kccCo, // = Other, Private Use
		kccCn, // = Other, Not Assigned

		kccPc, // = Punctuation, Connector
		kccPd, // = Punctuation, Dash
		kccPs, // = Punctuation, Open
		kccPe, // = Punctuation, Close
		kccPi, // = Punctuation, Initial quote (may behave like Ps or Pe depending
			   //				  on usage)
		kccPf, // = Punctuation, Final quote (may behave like Ps or Pe depending
			   //				  on usage)
		kccPo, // = Punctuation, Other

		kccSm, // = Symbol, Math
		kccSc, // = Symbol, Currency
		kccSk, // = Symbol, Modifier
		kccSo, // = Symbol, Other
	} LgGeneralCharCategory;  // Hungarian: cc

	// Unicode Bidirectional Categories, used by character property engine
	typedef [v1_enum] enum LgBidiCategory
	{
		// Strong
		kbicL,   // Left-Right; most alphabetic chars, etc.
		kbicLRE, // Left-Right Embedding
		kbicLRO, // Left-Right Override
		kbicR,   // Right-Left; Hebrew and its punctuation
		kbicAL,  // Right-Left Arabic
		kbicRLE, // Right-Left Embedding
		kbicRLO, // Right-Left Override
		kbicPDF, // Pop Directional Format

		// Weak
		kbicEN,  //	European Number
		kbicES,  //	European Number Separator
		kbicET,  //	European Number Terminator
		kbicAN,  //	Arabic Number
		kbicCS,  //	Common Number Separator

		// Separators:
		kbicNSM, // Non-Spacing Mark
		kbicBN,  // Boundary Neutral
		kbicB,   //	Paragraph Separator
		kbicS,   //	Segment Separator

		// Neutrals:
		kbicWS,  //	Whitespace
		kbicON,  //	Other Neutrals ; All other characters: punctuation, symbols
	} LgBidiCategory;  // Hungarian: bic

	// Line Breaking Character classes defined by Unicode.
	typedef [v1_enum] enum LgLBP
	{
				 // '*' indicates normative property
		klbpAI,  //  0   Ambiguous (Alphabetic or Ideographic)
		klbpAL,  //  1   Ordinary Alphabetic
		klbpB2,  //  2   Break Opportunity Before and After
		klbpBA,  //  3   Break Opportunity After
		klbpBB,  //  4   Break Opportunity Before
		klbpBK,  //  5 * Mandatory Break
		klbpCB,  //  6 * Contingent Break Opportunity
		klbpCL,  //  7   Closing
		klbpCM,  //  8 * Combining Marks
		klbpCR,  //  9 * Carriage Return
		klbpEX,  // 10   Exclamation
		klbpGL,  // 11 * Non-breaking ("Glue")
		klbpHY,  // 12   Hyphen
		klbpID,  // 13   Ideographic
		klbpIN,  // 14   Inseparable
		klbpIS,  // 15   Infix Separator (Numeric)
		klbpLF,  // 16 * Line Feed
		klbpNS,  // 17   Non Starter
		klbpNU,  // 18   Numeric
		klbpOP,  // 19   Opening
		klbpPO,  // 20   Postfix (Numeric)
		klbpPR,  // 21   Prefix (Numeric)
		klbpQU,  // 22   Ambiguous Quotation
		klbpSA,  // 23   Complex Context
		klbpSG,  // 24 * Surrogates
		klbpSP,  // 25 * Space
		klbpSY,  // 26   Symbols Allowing Breaks
		klbpXX,  // 27   Unknown (used for unassigned characters)
		klbpZW   // 28 * Zero Width Space
	} LgLBP;  // Hungarian lbp

	// Character decomposition tags
	typedef [v1_enum] enum LgDecompMapTag
	{
		kdtNoTag,
		kdtFont,
		kdtNoBreak,
		kdtInitial,
		kdtMedial,
		kdtFinal,
		kdtIsolated,
		kdtCircle,
		kdtSuper,
		kdtSub,
		kdtVertical,
		kdtWide,
		kdtNarrow,
		kdtSmall,
		kdtSquare,
		kdtFraction,
		kdtCompat
	} LgDecompMapTag;	// Hungarian dt

	// XML tags
	typedef [v1_enum] enum LgXMLTag
	{
		kxmlInvalid,
		kxmlChardefs,
		kxmlDef,
		kxmlUdata,
		kxmlLinebrk
	} LgXMLTag;		// Hungarian xml

	/*******************************************************************************************
		Interface ILgWritingSystem
		An LgWritingSystem represents one way of writing data in a particular language
		(or dialect). It has a number of engines which implement various aspects of writing
		system behavior.

		ENHANCE: May need some more 'documentation' type attributes, such as
		an author, region, country--what exactly is useful?

		@h3{When to implement}
		Clients should not implement this interface.

		@h3{When to use}
		Use this class when you need to get one of the engines or other bits of information
		it stores about an writing system. In some cases, if you need only one engine, it is
		simpler to ask the ${LgWritingSystemFactory} for it in a single step.

		Don't use an ILgWritingSystem when you just need to identify an writing system, but
		don't actually need any of the engines. Use the integer which stands for the writing
		system.

		@h3{How to obtain an instance}
		Normally, use the get_Engine method of an ${LgWritingSystemFactory}. This will create
		and writing system with all default engines if one does not already exist. To avoid
		this, use get_EngineOrNull instead.

		@h3{Hungarian: ws or wseng}
		(Note: use wseng when you need to distinguish the interface/object from the writing
		system's integer code, which uses ws as its Hungarian.)
	*******************************************************************************************/
	DeclareInterface(LgWritingSystem, Unknown, FF923C7E-A7C1-4760-B8E5-7A6D28F4AECB)
	{
		// The identifier for this writing system.
		[propget] HRESULT Id(
			[out, retval] BSTR *pbstr);

		// GET THE WRITING SYSTEM INTEGER that identifies this writing system to classes which
		// don't actually need to use its methods
		[propget] HRESULT Handle(
			[out, retval] int * pws);

		// Get the language name.
		[propget] HRESULT LanguageName(
			[out, retval] BSTR * pbstr);

		// Get the name of the spelling dictionary to use for this writing system.
		// Currently returns a generally-useful default, unless explicitly set to empty
		// to prevent this.
		[propget] HRESULT SpellCheckingId(
			[out, retval] BSTR *pbstr);

		// Get the primary direction, used for complex embedding; may have fragments like
		// numbers that go the other way internally.
		[propget] HRESULT RightToLeftScript(
			[out, retval] ComBool * pfRightToLeft);

		// Get the engine used to render text with the specified properties. At present only
		// font, bold, and italic properties are significant.
		// Font name may be '<default serif>' which produces a renderer suitable for the default
		// serif font.
		[propget] HRESULT Renderer(
			[in] IVwGraphics * pvg,
			[out, retval] IRenderEngine ** ppreneng);

		// Get the "serif font variation" string which is used, for instance, to specify
		// Graphite features.
		[propget] HRESULT DefaultFontFeatures(
			[out, retval] BSTR * pbstr);

		// Get the default serif font; usually used for the main body of text in a document.
		[propget] HRESULT DefaultFontName(
			[out, retval] BSTR * pbstr);

		// Get the engine used to find character properties, including figuring out where line
		// breaks are allowed.
		[propget] HRESULT CharPropEngine(
			[out, retval] ILgCharacterPropertyEngine ** pppropeng);

		// Apply any changes to the chrp before it is used for real: currently,
		// interpret the magic font names.
		HRESULT InterpretChrp(
			[in, out] LgCharRenderProps * pchrp);

		// Returns true to pass NFC text to the keyboard, otherwise we pass NFD.
		[propget] HRESULT UseNfcContext(
			[out, retval] ComBool * pUseNfc);
	};

	//:>****************************************************************************************
	//:>	These are the interfaces for the engines--the code that actually does the work.
	//:>****************************************************************************************

	//:>****************************************************************************************
	//:>	CoClass definitions.
	//:>****************************************************************************************

	// Flags used to specify variations on how to collate.
	// Default is all listed options off.
	// Except where noted, options are orthogonal and may be ORed together for combined
	// effect.
	// Unrecognized options are ignored. This allows for forwards compatibility: as we
	// introduce new options, older engines will continue to work but ignore them.
	// (An unrecognized option is any bit not used by any of the options defined here.)
	typedef [v1_enum] enum LgCollatingOptions
	{
		fcoDefault = 0,
		fcoIgnoreCase = 1,
		fcoDontIgnoreVariant = 2,
		fcoLim // max valid value.
	} LgCollatingOptions; // Hungarian colopt

	/*******************************************************************************************
		Interface ILgCollatingEngine
		A collating engine knows how to compare strings in the same writing system.

		@h3{When to implement}
		Clients should not normally implement this interface. There are standard implementations
		in Language.dll. A new implementation might possibly be made for a language with very
		unusual collating requirements, if none of the standard implementations can be
		configured to suit.

		@h3{When to use}
		Use this interface when you need to know whether a given string collates before or after
		another, or to create a list of keys that can be simply compared in order to sort a
		larger list.

		@h3{How to obtain an instance}
		Obtain a collating engine from the writing system using
		${LgWritingSystem#get_CollatingEngine}. Obtain a default Unicode collater from
		${LgWritingSystemFactory#get_DefaultCollater}.

		@h3{Hungarian: coleng}
	*******************************************************************************************/
	DeclareInterface(LgCollatingEngine, Unknown, D27A3D8C-D3FE-4E25-9097-8F4A1FB30361)
	{
		// Get a sort key which may be compared to any other sort key produced by this
		// object via a simple BSTR comparison. This is especially useful in large-scale
		// sorting, where the work to generate the key only needs to be done once per key
		[propget] HRESULT SortKey(
			[in] BSTR bstrValue,
			[in] LgCollatingOptions colopt,
			[out, retval] BSTR * pbstrKey);

		// Get a sort key which may be compared to any other sort key produced by this
		// object via a simple wcscmp comparison. This is especially useful in large-scale
		// sorting, where the work to generate the key only needs to be done once per key

		// @param cchMaxOut Available space in output buffer. If 0, the method just sets
		// *pchKey to the number required.
		// @exception ERROR_INSUFFICIENT_BUFFER if not enough space in output buffer (gives
		// needed amount in *pcchOut).
		[restricted] HRESULT SortKeyRgch(
			[in, size_is(cchIn)] const OLECHAR * pch,
			[in] int cchIn,
			[in] LgCollatingOptions colopt,
			[in] int cchMaxOut,
			[out, size_is(cchMaxOut)] OLECHAR * pchKey,
			[out] int * pcchOut);

		// Return in *pnVal (<0, 0, or >0) depending on whether the first string is
		// (less than, equal, or greater than) the second string passed. This in principle
		// creates a SortKey for each string using the SortKey method, then compares them.
		// Any actual implementation promises to give the same results as doing that.
		// However, the actual implementation may be more efficient than that, saving time
		// when only a single comparison is to be made involving each string.
		HRESULT Compare(
			[in] BSTR bstrValue1,
			[in] BSTR bstrValue2,
			[in] LgCollatingOptions colopt,
			[out, retval] int * pnVal);

		// Get the language writing system factory used with this collating engine object.
		[propget] HRESULT WritingSystemFactory(
			[out, retval] ILgWritingSystemFactory ** ppwsf);
		// Set the language writing system factory to use with this collating engine object.
		[propputref] HRESULT WritingSystemFactory(
			[in] ILgWritingSystemFactory * pwsf);

		// The next two methods are required by C# which doesn't know that BSTRs can be anything
		// but NUL-terminated UTF-16 strings.

		// Get a sort key which may be compared to any other sort key produced by this
		// object via a simple BSTR comparison. This is especially useful in large-scale
		// sorting, where the work to generate the key only needs to be done once per key
		[propget] HRESULT SortKeyVariant(
			[in] BSTR bstrValue,
			[in] LgCollatingOptions colopt,
			[out, retval] VARIANT * psaKey);		// will be a "safearray".

		// Return in *pnVal (<0, 0, or >0) depending on whether the first string is
		// (less than, equal, or greater than) the second string passed. This in principle
		// creates a SortKey for each string using the SortKey method, then compares them.
		// Any actual implementation promises to give the same results as doing that.
		// However, the actual implementation may be more efficient than that, saving time
		// when only a single comparison is to be made involving each string.
		HRESULT CompareVariant(
			[in] VARIANT saValue1,			// "safearray"
			[in] VARIANT saValue2,			// "safearray"
			[in] LgCollatingOptions colopt,
			[out, retval] int * pnVal);

		// Initialize the collating engine to the given locale.
		HRESULT Open(
			[in] BSTR bstrLocale);

		// Close and free the currently open collating engine, if any.
		HRESULT Close();

		// ENHANCE JohnT: we should have an Rgch version of Compare().
	};

	/*******************************************************************************************
		Interface ILgCharacterPropertyEngine
		This interface provides information about character properties and converting between
		characters.

		Note the use of int rather than OLECHAR throughout for character codes. This allows
		for the possibility of characters not in plane 0, though the current base implementation
		considers all characters outside plane 0 to be unassigned.

		In general, routines which take a single character as input return E_INVALIDARG if the
		character is outside the extended Unicode range (i.e., it could not be represented as
		two surrogate pair characters).

		@h3{When to implement}
		Clients should not normally implement this interface. There are standard implementations
		in Language.dll.

		@h3{When to use}
		Use this interface when you need to know properties of characters, such as whether a
		character is a letter, how it behaves in the Unicode bidi algorithm, how it combines
		with other characters, whether it is a symbol, separator, etc, its case, how it
		might decompose, and so forth. A particularly important use is to determine possible
		line break positions in a string.

		@h3{How to obtain an instance}
		Obtain a collating engine from the writing system using
		${LgWritingSystem#get_CharPropEngine}. Obtain a default Unicode char props engine from
		${LgWritingSystemFactory#get_UnicodeCharProps}.

		@h3{Hungarian: propeng}
	*******************************************************************************************/
	DeclareInterface(LgCharacterPropertyEngine, Unknown, 890C5B18-6E95-438E-8ADE-A4FFADDF0684)
	{
		// Get the exact character category as defined in the Unicode standard.
		// See @HTTP{www.unicode.org/Public/UNIDATA/UnicodeData.html#General%20Category}
		[propget] HRESULT GeneralCategory(
			[in] int ch,
			[out, retval] LgGeneralCharCategory * pcc);

		// Get the Bidi category of a character as defined in the Unicode standard.
		// See @HTTP{www.unicode.org/Public/UNIDATA/UnicodeData.html#Bidirectional%20Category}
		// See @HTTP{www.unicode.org/unicode/reports/tr9/} for the full algorithm
		[propget] HRESULT BidiCategory(
			[in] int ch,
			[out, retval] LgBidiCategory * pbic);

		// Return true if Unicode general category starts with L. See ${#get_GeneralCategory}
		// If this returns true, exactly one of ${#get_IsUpper}, ${#get_IsLower},
		// ${#get_IsTitle}, ${#get_IsModifier}, or ${#get_IsOtherLetter} will return true.
		[propget] HRESULT IsLetter(
			[in] int ch,
			[out, retval] ComBool *pfRet);
		// Return true if character is considered to be part of a word (by default, this
		// corresponds to Unicode general category Mc, Mn, and categories starting with L.
		// ENHANCE: Eventually, this method may need to be altered or replaced to acocunt
		// for the reality that some languages have context rules to determine whether a
		// character is word-forming or not (e.g., apostrophes).
		// See ${#get_GeneralCategory}
		[propget] HRESULT IsWordForming(
			[in] int ch,
			[out, retval] ComBool *pfRet);
		// Return true if Unicode general category starts with P. See ${#get_GeneralCategory}
		[propget] HRESULT IsPunctuation(
			[in] int ch,
			[out, retval] ComBool *pfRet);
		// Return true if Unicode general category starts with N. See ${#get_GeneralCategory}
		[propget] HRESULT IsNumber(
			[in] int ch,
			[out, retval] ComBool *pfRet);
		// Return true if Unicode general category starts with Z. See ${#get_GeneralCategory}
		[propget] HRESULT IsSeparator(
			[in] int ch,
			[out, retval] ComBool *pfRet);
		// Return true if Unicode general category starts with S. See ${#get_GeneralCategory}
		[propget] HRESULT IsSymbol(
			[in] int ch,
			[out, retval] ComBool *pfRet);
		// Return true if Unicode general category starts with M. See ${#get_GeneralCategory}
		[propget] HRESULT IsMark(
			[in] int ch,
			[out, retval] ComBool *pfRet);
		// Return true if Unicode general category starts with C. See ${#get_GeneralCategory}
		[propget] HRESULT IsOther(
			[in] int ch,
			[out, retval] ComBool *pfRet);


		// Return true if Unicode general category is Lu. See ${#get_GeneralCategory}
		[propget] HRESULT IsUpper(
			[in] int ch,
			[out, retval] ComBool *pfRet);
		// Return true if Unicode general category is Ll. See ${#get_GeneralCategory}
		// In languages without case all characters are considered lower case.
		[propget] HRESULT IsLower(
			[in] int ch,
			[out, retval] ComBool *pfRet);
		// Return true if Unicode general category is Lt. See ${#get_GeneralCategory}
		// This refers to "Title case" characters, typically a single code point standing for
		// two letters, where the first is upper case and the second is lower.
		// Unicode general category Lt, typically digraph with first upper
		[propget] HRESULT IsTitle(
			[in] int ch,
			[out, retval] ComBool *pfRet);
		// Return true if Unicode general category is Lm. See ${#get_GeneralCategory}
		[propget] HRESULT IsModifier(
			[in] int ch,
			[out, retval] ComBool *pfRet);
		// Return true if Unicode general category is Lo. See ${#get_GeneralCategory}
		[propget] HRESULT IsOtherLetter(
			[in] int ch,
			[out, retval] ComBool *pfRet);

		// Return true if Unicode general category is Ps. See ${#get_GeneralCategory}
		// Signifies opening punctuation, like left paren
		// ENHANCE JohnT: Should opening include Pi, Initial quote?
		[propget] HRESULT IsOpen(
			[in] int ch,
			[out, retval] ComBool *pfRet);
		// Return true if Unicode general category is Pe. See ${#get_GeneralCategory}
		// Signifies closing punctuation, like right paren.
		// ENHANCE JohnT: should we also include Pf, final quote?
		[propget] HRESULT IsClose(  // Unicode general category Pe,
			[in] int ch,
			[out, retval] ComBool *pfRet);
		// Return true if Unicode general category is Pc. See ${#get_GeneralCategory}
		// Signifies  middle of a word, like hyphen.
		// ENHANCE JohnT: should we also include Pd, dash
		[propget] HRESULT IsWordMedial(
			[in] int ch,
			[out, retval] ComBool *pfRet);

		// Return true if Unicode general category is Cc. See ${#get_GeneralCategory}
		[propget] HRESULT IsControl(
			[in] int ch,
			[out, retval] ComBool *pfRet);

		// Convert a character to lower case if it is Lu or Lt; otherwise return it unchanged.
		// ENHANCE JohnT: should we convert characters that are not Lu or Lt but for which
		// UnicodeData.txt specifies a case conversion?
		//
		// See ${#ToLower} to convert an entire string, or to make use of Unicode muli-character
		// conversions.
		// @exception E_INVALIDARG if passed invalid Unicode code point, including one half
		// of a surrogate pair.
		[propget] HRESULT ToLowerCh(
				  [in] int ch,
				  [out, retval] int * pch);
		// Convert a character to upper case if it is Ll or Lt; otherwise return it unchanged.
		// ENHANCE JohnT: should we convert characters that are not Ll or Lt but for which
		// UnicodeData.txt specifies a case conversion?
		//
		// See ${#ToUpper} to convert an entire string, or to make use of Unicode muli-character
		// conversions.
		// @exception E_INVALIDARG if passed invalid Unicode code point, including one half
		// of a surrogate pair.
		[propget] HRESULT ToUpperCh(
				  [in] int ch,
				  [out, retval] int * pch);
		// Convert a character to title case if it is Lu or Ll; otherwise return it unchanged.
		// Usually this is the same as converting it to upper case.
		// ENHANCE JohnT: should we convert characters that are not Lu or Ll but for which
		// UnicodeData.txt specifies a case conversion?
		//
		// See ${#ToTitle} to convert an entire string, or to make use of Unicode muli-character
		// conversions.
		// @exception E_INVALIDARG if passed invalid Unicode code point, including one half
		// of a surrogate pair.
		[propget] HRESULT ToTitleCh(
				  [in] int ch,
				  [out, retval] int * pch);

		// Convert a string to lower case. Characters that are not Lu or Lt pass through
		// unchanged.  Note that the output may be longer than the input! This function, unlike
		// ${#get_ToLowerCh}, will apply multi-character conversions if Unicode specifies them.
		// @exception E_INVALIDARG if characters in input are not valid Unicode.
		HRESULT ToLower(
				  [in] BSTR bstr,
				  [out, retval] BSTR * pbstr);
		// Convert a string to upper case. Characters that are not Ll or Lt pass through
		// unchanged.  Note that the output may be longer than the input! This function, unlike
		// ${#get_ToUpperCh}, will apply multi-character conversions if Unicode specifies them.
		// @exception E_INVALIDARG if characters in input are not valid Unicode.
		HRESULT ToUpper(
				  [in] BSTR bstr,
				  [out, retval] BSTR * pbstr);
		// Convert a string to title case. Characters that are not Lu or Ll pass through
		// unchanged.  Note that the output may be longer than the input!  This function, unlike
		// ${#get_ToUpperCh}, will apply multi-character conversions if Unicode specifies them.
		// Note that this is not usually useful, because if you want title case, you usually
		// want to convert only the first non-punctuation character, or perhaps the first of
		// each word.  However, this at least provides a way to get at multi-character
		// conversions by passing a single character input string.
		// @exception E_INVALIDARG if characters in input are not valid Unicode.
		HRESULT ToTitle(
				  [in] BSTR bstr,
				  [out, retval] BSTR * pbstr);

		// Convert a string to lower case. Characters that are not Lu or Lt pass through
		// unchanged.  Note that the output may be longer than the input! This function, unlike
		// ${#get_ToLowerCh}, will apply multi-character conversions if Unicode specifies them.
		// If cchOut is zero, just return the length needed.
		// @exception E_FAIL if cchOut is non-zero and too small
		// @exception E_INVALIDARG if characters in input are not valid Unicode.
		[restricted] HRESULT ToLowerRgch(
				  [in, size_is(cchIn)] OLECHAR * prgchIn,
				  [in] int cchIn,
				  [out, size_is(cchOut)] OLECHAR * prgchOut,
				  [in] int cchOut,
				  [out] int * pcchRet);
		// Convert a string to upper case. Characters that are not Ll or Lt pass through
		// unchanged.  Note that the output may be longer than the input! This function, unlike
		// ${#get_ToUpperCh}, will apply multi-character conversions if Unicode specifies them.
		// If cchOut is zero, just return the length needed.
		// @exception E_FAIL if cchOut is non-zero and too small
		// @exception E_INVALIDARG if characters in input are not valid Unicode.
		[restricted] HRESULT ToUpperRgch(
				  [in, size_is(cchIn)] OLECHAR * prgchIn,
				  [in] int cchIn,
				  [out, size_is(cchOut)] OLECHAR * prgchOut,
				  [in] int cchOut,
				  [out] int * pcchRet);
		// Convert a string to title case. Characters that are not Lu or Ll pass through
		// unchanged.  Note that the output may be longer than the input! This function, unlike
		// ${#get_ToUpperCh}, will apply multi-character conversions if Unicode specifies them.
		// Note that this is not usually useful, because if you want title case, you usually
		// want to convert only the first non-punctuation character, or perhaps the first of
		// each word.  However, this at least provides a way to get at multi-character
		// conversions by passing a single character input string.
		// If cchOut is zero, just return the length needed.
		// @exception E_FAIL if cchOut is non-zero and too small
		// @exception E_INVALIDARG if characters in input are not valid Unicode.
		[restricted] HRESULT ToTitleRgch(
				  [in, size_is(cchIn)] OLECHAR * prgchIn,
				  [in] int cchIn,
				  [out, size_is(cchOut)] OLECHAR * prgchOut,
				  [in] int cchOut,
				  [out] int * pcchRet);

		// Returns true if the specified code point is a member of the specified user defined
		// class of code points. Nathan thinks we should restrict class names to a single
		// character to make patterns containing them more readable. Example \C\Vxyz for all
		// words containing a consonant, followed by a vowel, followed by xyz.
		//
		// Not yet implemented, and may not be, as it is not clear that this is the right place
		// to store user defined character classes.
		[propget] HRESULT IsUserDefinedClass(
			[in] int ch,
			[in] int chClass,
			[out, retval] ComBool * pfRet);

		// Converts a string into another string in which all characters are replaced with their
		// sound alike equivalent. For example, if for this language s and z where specified to
		// sound alike, we could take s as the generic form and convert all z's to this form.
		// Note that we need to support the possibility that 0 (empty code point) and x and y
		// sound alike which means that all x's and 's and y's will be ignored when testing for
		// sound alikeness.
		//
		// ENHANCE JohnT: Should this be a separate engine? Does it belong to the spelling
		// engine?
		// ENHANCE Development(JohnT): enhance the specification so it can specify sound-alikes.
		//
		// Not yet implemented, and may never be.
		[propget] HRESULT SoundAlikeKey(
			[in] BSTR bstrValue,
			[out, retval] BSTR * pbstrKey);

		// Get the official Unicode character name (character database field 1).
		// Will also produce a somewhat helpful descriptive string for surrogate halves and
		// PUA characters, though officially they have no name.
		// (Warning: obtaining this for the first character in each page will be somewhat slow,
		// and will use up something like 10K of RAM).
		// @exception E_INVALIDARG if character input is not valid Unicode.
		[propget] HRESULT CharacterName(
			[in] int ch,
			[out, retval] BSTR * pbstrName);

		// Get the decomposition of this character (Unicode char database field 5).
		// Empty string if it does not decompose.
		// @exception E_INVALIDARG if character input is not valid Unicode.
		[propget] HRESULT Decomposition(
			[in] int ch,
			[out, retval] BSTR * pbstr);
		// Get the decomposition of this character (Unicode char database field 5).
		// Empty string if it does not decompose.
		// @exception E_INVALIDARG if character input is not valid Unicode.
		[restricted] HRESULT DecompositionRgch(
			[in] int ch,
			[in] int cchMax,
			[out] OLECHAR * prgch,
			[out] int * pcch,
			[out] ComBool * pfHasDecomp);

		// Get the recursive canonical decomposition of a character. Empty string if it does
		// not decompose at all.
		// @exception E_INVALIDARG if character input is not valid Unicode.
		[propget] HRESULT FullDecomp(
			[in] int ch,
			[out, retval] BSTR * pbstrOut);
		// Get the recursive canonical decomposition of a character. The character itself if it
		// does not decompose at all.
		// @exception E_INVALIDARG if character input is not valid Unicode.
		[restricted] HRESULT FullDecompRgch(
			[in] int ch,
			[in] int cchMax,
			[out] OLECHAR * prgch,
			[out] int * pcch,
			[out] ComBool * pfHasDecomp);

		// Get the character's value as a number.(Field 8 in
		// @HTTP{www.unicode.org/Public/UNIDATA/UnicodeData.html}).
		// @exception E_INVALIDARG if character input is not valid Unicode.
		// @exception E_UNEXPECTED if the character is not
		// one of the Nd, Nl, or No types, or if it is one of those types but the
		// Unicode database gives no numeric value for it.
		// Currently also if the character represents a fraction.
		// @end
		// ENHANCE JohnT: is there a more useful behavior for the fraction case?
		// Would it be better to return 0 for all cases where we don't know a useful answer?
		[propget] HRESULT NumericValue(
			[in] int ch,
			[out, retval] int * pn);

		// Get the character's combining class (Unicode char database field 3; see
		// @HTTP{www.unicode.org/Public/UNIDATA/UnicodeData.html#Canonical%20Combining%20Classes})
		// @exception E_INVALIDARG if character input is not valid Unicode.
		[propget] HRESULT CombiningClass(
			[in] int ch,
			[out, retval] int * pn);

		// Get any comment recorded about this character (Unicode char database field 11).
		// Note: currently this is not implemented to obtain the rather uninteresting comments
		// recorded in the standard UnicodeDatabase file. It will give interesting answers only
		// if a comment is provided in the specification for this writing system.
		[propget] HRESULT Comment(
			[in] int ch,
			[out, retval] BSTR * pbstr);

		// Get line breaking properties (from enumeration LgLBP) for an array of characters.
		// This passes an array in, and an array with the same number of elements out, to
		// improve efficiency when properties are required for a string of characters.
		// See @HTTP{www.unicode.org/unicode/reports/tr14/}.
		// @exception E_INVALIDARG if characters in input are not valid Unicode.
		[restricted] HRESULT GetLineBreakProps(
			[in, size_is(cchIn)] const OLECHAR * prgchIn,
			[in] int cchIn,
			[out, size_is(cchIn)] byte * prglbOut);

		// Get line break status (from combinations of values in enumeration LgLineBreakStatus)
		// of each character in the input array.
		// @exception E_INVALIDARG if characters in input are not valid Unicode.
		[restricted] HRESULT GetLineBreakStatus(
			[in, size_is(cb)] const byte * prglbpIn,
			[in] int cb,
			[out, size_is(cb)] byte * prglbsOut);

		// This combines the functions of ${#GetLineBreakProps} and ${#GetLineBreakStatus},
		// plus the ability to skip part of the string, and stop at break characters.
		//
		// The first two arguments define an array of characters as for ${#GetLineBreakProps}.
		// The output is basically what would be produced by passing the output of
		// that method as input to GetLineBreakStatus, with two exceptions:
		//
		// 1. We only want line break status info for characters from ichMin to ichLim.
		// (A larger array is passed in because we may need to look at preceding characters
		// to confidently know whether we can break after the char at ichMin.)
		//
		// 2. If we detect a character which forces a line or segment break in the range
		// ichMin..ichLim, we stop and do not return any info about subsequent characters.
		//
		// Also, we set *pichBreak to the index of the break character.
		// *pichBreak is set to -1 if we don't find a break character.
		// Break characters are things like CR, LF, TAB, or the embedded object character.
		[restricted] HRESULT GetLineBreakInfo(
			[in, size_is(cchIn)] const OLECHAR * prgchIn,
			[in] int cchIn,
			[in] int ichMin,
			[in] int ichLim,
			[out, size_is(ichLim - ichMin)] byte * prglbsOut,
			[out] int * pichBreak);

		// Strip diacritics. Specifically, removes all characters that have the property Lm on
		// Mn.  Note that this will not comvert a single code point that includes a diacritic to
		// its unmodified equivalent. It is usually desireable to first perform normalization
		// (form D or KD) before stripping diacritics.
		HRESULT StripDiacritics(
			  [in] BSTR bstr,
			  [out, retval] BSTR * pbstr);
		// Strip diacritics. Specifically, removes all characters that have the property Lm or
		// Mn.  Note that this will not comvert a single code point that includes a diacritic to
		// its unmodified equivalent. It is usually desireable to first perform normalization
		// (form D or KD) before stripping diacritics.
		[restricted] HRESULT StripDiacriticsRgch(
			[in, size_is(cchIn)] OLECHAR * prgchIn,
			[in] int cchIn,
			[out, size_is(cchMaxOut)] OLECHAR * prgchOut,
			[in] int cchMaxOut,
			[out] int * pcchOut);

		// Perform compatibility normalization of the input string, that is, every character
		// which  has a compatibility decomposition is decomposed (recursively). This is
		// Normalization Form KD (NFKD) as defined by Unicode TR 15.
		[restricted] HRESULT NormalizeKdRgch(
			[in, size_is(cchIn)] OLECHAR * prgchIn,
			[in] int cchIn,
			[out, size_is(cchMaxOut)] OLECHAR * prgchOut,
			[in] int cchMaxOut,
			[out] int * pcchOut);

		// Perform normalization of the input string, that is, every character
		// which  has a decomposition is decomposed (recursively). This is
		// Normalization Form D (NFD) as defined by Unicode TR 15.
		HRESULT NormalizeD(
			  [in] BSTR bstr,
			  [out, retval] BSTR * pbstr);
		// Perform compatibility normalization of the input string, that is, every character
		// which  has a compatibility decomposition is decomposed (recursively). This is
		// Normalization Form D (NFD) as defined by Unicode TR 15.
		[restricted] HRESULT NormalizeDRgch(
			[in, size_is(cchIn)] OLECHAR * prgchIn,
			[in] int cchIn,
			[out, size_is(cchMaxOut)] OLECHAR * prgchOut,
			[in] int cchMaxOut,
			[out] int * pcchOut);

		// Returns the locale of the engine.  See put_Locale for more notes.
		[propget] HRESULT Locale(
			[out, retval] int * pnLocale);

		// Assigns the locale of the engine.  The locale affects the ICU functions called for
		// line breaking and changing cases.  Note that the locale is read in using the
		// Microsoft format we've been using for the rest of FieldWorks, as opposed to the ICU
		// format (which it's translated into inside the class implementation).
		[propput] HRESULT Locale(
			[in] int nLocale);

		// Gets the text that the LineBreakBefore and LineBreakAfter functions are using.  This
		// function is included for completion.
		HRESULT GetLineBreakText(
			[in] int cchMax,
			[out] OLECHAR * prgchOut,
			[out] int * pcchOut);
		// Sets the text for the LineBreakBefore and the LineBreakAfter functions to use.
		[propput] HRESULT LineBreakText(
			[in, size_is(cchMax)] OLECHAR * prgchIn,
			[in] int cchMax);


		// Finds the nearest line break immediately before the given index (ichIn).  The
		// function returns not only a location but the weight of the line break (currently not
		// implemented).  See http://www.unicode.org/unicode/reports/tr14/ for more information
		// on line breaking properties.
		HRESULT LineBreakBefore(
			[in] int ichIn,
			[out] int * pichOut,
			[out] LgLineBreak * plbWeight);

		// Finds the nearest line break immediately after the given index (ichIn).  The function
		// returns not only a location but the weight of the line break (currently not
		// implemented).  See http://www.unicode.org/unicode/reports/tr14/ for more information
		// on line breaking properties.
		HRESULT LineBreakAfter(
			[in] int ichIn,
			[out] int * pichOut,
			[out] LgLineBreak * plbWeight);
	};

	/*******************************************************************************************
		Interface ILgIcuCharPropEngine
		This interface provides initialization functions for an ICU character property engine.

		@h3{When to implement}
		Clients should not normally implement this interface. There are standard implementations
		in Language.dll.

		@h3{When to use}
		Use this interface when you need to initialize an ICU character property engine.

		@h3{How to obtain an instance}
		For now the only way is to create one using CoCreateInstance, with
		CLSID_LgIcuCharPropEngine.

		@h3{Hungarian: ipropeng}
	*******************************************************************************************/
	DeclareInterface(LgIcuCharPropEngine, LgCharacterPropertyEngine, E8689492-7622-427b-8518-6339294FD227)
	{
		HRESULT Initialize(
			[in] BSTR bstrLanguage,
			[in] BSTR bstrScript,
			[in] BSTR bstrCountry,
			[in] BSTR bstrVariant);

		HRESULT InitCharOverrides(
			[in] BSTR bstrWsCharsList);
	}

	/*******************************************************************************************
		Interface ILgWritingSystemFactory
		Knows how to find an writing system engine from an writing system integer or an ICU
		Locale string.

		@h3{When to implement}
		Never implement this interface.

		@h3{When to use}
		Use this interface when you need to obtain writing systems and their engines.

		@h3{How to obtain an instance}

		@h3{Hungarian: wsf}
	*******************************************************************************************/
	DeclareInterface(LgWritingSystemFactory, Unknown, 22376578-BFEB-4c46-8D72-C9154890DD16)
	{
		// Get the actual writing system object for a given ICU Locale string.
		// The current implementation returns any existing writing system for that ICU Locale,
		// or creates one with default settings if one is not already known.
		// (Use ${#get_EngineOrNull} to avoid automatic creation of a new engine.)
		[propget] HRESULT Engine(
			[in] BSTR bstrIcuLocale,
			[out, retval] ILgWritingSystem ** ppwseng);

		// Get the actual writing system object for a given code, or returns NULL if one does
		// not already exist.
		// (Use ${#get_Engine} if you prefer to have an writing system created automatically if
		// one does not already exist.)
		[propget] HRESULT EngineOrNull(
			[in] int ws,
			[out, retval] ILgWritingSystem ** ppwseng);

		// Get an writing system ID from an ICULocale, or 0 if no such writing system exists.
		// Return S_FALSE if the writing system does not exist.
		HRESULT GetWsFromStr(
			[in] BSTR bstr,
			[out, retval] int * pwsId);
		// Get the ICULocale for the writing system if it exists, or NULL if it doesn't.
		// Return S_FALSE if the writing system does not exist.
		HRESULT GetStrFromWs(
			[in] int wsId,
			[out, retval] BSTR * pbstr);

		// Get the number of writing systems currently installed in the system
		[propget] HRESULT NumberOfWs(
			[out, retval] int * pcws);
		// Get the list of writing systems currrently installed in the system.
		HRESULT GetWritingSystems(
			[out, size_is(cws)] int * rgws,
			[in] int cws);

		// Get the char prop engine for a particular WS
		[propget] HRESULT CharPropEngine(
			[in] int ws,
			[out, retval] ILgCharacterPropertyEngine ** pplcpe);
		// Get the renderer for a particular WS
		[propget] HRESULT Renderer(
			[in] int ws,
			[in] IVwGraphics * pvg,
			[out, retval] IRenderEngine ** ppre);
		// Get the renderer for a particular Chrp
		[propget] HRESULT RendererFromChrp(
			[in] IVwGraphics * pvg,
			// should be [in, ref] possibly?
			[in, out] LgCharRenderProps * pchrp,
			[out, retval] IRenderEngine ** ppre);

		// Get the default user interface writing system.
		[propget] HRESULT UserWs(
			[out, retval] int * pws);
		// Set the default user interface writing system. This should usually be done very early in
		// the lifecycle of the WSF.
		[propput] HRESULT UserWs(
			[in] int ws);
	};

/*******************************************************************************************
	Interface ILgIcuConverterEnumerator

	An interface that allows retrieving a list of the converters that ICU supports.
	Eventually it may also support creating converters, though our preferred approach is
	to use the EncConverters interface.

	@h3{When to implement}
	The standard implementation should suffice.

	@h3{When to use}
	To retrieve a list of available converters.

	@h3{Hungarian: lcpe}
*******************************************************************************************/
DeclareInterface(LgIcuConverterEnumerator, Unknown, 8E6D558E-8755-4EA1-9FF6-039D375312E9)
{
	// Get the count of available converters.
	[propget] HRESULT Count(
		[out, retval] int * pcconv);

	// Get the nth converter name.
	[propget] HRESULT ConverterName(
		[in] int iconv,
		[out,retval] BSTR * pbstrName);

	// Get the ID string that identifies the converter to ICU.
	[propget] HRESULT ConverterId(
		[in] int iconv,
		[out,retval] BSTR * pbstrName);

};

/*******************************************************************************************
	Interface ILgIcuTransliteratorEnumerator

	An interface that allows retrieving a list of the transliterators that ICU supports.
	Eventually it may also support creating transliterators, though our preferred approach is
	to use the EncConverters interface.

	@h3{When to implement}
	The standard implementation should suffice.

	@h3{When to use}
	To retrieve a list of available converters.

	@h3{Hungarian: lcpe}
*******************************************************************************************/
DeclareInterface(LgIcuTransliteratorEnumerator, Unknown, 50F2492C-6C46-48BA-8B7F-5F04153AB2CC)
{
	// Get the count of available converters.
	[propget] HRESULT Count(
		[out, retval] int * pctrans);

	// Get the nth converter name.
	[propget] HRESULT TransliteratorName(
		[in] int itrans,
		[out,retval] BSTR * pbstrName);

	// Get the ID string that identifies the transliterator to ICU.
	[propget] HRESULT TransliteratorId(
		[in] int iconv,
		[out,retval] BSTR * pbstrName);
};

/*******************************************************************************************
	Interface ILgLocaleEnumerator

	An interface that allows retrieving a list of the available ICU locales on the system.

	@h3{When to implement}
	The standard implementation should suffice.

	@h3{When to use}
	To retrieve a list of available locales.

	@h3{Hungarian: lcpe}
*******************************************************************************************/
DeclareInterface(LgIcuLocaleEnumerator, Unknown, 08F649D0-D8AB-447B-AAB6-21F85CFA743C)
{
	// Get the count of available converters.
	[propget] HRESULT Count(
		[out, retval] int * pclocale);

	// Get the nth locale name. (ICU getName.)
	[propget] HRESULT Name(
		[in] int iloc,
		[out, retval] BSTR * pbstrName);

	// Get the nth locale language identifier. (ICU getLanguage.)
	[propget] HRESULT Language(
		[in] int iloc,
		[out, retval] BSTR * pbstrName);

	// Get the nth locale country. (ICU getCountry.)
	[propget] HRESULT Country(
		[in] int iloc,
		[out, retval] BSTR * pbstrName);

	// Get the nth locale variant. (ICU getVariant.)
	[propget] HRESULT Variant(
		[in] int iloc,
		[out, retval] BSTR * pbstrName);

	// Get the display name of the locale represented by this enumerator.
	// The display name will be in the selected locale if it is non-empty;
	// pass null or an empty string to get the system default locale.
	[propget] HRESULT DisplayName(
		[in] int iloc,
		[in] BSTR bstrLocaleName,
		[out, retval] BSTR * pbstrName);

};

/*******************************************************************************************
	Interface ILgIcuResourceBundle

	An interface that represents an instance of an ICU ResourceBundle object.

	@h3{When to implement}
	The standard implementation should suffice.

	@h3{When to use}
	To retrieve information from ICU resources; this is useful for things like enumerating
	the countries and locales known to the system.

	@h3{Hungarian: lcpe}
*******************************************************************************************/
DeclareInterface(LgIcuResourceBundle, Unknown, C243C72A-0D15-44D9-ABCB-A6E875A7659A)
{
	// Initialize the root resource bundle. The path may be null to use the standard
	// FieldWorks ICU data directory.
	HRESULT Init(
		[in] BSTR bstrPath,
		[in] BSTR locale);

	// Get the key of the bundle. (Icu getKey.)
	[propget] HRESULT Key(
		[out, retval] BSTR * pbstrKey);

	// Get the 'string' of the bundle. (Icu getString.)
	[propget] HRESULT String(
		[out, retval] BSTR * pbstrString);

	// Get the name of the bundle. (Icu getName.) Note that the Key and String of the
	// bundle are often more useful.
	[propget] HRESULT Name(
		[out, retval] BSTR * pbstrName);

	// Get another resource bundle for a subsection of this one. (Icu get.)
	// If the resource does not exist, this sets pprb to NULL.
	[propget] HRESULT GetSubsection(
		[in] BSTR bstrSectionName,
		[out, retval] ILgIcuResourceBundle ** pprb);

	// Determine whether the bundle has more sub-resources accessible through get_Next.
	// (Icu hasNext.)
	[propget] HRESULT HasNext(
		[out, retval] ComBool * pfHasNext);

	// Get the 'next' subsection and advance. The first call to this retrieves the first
	// item. Call only while HasNext returns true. (Icu getNext.)
	[propget] HRESULT Next(
		[out, retval] ILgIcuResourceBundle ** pprb);

	// Get the size of the bundle. (Icu getSize.)
	[propget] HRESULT Size(
		[out, retval] int * pcrb);

	// Get the ith string. (Icu getStringEx.)
	[propget] HRESULT StringEx(
		[in] int irb,
		[out, retval] BSTR * pbstr);
};

#ifndef NO_COCLASSES
/*************************************************************************************//*:Ignore
	CoClass definitions.
***********************************************************************************************/
	// A collater based on Unicode Techinical Report 10.
	DeclareCoClass(LgUnicodeCollater, 0D9900D2-1693-481F-AA70-7EA64F264EC4)
	{
		interface ILgCollatingEngine;
	};

	// The *new* standrad character property engine, which gives answers based purely on
	// Unicode (thanks to ICU).
	DeclareCoClass(LgIcuCharPropEngine, 30D75676-A10F-48FE-9627-EBF4061EA49D)
	{
		interface ILgIcuCharPropEngine;
		interface IMarshal;
	};

	DeclareCoClass(LgIcuConverterEnumerator, 9E729461-F80D-4796-BA17-086BC61907F1)
	{
		interface ILgIcuConverterEnumerator;
	};
	DeclareCoClass(LgIcuTransliteratorEnumerator, 3F1FD0A4-B2B1-4589-BC82-9CEF5BA84F4E)
	{
		interface ILgIcuTransliteratorEnumerator;
	};
	DeclareCoClass(LgIcuResourceBundle, 0DD7FC1A-AB97-4A39-882C-269760D86619)
	{
		interface ILgIcuResourceBundle;
	};
	DeclareCoClass(LgIcuLocaleEnumerator, E426656C-64F7-480E-92F4-D41A7BFFD066)
	{
		interface ILgIcuLocaleEnumerator;
	};
#endif /*!NO_COCLASSES*/
