// Copyright (c) 2010-2013 SIL International
// This software is licensed under the LGPL, version 2.1 or later
// (http://www.gnu.org/licenses/lgpl-2.1.html)
//
// File: FwKernel.cs
// Responsibility: Generated by IDLImporter
// Last reviewed:
//
// <remarks>
// Generated by IDLImporter from file FwKernelTlb.idl
//
// You should use these interfaces when you access the COM objects defined in the mentioned
// IDL/IDH file.
// </remarks>
// --------------------------------------------------------------------------------------------
namespace SIL.FieldWorks.Common.ViewsInterfaces
{
	using SIL.Utils;
	using SIL.Utils.ComTypes;
	using System;
	using System.Runtime.InteropServices;
	using System.Runtime.InteropServices.ComTypes;
	using System.Runtime.CompilerServices;
	using System.Windows.Forms;



	/// <summary>
	/// Text scalarvalued properties are composed of a prop type and a prop value and optionally
	/// a variation. The prop type determines the kind of property that is being specified and the
	/// size of the associated data. The associated data holds both the variation (if used typically in the low 4 bits of the data and containing a value from the FwTextPropVar enum)
	/// and the value. The variation specifies how the value is interpreted. For example the font
	/// size prop type might have a value of 50. But is that 50 points, 50% of the current value,
	/// or 50 what? The variation specifies which. Typical variation values. These aren't necessarily appropriate in all situations.
	/// These must fit in 4 bits. ktpvNinch should not be used for anything.
	///</summary>
	public enum FwTextPropVar
	{

		/// <summary> no variation, or whatever </summary>
		ktpvDefault = 0,

		/// <summary> 1000ths of point. </summary>
		ktpvMilliPoint = 1,

		/// <summary> Fraction of inherited value. Denominator is kdenTextPropRel. </summary>
		ktpvRelative = 2,

		/// <summary> Value taken from an enumeration. </summary>
		ktpvEnum = 3,

		/// <summary> </summary>
		ktpvNinch = 15,
	}

	/// <summary>
	/// Normalization forms. These are defined to match exactly the ICU UNormalizationMode
	/// items.
	/// Hungarian: nm.
	///</summary>
	public enum FwNormalizationMode
	{

		/// <summary> not normalized </summary>
		knmNone = 1,

		/// <summary> Most decomposed form w/o loss of information. </summary>
		knmNFD = 2,

		/// <summary> Maximal decomposition, plus substitution of very similar items. </summary>
		knmNFKD = 3,

		/// <summary> Most compressed form w/o loss of info. </summary>
		knmNFC = 4,

		/// <summary> NFC is the default for most external media (clipboard, XML) </summary>
		knmDefault = 4,

		/// <summary> Most composed, plus substitution of very similar items. </summary>
		knmNFKC = 5,

		/// <summary> ?? </summary>
		knmFCD = 6,

		/// <summary> Nonstandard modification of NFC which preserves parallel style information. </summary>
		knmNFSC = 7,

		/// <summary>
		/// NFSC is equivalent to performing NFD normalization, then performing all NFC
		/// compositions except where the characters that would be composed have different style
		/// information. (This is used in XML files that include style info.)
		///</summary>
		knmLim,
	}

	/// <summary>
	/// Text property types. These encompass both scalarvalued and stringvalued properties.
	/// Hungarian: tpt
	///
	/// ENHANCE JohnT(SteveMc): Should this be TsTextPropType with Hungarian ttpt like the old days
	/// of Cellar 2?
	///</summary>
	public enum FwTextPropType
	{

		/// <summary> Value: writing system value and old writing system value </summary>
		ktptWs = 1,

		/// <summary> Value: FwTextToggleVal enum (variation = ktpvEnum?) </summary>
		ktptItalic = 2,

		/// <summary> Value: FwTextToggleVal enum (variation = ktpvEnum?) </summary>
		ktptBold = 3,

		/// <summary> Value: FwSuperscriptVal enum (variation = ktpvEnum?) </summary>
		ktptSuperscript = 4,

		/// <summary> Value: FwUnderlineType enum (variation = ktpvEnum?) </summary>
		ktptUnderline = 5,

		/// <summary> Variation: FwTextPropVar enum </summary>
		ktptFontSize = 6,

		/// <summary> Variation: FwTextPropVar enum </summary>
		ktptOffset = 7,

		/// <summary>
		/// Value: RGB value. If the high byte is nonzero, this is a special value,
		///   eg, transparent. See the FwTextColor enum for special values.
		///</summary>
		ktptForeColor = 8,

		/// <summary>
		/// Value: RGB value. If the high byte is nonzero, this is a special value,
		///   eg, transparent. See the FwTextColor enum for special values.
		///</summary>
		ktptBackColor = 9,

		/// <summary>
		/// Value: RGB value. If the high byte is nonzero, this is a special value,
		///   eg, transparent. See the FwTextColor enum for special values.
		/// Color used for underlining.
		///</summary>
		ktptUnderColor = 10,

		/// <summary>
		/// Paragraph level properties. Some of these may occassionally be used at the character
		/// level as well.
		/// Value: writing system value and old writing system value
		///</summary>
		ktptBaseWs = 16,

		/// <summary> Value: FwTextAlign enum </summary>
		ktptAlign = 17,

		/// <summary> Variation: FwTextPropVar enum </summary>
		ktptFirstIndent = 18,

		/// <summary> Variation: FwTextPropVar enum </summary>
		ktptLeadingIndent = 19,

		/// <summary> </summary>
		ktptMarginLeading = 19,

		/// <summary> Variation: FwTextPropVar enum </summary>
		ktptTrailingIndent = 20,

		/// <summary> </summary>
		ktptMarginTrailing = 20,

		/// <summary> Variation: FwTextPropVar enum </summary>
		ktptSpaceBefore = 21,

		/// <summary> See comments on ktptMarginTop below. </summary>
		ktptMswMarginTop = 21,

		/// <summary> Variation: FwTextPropVar enum </summary>
		ktptSpaceAfter = 22,

		/// <summary> </summary>
		ktptMarginBottom = 22,

		/// <summary> Variation: FwTextPropVar enum </summary>
		ktptTabDef = 23,

		/// <summary> Variation: FwTextPropVar enum </summary>
		ktptLineHeight = 24,

		/// <summary>
		/// Value: RGB value. If the high byte is nonzero, this is a special value,
		///   eg, transparent. See the FwTextColor enum for special values.
		///</summary>
		ktptParaColor = 25,

		/// <summary> Value: member of SpellOptions enumeration </summary>
		ktptSpellCheck = 26,

		/// <summary>
		/// Variation: ktpvMilliPoint.
		/// This is an alternative version of ktptMswMarginTop, implemented to enable compatibility
		/// with CSS and Word. In Word, the separation between two paragraphs is the SUM of the bottom
		/// margin of the upper one and the top margin of the lower one. In CSS, it is the MAX.
		/// The CSS approach is much nicer for designing documents that resize well, but the Word
		/// approach is simpler for naive users.
		/// To keep both capabilities in the Views code, I've retained the CSS behavior (separation
		/// between paragraphs is the MAX of the ktptMarginBottom and ktptMarginTop settings for
		/// the relevant paragraphs), but also, the SUM of ktptMarginBottom and ktptMswMarginTop.
		/// Strictly (as it is possible for both settings to be given), the separation is
		/// max (ktptMarginBottom[t] + ktptMswMarginTop[b], ktptMarginTop[b]).
		/// In current FieldWorks paragraph dialogs, only the ktptMswMarginTop setting is used.
		/// However some view constructors use ktptMarginTop.
		/// (Note...the value is chosen to be well clear of scp constants like ktptUnderColor&gt;&gt;2|2
		///</summary>
		ktptMarginTop = 50,

		/// <summary>
		/// Stringvalued properties. These start in again at 1 since they occupy a different
		/// namespace, so to speak.
		///</summary>
		ktptFontFamily = 1,

		/// <summary> </summary>
		ktptCharStyle = 2,

		/// <summary> </summary>
		ktptParaStyle = 3,

		/// <summary> </summary>
		ktptTabList = 4,

		/// <summary> prop holds sequence of 8char items, each the memcpyequivalent of a GUID </summary>
		ktptTags = 5,

		/// <summary> prop holds data about an embedded object. </summary>
		ktptObjData = 6,

		/// <summary>
		/// (The first character indicates the nature of the data, see VwTextBoxes.cpp.) Properties that originated in the views subsystem. These are a mixture of integer and
		/// string valued properties.
		/// int, ComBool variation
		///</summary>
		ktptRightToLeft = 128,

		/// <summary> int, no variations </summary>
		ktptDirectionDepth = 129,

		/// <summary>
		/// Values to be used by old writing system to select variation of smart font.
		/// string, giving variation names specific to font.
		///</summary>
		ktptFontVariations = 130,

		/// <summary> string, replace only </summary>
		ktptNamedStyle = 133,

		/// <summary> </summary>
		ktptPadLeading = 134,

		/// <summary> </summary>
		ktptPadTrailing = 135,

		/// <summary> </summary>
		ktptPadTop = 136,

		/// <summary> </summary>
		ktptPadBottom = 137,

		/// <summary> Keep these four in this order.
		/// int, length </summary>
		ktptBorderTop = 138,

		/// <summary> int, length </summary>
		ktptBorderBottom = 139,

		/// <summary> int, length </summary>
		ktptBorderLeading = 140,

		/// <summary> int, length </summary>
		ktptBorderTrailing = 141,

		/// <summary> </summary>
		ktptBorderColor = 142,

		/// <summary> Bullets and Numbering
		/// int </summary>
		ktptBulNumScheme = 143,

		/// <summary> int, 0, 1, 2 ... </summary>
		ktptBulNumStartAt = 144,

		/// <summary> string </summary>
		ktptBulNumTxtBef = 145,

		/// <summary> string </summary>
		ktptBulNumTxtAft = 146,

		/// <summary> string </summary>
		ktptBulNumFontInfo = 147,

		/// <summary> paragraph layout
		/// int, ComBool variation </summary>
		ktptKeepWithNext = 148,

		/// <summary> int, ComBool variation. </summary>
		ktptKeepTogether = 149,

		/// <summary> int, ComBool variation, not yet supported </summary>
		ktptHyphenate = 150,

		/// <summary> int, max </summary>
		ktptMaxLines = 151,

		/// <summary> overall table layout
		/// int, length </summary>
		ktptCellBorderWidth = 152,

		/// <summary> int, length </summary>
		ktptCellSpacing = 153,

		/// <summary> int, length </summary>
		ktptCellPadding = 154,

		/// <summary> uses TptEditable enum </summary>
		ktptEditable = 155,

		/// <summary> String, binary info about wsdependent char styles </summary>
		ktptWsStyle = 156,

		/// <summary>
		/// trick values used for special purposes
		/// ComBool, absolute: applying one with this sets table defs.
		///</summary>
		ktptSetRowDefaults = 159,

		/// <summary>
		/// If line height is set to relative, then reading line height from the prop store
		/// yields 0, and this fake property (which can't be set directly) can be used to
		/// read the relative line height, as 10000ths.
		///</summary>
		ktptRelLineHeight = 160,

		/// <summary> int, enum, a VwRule </summary>
		ktptTableRule = 161,

		/// <summary> paragraph layout
		/// int, ComBool variation </summary>
		ktptWidowOrphanControl = 162,

		/// <summary> Fake string valued text property used for exporting from FieldWorks apps. </summary>
		ktptFieldName = 9998,

		/// <summary>
		/// Fake integer valued text property used for exporting list items in a string.
		/// Value: FwTextToggleVal enum (variation = ktpvEnum?)
		///</summary>
		ktptMarkItem = 9999,
	}

	/// <summary>
	/// This enumeration idetifies the types of editable fields.
	/// It is used in the ktptEditable Text Property.
	///</summary>
	public enum TptEditable
	{

		/// <summary> </summary>
		ktptNotEditable = 0,

		/// <summary> </summary>
		ktptIsEditable,

		/// <summary> Used in type ahead edit boxs. </summary>
		ktptSemiEditable,
	}

	/// <summary>
	/// This enumeration idetifies the ways a range of text can be spellchecked.
	/// It is used in the ktptSpellCheck Text Property.
	/// Enhance JohnT: may want other options, such as one applied to text in individual strings
	/// that should not be further checked until edited, or one that excludes words in all caps
	/// or MixedCaseIndentifiers, or one that causes text to be checked even though readonly.
	///</summary>
	public enum SpellingModes
	{

		/// <summary> </summary>
		ksmMin = 0,

		/// <summary> check normally, the default (readonly text is not checked) </summary>
		ksmNormalCheck = 0,

		/// <summary> do not check at all </summary>
		ksmDoNotCheck,

		/// <summary> Check even if readonly. </summary>
		ksmForceCheck,

		/// <summary> </summary>
		ksmLim,
	}

	/// <summary>
	///This enumeration specifies the subtypes of data that may be associated with embedded object
	///characters (ORC, 0xfffc) using the property ktptObjData.
	///Explicit numbers are listed for every item as a reminder that these values occur embedded
	///in strings in existing data, and MUST not be changed (unless you implement a very tricky
	///bit of data migration).
	///</summary>
	public enum FwObjDataTypes
	{

		/// <summary>
		/// Next 8 characters give the GUID of a CmObject. Remaining bytes contain picture data
		/// suitable for OleLoadPicture. The picture will be hot: when clicked, the system calls
		/// DoHotLinkAction on the view constructor that inserted the picture.
		/// even number of picture bytes
		///</summary>
		kodtPictEvenHot = 1,

		/// <summary> odd number of picture bytes </summary>
		kodtPictOddHot = 2,

		/// <summary>
		/// Next 8 characters give the GUID of a CmObject. A string obtained from this object
		/// using GetStrForGuid (typically its name in the first analysis writing system) is displayed.
		/// The string will be hot: when clicked, the system calls DoHotLinkAction on the view
		/// constructor that inserted the string containing the hot object.
		/// (Note: if this property is associated with a character other than 0xfffc, the character
		/// is displayed normally, but the hot link behavior still happens when clicked.)
		/// (Note 2: the 8 characters are those obtained by doing memcopy on a Windows machine
		/// from a standard GUID data structure.)
		///</summary>
		kodtNameGuidHot = 3,

		/// <summary>
		/// The following characters could either be a relative path (based on
		/// LangProject:ExtLinkRootDir) or an absolute path. The string will be hot: when
		/// clicked, the system reconstructs the absolute path if necessary, then calls
		/// ShellExecute to launch the file with the default program used for that file extension.
		///</summary>
		kodtExternalPathName = 4,

		/// <summary>
		/// This one is like kodtNameGuidHot (see above), but using it implies that the object
		/// linked to is conceptually 'owned' by the string. For example, it ought to be deleted
		/// if the link character is deleted, and a copy of the object ought to be made if the
		/// link character is copied.
		/// (Note: the enumeration would be neater with this one adjacent to kodtNameGuidHot, but
		/// existing values are in use in databases and would be tedious to migrate.)
		///</summary>
		kodtOwnNameGuidHot = 5,

		/// <summary>
		/// This one is used ONLY in the clipboard...code won't know what to do with it elsewhere.
		/// It signifies something that should be kodtOwnNameGuidHot or kodtGuidMoveableObjDisp,
		/// but in the clipboard we store a representation of the object (made using
		/// IVwRootSite::TextRepOfObj) as the balance of the property. Pasting
		/// (IVwSelection::ReplaceWithTsString) calls IVwRootSite::MakeObjFromText to get a real
		/// guid and the proper type of FwObjDataTypes to be used for the pasted object.
		///</summary>
		kodtEmbeddedObjectData = 6,

		/// <summary>
		/// This is a generated contextsensitive string. It is not a hot link. The next 8 characters
		/// give a GUID, which can be compared to a known set of GUIDs that have special meaning to
		/// a view contructor. This class of embedded object is being created to support special
		/// elements in page headers/footers, but there may eventually be other uses for them as well.
		/// Here is a list of global GUIDs; specific applications may have additional ones:
		///
		/// First Reference on Page: 397F43AEE2B24f20928A1DF193C07674
		/// Last Reference on Page: 85EE15C6079946c68769F9B3CE313AE2
		/// Page Number: 644DF48A3B6045f480C7739BE6E56A96
		/// Total Page Count: E0EF9EDAE4E24fcf87205BC361BCE110
		/// Print Date: C4556A2141A84675A74D59B2C1A7E2B8
		/// Division Name: 2277B85F47BB45c9BC7A7232E26E901C
		/// Publication Title: C8136D98695743bdBEA97DCE35200900
		/// Page Reference: 8978089A8969424eAE54B94C554F882D
		///</summary>
		kodtContextString = 7,

		/// <summary>
		/// This results in a callback to the VC, with a new VwEnv, to create any display it
		/// wants of the object specified by the Guid (see IVwViewConstructor.DisplayEmbeddedObject).
		/// The display will typically occur immediately following the paragraph line that contains
		/// the ORC, which functions as an anchor, but may be moved down past following text to
		/// improve page breaking. Like kodtOwnNameGuidHot, this type of object is conceptually
		/// 'owned' by the string. So it ought to be deleted if the link character is
		/// deleted, and a copy of the object ought to be made if the link character is copied.
		///</summary>
		kodtGuidMoveableObjDisp = 8,
	}

	/// <summary>
	/// Text scalarvalued properties. The low 2 bits of these values encode the base2 log of the
	/// size of the associated data (2^n bytes).
	///
	/// The data may (depending on the scp) encode different "variations". If so, typically the
	/// low 4 bits of the data will contain a value in the TextPropVar enumeration.
	///
	/// It's OK to add new values to this enum, but don't change existing values. Doing so
	/// invalidates existing persistent data.
	///
	/// Hungarian: scp
	///</summary>
	public enum FwTextScalarProp
	{

		/// <summary> Character level properties.
		/// Data: int
		/// Value: writing system value </summary>
		kscpWs = ((FwTextPropType.ktptWs)<<2)|2,

		/// <summary> Data: 2 ints
		/// Value: writing system value and old writing system value </summary>
		kscpWsAndOws = ((FwTextPropType.ktptWs)<<2)|3,

		/// <summary> Data: byte
		/// Value: FwTextToggleVal enum (variation = ktpvEnum?) </summary>
		kscpItalic = ((FwTextPropType.ktptItalic)<<2)|0,

		/// <summary> Data: byte
		/// Value: FwTextToggleVal enum (variation = ktpvEnum?) </summary>
		kscpBold = ((FwTextPropType.ktptBold)<<2)|0,

		/// <summary> Data: byte
		/// Value: FwSuperscriptVal enum (variation = ktpvEnum?) </summary>
		kscpSuperscript = ((FwTextPropType.ktptSuperscript)<<2)|0,

		/// <summary> Data: byte
		/// Value: FwUnderlineType enum (variation = ktpvEnum?) </summary>
		kscpUnderline = ((FwTextPropType.ktptUnderline)<<2)|0,

		/// <summary> Data: int
		/// Variation (4 bits): FwTextPropVar enum </summary>
		kscpFontSize = ((FwTextPropType.ktptFontSize)<<2)|2,

		/// <summary> Data: int
		/// Variation (4 bits): FwTextPropVar enum </summary>
		kscpOffset = ((FwTextPropType.ktptOffset)<<2)|2,

		/// <summary>
		/// Data: int
		/// Value: RGB value. If the high byte is nonzero, this is a special value,
		///   eg, transparent. See the FwTextColor enum for special values.
		///</summary>
		kscpForeColor = ((FwTextPropType.ktptForeColor)<<2)|2,

		/// <summary>
		/// Data: int
		/// Value: RGB value. If the high byte is nonzero, this is a special value,
		///   eg, transparent. See the FwTextColor enum for special values.
		///</summary>
		kscpBackColor = ((FwTextPropType.ktptBackColor)<<2)|2,

		/// <summary>
		/// Data: int
		/// Value: RGB value. If the high byte is nonzero, this is a special value,
		///   eg, transparent. See the FwTextColor enum for special values.
		///</summary>
		kscpUnderColor = ((FwTextPropType.ktptUnderColor)<<2)|2,

		/// <summary> Data: byte
		/// Value: FwSpellingMode enum (variation = ktpvEnum) </summary>
		kscpSpellCheck = ((FwTextPropType.ktptSpellCheck)<<2)|0,

		/// <summary>
		/// Paragraph level properties. Some of these may occassionally be used at the character
		/// level as well.
		/// Data: int
		/// Value: writing system value
		///</summary>
		kscpBaseWs = ((FwTextPropType.ktptBaseWs)<<2)|2,

		/// <summary> Data: 2 ints
		/// Value: writing system value and old writing system value </summary>
		kscpBaseWsAndOws = ((FwTextPropType.ktptBaseWs)<<2)|3,

		/// <summary> Data: byte
		/// Value: FwTextAlign enum </summary>
		kscpAlign = ((FwTextPropType.ktptAlign)<<2)|0,

		/// <summary> Data: int
		/// Variation (4 bits): FwTextPropVar enum </summary>
		kscpFirstIndent = ((FwTextPropType.ktptFirstIndent)<<2)|2,

		/// <summary> Data: int
		/// Variation (4 bits): FwTextPropVar enum </summary>
		kscpLeadingIndent = ((FwTextPropType.ktptLeadingIndent)<<2)|2,

		/// <summary> Data: int
		/// Variation (4 bits): FwTextPropVar enum </summary>
		kscpTrailingIndent = ((FwTextPropType.ktptTrailingIndent)<<2)|2,

		/// <summary> Data: int
		/// Variation (4 bits): FwTextPropVar enum </summary>
		kscpSpaceBefore = ((FwTextPropType.ktptSpaceBefore)<<2)|2,

		/// <summary> Data: int
		/// Variation (4 bits): FwTextPropVar enum </summary>
		kscpSpaceAfter = ((FwTextPropType.ktptSpaceAfter)<<2)|2,

		/// <summary> Data: int
		/// Variation (4 bits): FwTextPropVar enum </summary>
		kscpTabDef = ((FwTextPropType.ktptTabDef)<<2)|2,

		/// <summary> Data: int
		/// Variation (4 bits): FwTextPropVar enum </summary>
		kscpLineHeight = ((FwTextPropType.ktptLineHeight)<<2)|2,

		/// <summary>
		/// Data: int
		/// Value: RGB value. If the high byte is nonzero, this is a special value,
		///   eg, transparent. See the FwTextColor enum for special values.
		///</summary>
		kscpParaColor = ((FwTextPropType.ktptParaColor)<<2)|2,

		/// <summary> Data: byte
		/// Value: ComBool </summary>
		kscpKeepWithNext = ((FwTextPropType.ktptKeepWithNext)<<2)|0,

		/// <summary> Data: byte
		/// Value: ComBool </summary>
		kscpKeepTogether = ((FwTextPropType.ktptKeepTogether)<<2)|0,

		/// <summary> Data: byte
		/// Value: ComBool </summary>
		kscpWidowOrphanControl = ((FwTextPropType.ktptWidowOrphanControl)<<2)|0,

		/// <summary>
		/// Fake integer valued text property used for exporting list items in a string.
		/// Value: FwTextToggleVal enum (variation = ktpvEnum?)
		///</summary>
		kscpMarkItem = ((FwTextPropType.ktptMarkItem)<<2)|0,
	}

	/// <summary> String valued properties. </summary>
	public enum FwTextStringProp
	{

		/// <summary> </summary>
		kstpFontFamily = FwTextPropType.ktptFontFamily,

		/// <summary> </summary>
		kstpCharStyle = FwTextPropType.ktptCharStyle,

		/// <summary> </summary>
		kstpParaStyle = FwTextPropType.ktptParaStyle,

		/// <summary> </summary>
		kstpTabList = FwTextPropType.ktptTabList,

		/// <summary> </summary>
		kstpTags = FwTextPropType.ktptTags,

		/// <summary> </summary>
		kstpObjData = FwTextPropType.ktptObjData,

		/// <summary> </summary>
		kstpFontVariations = FwTextPropType.ktptFontVariations,

		/// <summary> </summary>
		kstpNamedStyle = FwTextPropType.ktptNamedStyle,

		/// <summary> </summary>
		kstpBulNumTxtBef = FwTextPropType.ktptBulNumTxtBef,

		/// <summary> </summary>
		kstpBulNumTxtAft = FwTextPropType.ktptBulNumTxtAft,

		/// <summary> </summary>
		kstpBulNumFontInfo = FwTextPropType.ktptBulNumFontInfo,

		/// <summary> </summary>
		kstpWsStyle = FwTextPropType.ktptWsStyle,

		/// <summary> Fake string valued text property used for exporting. </summary>
		kstpFieldName = FwTextPropType.ktptFieldName,
	}

	/// <summary> General text property constants. </summary>
	public enum FwTextPropConstants
	{

		/// <summary> Typical denominator for values specified with the ktpvRelative variation. </summary>
		kdenTextPropRel = 10000,

		/// <summary> Number of low bits used for the variation. </summary>
		kcbitTextPropVar = 4,

		/// <summary>
		/// Widely used for "no input no change", that is, some property is not specified.
		/// The value should not be a valid RGB color, nor a likely value for any other property.
		///</summary>
		knNinch = -2147483648,

		/// <summary>
		/// Similar value, indicating that a property has conflicting values on differnt runs.
		///</summary>
		knConflicting = -2147483647,
	}

	/// <summary>
	/// This enumeration provides the possible values for italic, bold, etc.
	/// Hungarian: ttv
	///</summary>
	public enum FwTextToggleVal
	{

		/// <summary> </summary>
		kttvOff = 0,

		/// <summary> </summary>
		kttvForceOn = 1,

		/// <summary> </summary>
		kttvInvert = 2,
	}

	/// <summary> This enumeration provides the possible values for superscript.
	/// Hungarian: ssv </summary>
	public enum FwSuperscriptVal
	{

		/// <summary> </summary>
		kssvOff = 0,

		/// <summary> </summary>
		kssvSuper = 1,

		/// <summary> </summary>
		kssvSub = 2,
	}

	/// <summary>
	/// Provides some of the possible values for kscpFontColor and kscpBackColor.
	/// Hungarian: clr
	///</summary>
	public enum FwTextColor
	{

		/// <summary> </summary>
		kclrWhite = 16777215,

		/// <summary> </summary>
		kclrBlack = 0,

		/// <summary> </summary>
		kclrRed = 255,

		/// <summary> </summary>
		kclrGreen = 65280,

		/// <summary> </summary>
		kclrBlue = 16711680,

		/// <summary> </summary>
		kclrYellow = 65535,

		/// <summary> </summary>
		kclrMagenta = 16711935,

		/// <summary> </summary>
		kclrCyan = 16776960,

		/// <summary> Special values. </summary>
		kclrTransparent = -1073741824,
	}

	/// <summary>
	/// Possible values for kscpUnderline.
	/// Keep these "in order" so that the max of two unt values is the stronger form of underline.
	/// ENHANCE JohnT: this requirement may conflict with not changing the assignments once we have
	/// data...
	///</summary>
	public enum FwUnderlineType
	{

		/// <summary> </summary>
		kuntMin,

		/// <summary> </summary>
		kuntNone = kuntMin,

		/// <summary> </summary>
		kuntDotted,

		/// <summary> </summary>
		kuntDashed,

		/// <summary> </summary>
		kuntSingle,

		/// <summary> </summary>
		kuntDouble,

		/// <summary> </summary>
		kuntStrikethrough,

		/// <summary>
		/// ENHANCE JohnT: should we have a distinctly separate range for things like squiggle
		/// that don't go in a user menu?
		/// squiggle underline for spelling errors
		///</summary>
		kuntSquiggle,

		/// <summary> keep this the last one </summary>
		kuntLim,
	}

	/// <summary> Possible values for kscpAlign. </summary>
	public enum FwTextAlign
	{

		/// <summary> </summary>
		ktalMin,

		/// <summary> </summary>
		ktalLeading = ktalMin,

		/// <summary> </summary>
		ktalLeft,

		/// <summary> </summary>
		ktalCenter,

		/// <summary> </summary>
		ktalRight,

		/// <summary> </summary>
		ktalTrailing,

		/// <summary> </summary>
		ktalJustify,

		/// <summary> </summary>
		ktalLim,
	}

	/// <summary> Information for a run in a string. </summary>
	[StructLayout(LayoutKind.Sequential, Pack=4)]
	public struct TsRunInfo
	{

		/// <summary> </summary>
		public int ichMin;

		/// <summary> </summary>
		public int ichLim;

		/// <summary> The index of this run, zero based. </summary>
		public int irun;
	}

	/// <summary>
	/// TsString objects hold one or more runs of text. Each run has associated with it a
	/// TsTextProps object. Adjacent runs of text must have different TsTextProps objects.
	/// An empty string has a single empty run with an empty TsTextProps object. Nonempty
	/// strings have nonempty runs. TsString objects are immutable. TsString objects are
	/// created from instances of TsStrFactory, TsStrBldr and TsIncStrBldr.
	/// Hungarian: tss
	///</summary>
	[ComImport()]
	[InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]
	[Guid("295B2E11-B149-49C5-9BE9-9F46185609AA")]
	public interface ITsString
	{

		/// <summary> Fetch the raw text. </summary>
		/// <returns>A System.String </returns>
		string Text
		{
			[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
			[return: MarshalAs(UnmanagedType.BStr)]
			get;
		}

		/// <summary> Fetch the length in characters of the text. </summary>
		/// <returns>A System.Int32 </returns>
		int Length
		{
			[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
			get;
		}

		/// <summary> Fetch the number of runs. </summary>
		/// <returns>A System.Int32 </returns>
		int RunCount
		{
			[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
			get;
		}

		/// <summary>
		/// Mapping between character indexes and run indexes.
		/// Fetch the run index for a particular character position.
		/// ich may be equal to the length of the string which is one more than the last valid
		/// character index, in which case, the last run will be used.
		///</summary>
		/// <param name='ich'> </param>
		/// <returns></returns>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		int get_RunAt(int ich);

		/// <summary> Fetch the character position of the first character in a particular run. </summary>
		/// <param name='irun'> </param>
		/// <returns></returns>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		int get_MinOfRun(int irun);

		/// <summary> Fetch the character position one past the last character in a particular run. </summary>
		/// <param name='irun'> </param>
		/// <returns></returns>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		int get_LimOfRun(int irun);

		/// <summary> Fetch both Min and Lim of a run. </summary>
		/// <param name='irun'> </param>
		/// <param name='_ichMin'> </param>
		/// <param name='_ichLim'> </param>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void GetBoundsOfRun(int irun, out int _ichMin, out int _ichLim);

		/// <summary>
		/// Run information.
		/// Fetch the run information at a given character position. ich must be a valid character
		/// postion.
		///</summary>
		/// <param name='ich'> </param>
		/// <param name='_tri'> </param>
		/// <returns></returns>
		[return: MarshalAs(UnmanagedType.Interface)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		ITsTextProps FetchRunInfoAt(int ich, out TsRunInfo _tri);

		/// <summary> Fetch the run information for a particular run. irun must be a valid run index. </summary>
		/// <param name='irun'> </param>
		/// <param name='_tri'> </param>
		/// <returns></returns>
		[return: MarshalAs(UnmanagedType.Interface)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		ITsTextProps FetchRunInfo(int irun, out TsRunInfo _tri);

		/// <summary>
		/// Fetching characters.
		/// Fetch the text for a particular run. irun must be a valid run index.
		///</summary>
		/// <param name='irun'> </param>
		/// <returns></returns>
		[return: MarshalAs(UnmanagedType.BStr)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		string get_RunText(int irun);

		/// <summary> Fetch the characters from ichMin to ichLim. Return the string as a BSTR. </summary>
		/// <param name='ichMin'> </param>
		/// <param name='ichLim'> </param>
		/// <returns></returns>
		[return: MarshalAs(UnmanagedType.BStr)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		string GetChars(int ichMin, int ichLim);

		/// <summary>
		/// Fetch characters into a caller supplied buffer from ichMin to ichLim. Return the string
		/// as a OLECHAR
		///</summary>
		/// <param name='ichMin'> </param>
		/// <param name='ichLim'> </param>
		/// <param name='_rgch'> </param>
		[Obsolete("Can\'t call COM method marked with [local] attribute in IDL file")]
		[TypeLibFunc(TypeLibFuncFlags.FRestricted)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void FetchChars(int ichMin, int ichLim, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef=typeof(ArrayPtrMarshaler))] ArrayPtr/*OLECHAR[]*/ _rgch);

		/// <summary>
		/// Locking text. These routines provide fast access to the raw characters of the TsString.
		/// The use of local prevents marshalling.
		/// Fetches a pointer to the raw characters and the number of characters.
		///</summary>
		/// <param name='_prgch'> </param>
		/// <param name='_cch'> </param>
		[Obsolete("Can\'t call COM method marked with [local] attribute in IDL file")]
		[TypeLibFunc(TypeLibFuncFlags.FRestricted)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void LockText(out string _prgch, out int _cch);

		/// <summary> Balances calls to LockText. </summary>
		/// <param name='_rgch'> </param>
		[Obsolete("Can\'t call COM method marked with [local] attribute in IDL file")]
		[TypeLibFunc(TypeLibFuncFlags.FRestricted)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void UnlockText(string _rgch);

		/// <summary> Fetches a constant pointer to the raw characters of a particular run. </summary>
		/// <param name='irun'> </param>
		/// <param name='_prgch'> </param>
		/// <param name='_cch'> </param>
		[Obsolete("Can\'t call COM method marked with [local] attribute in IDL file")]
		[TypeLibFunc(TypeLibFuncFlags.FRestricted)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void LockRun(int irun, out string _prgch, out int _cch);

		/// <summary> Balances calls to LockRun. </summary>
		/// <param name='irun'> </param>
		/// <param name='_rgch'> </param>
		[Obsolete("Can\'t call COM method marked with [local] attribute in IDL file")]
		[TypeLibFunc(TypeLibFuncFlags.FRestricted)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void UnlockRun(int irun, string _rgch);

		/// <summary>
		/// Getting properties.
		/// Fetch the run properties at a particular character position.
		///</summary>
		/// <param name='ich'> </param>
		/// <returns></returns>
		[return: MarshalAs(UnmanagedType.Interface)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		ITsTextProps get_PropertiesAt(int ich);

		/// <summary> Fetch the properties of a particular run. </summary>
		/// <param name='irun'> </param>
		/// <returns></returns>
		[return: MarshalAs(UnmanagedType.Interface)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		ITsTextProps get_Properties(int irun);

		/// <summary>
		/// Builders.
		/// Fetches a string builder. The builder allows a copy of the string to be modified using
		/// a series of replace operations. There is no connection between the builder and the
		/// string. Data is copied to the builder.
		///</summary>
		/// <returns></returns>
		[return: MarshalAs(UnmanagedType.Interface)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		ITsStrBldr GetBldr();

		/// <summary>
		/// Fetches an incremental string builder. The builder allows a copy of the string to be
		/// modified using a series of append operations. There is no connection between the builder
		/// and the string. Data is copied to the builder.
		///</summary>
		/// <returns></returns>
		[return: MarshalAs(UnmanagedType.Interface)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		ITsIncStrBldr GetIncBldr();

		/// <summary> Serialization. </summary>
		/// <returns></returns>
		System.Guid GetFactoryClsid();

		/// <summary> </summary>
		/// <param name='_strm'> </param>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void SerializeFmt(System.Runtime.InteropServices.ComTypes.IStream _strm);

		/// <summary> </summary>
		/// <param name='_rgb'> </param>
		/// <param name='cbMax'> </param>
		/// <returns></returns>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		int SerializeFmtRgb([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef=typeof(ArrayPtrMarshaler))] ArrayPtr/*BYTE[]*/ _rgb, int cbMax);

		/// <summary> Equality </summary>
		/// <param name='_tss'> </param>
		/// <returns></returns>
		[return: MarshalAs(UnmanagedType.VariantBool)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		bool Equals([MarshalAs(UnmanagedType.Interface)] ITsString _tss);

		/// <summary>
		/// Write the string to the stream in standard FieldWorks XML format. Indent the
		/// number of spaces given by cchIndent, which may be zero.
		///</summary>
		/// <param name='_strm'> </param>
		/// <param name='_wsf'> </param>
		/// <param name='cchIndent'> </param>
		/// <param name='ws'> </param>
		/// <param name='fWriteObjData'> </param>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void WriteAsXml(System.Runtime.InteropServices.ComTypes.IStream _strm, [MarshalAs(UnmanagedType.Interface)] ILgWritingSystemFactory _wsf, int cchIndent, int ws, [MarshalAs(UnmanagedType.VariantBool)] bool fWriteObjData);

		/// <summary>
		/// Return a string in standard FieldWorks XML format. Indent the
		/// number of spaces given by cchIndent, which may be zero.
		///</summary>
		/// <param name='_wsf'> </param>
		/// <param name='cchIndent'> </param>
		/// <param name='ws'> </param>
		/// <param name='fWriteObjData'> </param>
		/// <returns></returns>
		[return: MarshalAs(UnmanagedType.BStr)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		string GetXmlString([MarshalAs(UnmanagedType.Interface)] ILgWritingSystemFactory _wsf, int cchIndent, int ws, [MarshalAs(UnmanagedType.VariantBool)] bool fWriteObjData);

		/// <summary>
		/// Return whether the string is already in the specified normal form.
		/// Note that a string may be considered to be in NFC
		/// even though its text (the plain character sequence) is not.
		/// This is because we don't collapse otherwise collapsible pairs if they
		/// have different style properties.
		///</summary>
		/// <param name='nm'> </param>
		/// <returns></returns>
		[return: MarshalAs(UnmanagedType.VariantBool)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		bool get_IsNormalizedForm(FwNormalizationMode nm);

		/// <summary>
		/// Return an equivalent string in the specified normal form.
		/// This may be the same object as the recipient, if it is already in
		/// that normal form.
		/// Note that TsStrings normalized to NFC may not have text
		/// (the sequence of plain characters) that is so normalized.
		/// This is because we don't collapse otherwise collapsible pairs if they
		/// have different style properties.
		///</summary>
		/// <param name='nm'> </param>
		/// <returns></returns>
		[return: MarshalAs(UnmanagedType.Interface)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		ITsString get_NormalizedForm(FwNormalizationMode nm);

		/// <summary>
		/// Return an equivalent string in NFD.
		/// This may be the same object as the recipient, if it is already in
		/// that normal form.
		///
		/// The values pointed to by the array of pointers to offsets to fix are each offsets into
		/// the string. The code attempts to adjust them to corresponding offsets in the output
		/// string. An exact correspondence is not always achieved; if the offset is in the middle
		/// of a diacritic sequence, it may be moved to the start of the following base character
		/// (or the end of the string).
		///</summary>
		/// <param name='_ptssRet'> </param>
		/// <param name='_rgpichOffsetsToFix'> indirectly in/out </param>
		/// <param name='cichOffsetsToFix'> </param>
		[Obsolete("Can\'t call COM method marked with [local] attribute in IDL file")]
		[TypeLibFunc(TypeLibFuncFlags.FRestricted)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void NfdAndFixOffsets([MarshalAs(UnmanagedType.Interface)] out ITsString _ptssRet, [MarshalAs(UnmanagedType.LPArray, SizeParamIndex=2)] int[] _rgpichOffsetsToFix, int cichOffsetsToFix);

		/// <summary> Fetch the string from ichMin to ichLim. Return the string as a ITsString. </summary>
		/// <param name='ichMin'> </param>
		/// <param name='ichLim'> </param>
		/// <returns></returns>
		[return: MarshalAs(UnmanagedType.Interface)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		ITsString GetSubstring(int ichMin, int ichLim);

		/// <summary>
		/// Write the string to the stream in standard FieldWorks XML format. Indent the
		/// number of spaces given by cchIndent, which may be zero.
		///</summary>
		/// <param name='_strm'> </param>
		/// <param name='_wsf'> </param>
		/// <param name='cchIndent'> </param>
		/// <param name='ws'> </param>
		/// <param name='fWriteObjData'> </param>
		/// <param name='fUseRFC4646'> </param>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void WriteAsXmlExtended(System.Runtime.InteropServices.ComTypes.IStream _strm, [MarshalAs(UnmanagedType.Interface)] ILgWritingSystemFactory _wsf, int cchIndent, int ws, [MarshalAs(UnmanagedType.VariantBool)] bool fWriteObjData, [MarshalAs(UnmanagedType.VariantBool)] bool fUseRFC4646);

		/// <summary>
		/// Optimizations/shortcuts (there are other ways to do these things, but they are highfrequency
		/// and having these shortcuts minimizes round trips to unmanaged code).
		/// Shortcut to get the indicated string property for the indicated run.
		///</summary>
		/// <param name='iRun'> </param>
		/// <param name='tpt'> </param>
		/// <returns></returns>
		[return: MarshalAs(UnmanagedType.BStr)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		string get_StringProperty(int iRun, int tpt);

		/// <summary>
		/// Shortcut to get the indicated string property for the indicated character position.
		///</summary>
		/// <param name='ich'> </param>
		/// <param name='tpt'> </param>
		/// <returns></returns>
		[return: MarshalAs(UnmanagedType.BStr)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		string get_StringPropertyAt(int ich, int tpt);

		/// <summary> Shortcut to get WS at given run </summary>
		/// <param name='irun'> </param>
		/// <returns></returns>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		int get_WritingSystem(int irun);

		/// <summary> Shortcut to get WS at given ich </summary>
		/// <param name='ich'> </param>
		/// <returns></returns>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		int get_WritingSystemAt(int ich);

		/// <summary> Shortcut to determine whether a run is an ORC </summary>
		/// <param name='iRun'> </param>
		/// <returns></returns>
		[return: MarshalAs(UnmanagedType.VariantBool)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		bool get_IsRunOrc(int iRun);
	}

	/// <summary>
	/// ITsTextProps contains lists of Integer and String properties. See the enumerations
	/// described above for the Integer and String property values. No two successive runs will
	/// have the same text properties. ITsTextProps are immutable. A copy may be modified by
	/// obtaining a builder object with a call to GetBldr.
	/// Hungarian: ttp
	///</summary>
	[ComImport()]
	[InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]
	[Guid("4FA0B99A-5A56-41A4-BE8B-B89BC62251A5")]
	public interface ITsTextProps
	{

		/// <summary> Fetch the number of integer properties. </summary>
		/// <returns>A System.Int32 </returns>
		int IntPropCount
		{
			[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
			get;
		}

		/// <summary>
		/// Fetch the integer property at a particular index. The variation is not always meaningful,
		/// but should be set to ktpvDefault when that is the case.
		///</summary>
		/// <param name='iv'> </param>
		/// <param name='_tpt'> </param>
		/// <param name='_nVar'> </param>
		/// <returns></returns>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		int GetIntProp(int iv, out int _tpt, out int _nVar);

		/// <summary>
		/// Fetch the variation and value of an integer property. If an invalid tpt value is
		/// passed, GetIntPropValues will return S_FALSE and pnVar and pnVal are set to 1.
		///</summary>
		/// <param name='tpt'> </param>
		/// <param name='_nVar'> </param>
		/// <returns></returns>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		int GetIntPropValues(int tpt, out int _nVar);

		/// <summary> Fetch the number of string properties. </summary>
		/// <returns>A System.Int32 </returns>
		int StrPropCount
		{
			[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
			get;
		}

		/// <summary> Fetch the string property at a particular index. </summary>
		/// <param name='iv'> </param>
		/// <param name='_tpt'> </param>
		/// <returns></returns>
		[return: MarshalAs(UnmanagedType.BStr)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		string GetStrProp(int iv, out int _tpt);

		/// <summary>
		/// Fetch the value of a string property. If an invalid tpt value is passed,
		/// GetStrPropValue will return S_FALSE and and pbstrVal is set to NULL.
		///</summary>
		/// <param name='tpt'> </param>
		/// <returns></returns>
		[return: MarshalAs(UnmanagedType.BStr)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		string GetStrPropValue(int tpt);

		/// <summary>
		/// Creates a builder object from the text property object. The builder contains a copy of
		/// the text properties object's internal data which can be modified through the methods
		/// provided by the builder. (Note that this modifies a copy of the data, not the original
		/// TsTextProps.)
		///</summary>
		/// <returns></returns>
		[return: MarshalAs(UnmanagedType.Interface)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		ITsPropsBldr GetBldr();

		/// <summary> Serialization. </summary>
		/// <returns></returns>
		System.Guid GetFactoryClsid();

		/// <summary> </summary>
		/// <param name='_strm'> </param>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void Serialize(System.Runtime.InteropServices.ComTypes.IStream _strm);

		/// <summary>
		/// If cbMax is not large enough, S_FALSE is returned and pcb is set to the required size.
		///</summary>
		/// <param name='_rgb'> </param>
		/// <param name='cbMax'> </param>
		/// <returns></returns>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		int SerializeRgb([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef=typeof(ArrayPtrMarshaler))] ArrayPtr/*BYTE[]*/ _rgb, int cbMax);

		/// <summary>
		/// Serialize a set of text property objects as would be needed for a string object in
		/// the database. It is assumed that for any runs for which we want to use duplicated property
		/// information, the ITsTextProps themselves are redundant in rgpttp.
		///</summary>
		/// <param name='cpttp'> </param>
		/// <param name='rgpttp'> </param>
		/// <param name='rgich'> </param>
		/// <param name='_rgb'> </param>
		/// <param name='cbMax'> </param>
		/// <returns></returns>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		int SerializeRgPropsRgb(int cpttp, [MarshalAs(UnmanagedType.Interface)] ITsTextProps rgpttp, int rgich, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef=typeof(ArrayPtrMarshaler))] ArrayPtr/*BYTE[]*/ _rgb, int cbMax);

		/// <summary>
		/// Write the text properties to the stream in standard FieldWorks XML format. Indent the
		/// number of spaces given by cchIndent, which may be zero.
		/// Note that this is for standalone text property objects, not for those embedded inside
		/// strings: those are handled by the ITsString method itself.
		///</summary>
		/// <param name='_strm'> </param>
		/// <param name='_wsf'> </param>
		/// <param name='cchIndent'> </param>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void WriteAsXml(System.Runtime.InteropServices.ComTypes.IStream _strm, [MarshalAs(UnmanagedType.Interface)] ILgWritingSystemFactory _wsf, int cchIndent);
	}

	/// <summary>
	/// The main purpose of ITsStrFactory is to provide the Deserialize method to the persistence
	/// mechanism. It also provides a mechanism to get simple TsStrings and empty builders. Since
	/// TsString objects are imutable, the method to retrieve one from a persistant store must be
	/// provided by the factory.
	/// Hungarian: tsf
	///</summary>
	[ComImport()]
	[InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]
	[Guid("C10EA417-8317-4048-AC90-103F8BDFB325")]
	public interface ITsStrFactory
	{

		/// <summary> </summary>
		/// <param name='_strmTxt'> </param>
		/// <param name='_strmFmt'> </param>
		/// <returns></returns>
		[return: MarshalAs(UnmanagedType.Interface)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		ITsString DeserializeStringStreams(System.Runtime.InteropServices.ComTypes.IStream _strmTxt, System.Runtime.InteropServices.ComTypes.IStream _strmFmt);

		/// <summary> </summary>
		/// <param name='bstrTxt'> </param>
		/// <param name='_strmFmt'> </param>
		/// <returns></returns>
		[return: MarshalAs(UnmanagedType.Interface)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		ITsString DeserializeString([MarshalAs(UnmanagedType.BStr)] string bstrTxt, System.Runtime.InteropServices.ComTypes.IStream _strmFmt);

		/// <summary> </summary>
		/// <param name='bstrTxt'> </param>
		/// <param name='_rgbFmt'> </param>
		/// <param name='cbFmt'> </param>
		/// <returns></returns>
		[return: MarshalAs(UnmanagedType.Interface)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		ITsString DeserializeStringRgb([MarshalAs(UnmanagedType.BStr)] string bstrTxt, [MarshalAs(UnmanagedType.LPArray, SizeParamIndex=2)] byte[] _rgbFmt, int cbFmt);

		/// <summary> </summary>
		/// <param name='_rgchTxt'> </param>
		/// <param name='_cchTxt'> </param>
		/// <param name='_rgbFmt'> </param>
		/// <param name='_cbFmt'> </param>
		/// <returns></returns>
		[return: MarshalAs(UnmanagedType.Interface)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		ITsString DeserializeStringRgch([MarshalAs(UnmanagedType.LPWStr)] string _rgchTxt, ref int _cchTxt, [MarshalAs(UnmanagedType.LPArray, SizeParamIndex=3)] byte[] _rgbFmt, ref int _cbFmt);

		/// <summary>
		/// Creates a simple ITsString from the BSTR with writing system. The default old writing
		/// system is assumed for this string. If ws is zero, the ws/ows stack is empty. If the string
		/// length is zero, properties are not set.
		///</summary>
		/// <param name='bstr'> </param>
		/// <param name='ws'> </param>
		/// <returns></returns>
		[return: MarshalAs(UnmanagedType.Interface)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		ITsString MakeString([MarshalAs(UnmanagedType.BStr)] string bstr, int ws);

		/// <summary>
		/// Creates a simple ITsString from the OLECHAR string with writing system. The default
		/// writing system is assumed for this string. If cch is zero, properties are not set.
		///</summary>
		/// <param name='_rgch'> </param>
		/// <param name='cch'> </param>
		/// <param name='ws'> </param>
		/// <returns></returns>
		[return: MarshalAs(UnmanagedType.Interface)]
		[TypeLibFunc(TypeLibFuncFlags.FRestricted)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		ITsString MakeStringRgch([MarshalAs(UnmanagedType.LPWStr)] string _rgch, int cch, int ws);

		/// <summary>
		/// Creates a simple ITsString from the OLECHAR string with the given properties.
		/// The string might be empty.
		///</summary>
		/// <param name='_rgch'> </param>
		/// <param name='cch'> </param>
		/// <param name='_ttp'> </param>
		/// <returns></returns>
		[return: MarshalAs(UnmanagedType.Interface)]
		[TypeLibFunc(TypeLibFuncFlags.FRestricted)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		ITsString MakeStringWithPropsRgch([MarshalAs(UnmanagedType.LPWStr)] string _rgch, int cch, [MarshalAs(UnmanagedType.Interface)] ITsTextProps _ttp);

		/// <summary> Builders.
		/// Creates an empty string builder object. </summary>
		/// <returns></returns>
		[return: MarshalAs(UnmanagedType.Interface)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		ITsStrBldr GetBldr();

		/// <summary> Creates an empty incremental string builder object. </summary>
		/// <returns></returns>
		[return: MarshalAs(UnmanagedType.Interface)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		ITsIncStrBldr GetIncBldr();

		/// <summary> Run information
		/// Fetch the number of runs in the given format prgch. </summary>
		/// <param name='_rgbFmt'> </param>
		/// <param name='cbFmt'> </param>
		/// <returns></returns>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		int get_RunCount([MarshalAs(UnmanagedType.LPArray, SizeParamIndex=1)] byte[] _rgbFmt, int cbFmt);

		/// <summary>
		/// Fetch the run information at a given character position relative to the format prgch.
		/// ich must be a valid character postion.
		///</summary>
		/// <param name='_rgbFmt'> </param>
		/// <param name='cbFmt'> </param>
		/// <param name='ich'> </param>
		/// <param name='_tri'> </param>
		/// <returns></returns>
		[return: MarshalAs(UnmanagedType.Interface)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		ITsTextProps FetchRunInfoAt([MarshalAs(UnmanagedType.LPArray, SizeParamIndex=1)] byte[] _rgbFmt, int cbFmt, int ich, out TsRunInfo _tri);

		/// <summary>
		/// Fetch the run information for a particular run in for format prgch. irun must be a valid
		/// run index.
		///</summary>
		/// <param name='_rgbFmt'> </param>
		/// <param name='cbFmt'> </param>
		/// <param name='irun'> </param>
		/// <param name='_tri'> </param>
		/// <returns></returns>
		[return: MarshalAs(UnmanagedType.Interface)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		ITsTextProps FetchRunInfo([MarshalAs(UnmanagedType.LPArray, SizeParamIndex=1)] byte[] _rgbFmt, int cbFmt, int irun, out TsRunInfo _tri);

		/// <summary>
		/// Return an empty string in the specified writing system.
		/// These are typically cached so a new object does not have to be created every time.
		///</summary>
		/// <param name='ws'> </param>
		/// <returns></returns>
		[return: MarshalAs(UnmanagedType.Interface)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		ITsString EmptyString(int ws);
	}

	/// <summary>
	/// The main purpose of ITsPropsFactory is to provide the Deserialize method to the persistence
	/// mechanism. It also provides a mechanism to create a property object and create an empty
	/// property builder.
	/// Hungarian: tpf
	///</summary>
	[ComImport()]
	[InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]
	[Guid("8DCE56A6-CFF1-4402-95FE-2B574912B54E")]
	public interface ITsPropsFactory
	{

		/// <summary> </summary>
		/// <param name='_strm'> </param>
		/// <returns></returns>
		[return: MarshalAs(UnmanagedType.Interface)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		ITsTextProps DeserializeProps(System.Runtime.InteropServices.ComTypes.IStream _strm);

		/// <summary> </summary>
		/// <param name='_rgb'> </param>
		/// <param name='_cb'> </param>
		/// <returns></returns>
		[return: MarshalAs(UnmanagedType.Interface)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		ITsTextProps DeserializePropsRgb([MarshalAs(UnmanagedType.LPArray, SizeParamIndex=1)] byte[] _rgb, ref int _cb);

		/// <summary>
		/// Create a set of TsTextProps from the string. DOES NOT create a separate object for
		/// runs that have duplicate properties; the return array will point to duplicate copies
		/// of the TsTextProps.
		///</summary>
		/// <param name='cpttpMax'> </param>
		/// <param name='_rgb'> </param>
		/// <param name='_cb'> </param>
		/// <param name='_cpttpRet'> </param>
		/// <param name='rgpttp'> </param>
		/// <param name='rgich'> </param>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void DeserializeRgPropsRgb(int cpttpMax, [MarshalAs(UnmanagedType.LPArray, SizeParamIndex=2)] byte[] _rgb, ref int _cb, out int _cpttpRet, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef=typeof(ArrayPtrMarshaler))] ArrayPtr/*ITsTextProps[]*/ rgpttp, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef=typeof(ArrayPtrMarshaler))] ArrayPtr/*int[]*/ rgich);

		/// <summary>
		/// Creates a property object containing ws writing system, ows old writing system, and a character
		/// style (kstpCharStyle) value passed as a BSTR. The ws value may be zero which means
		/// no writing system is specified. bstrStyle may be NULL. If ws is zero, ows must also be zero.
		/// An error will be returned otherwise.
		///</summary>
		/// <param name='bstrStyle'> </param>
		/// <param name='ws'> </param>
		/// <param name='ows'> </param>
		/// <returns></returns>
		[return: MarshalAs(UnmanagedType.Interface)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		ITsTextProps MakeProps([MarshalAs(UnmanagedType.BStr)] string bstrStyle, int ws, int ows);

		/// <summary>
		/// Creates a property object containing ws writing system, ows old writing system, and a character
		/// style (kstpCharStyle) value passed as a OLECHAR array. The ws value may be zero which
		/// means no writing system is specified. prgchStyle may be NULL. If ws is zero, ows must also
		/// be zero. An error will be returned otherwise.
		///</summary>
		/// <param name='_rgchStyle'> </param>
		/// <param name='cch'> </param>
		/// <param name='ws'> </param>
		/// <param name='ows'> </param>
		/// <returns></returns>
		[return: MarshalAs(UnmanagedType.Interface)]
		[TypeLibFunc(TypeLibFuncFlags.FRestricted)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		ITsTextProps MakePropsRgch([MarshalAs(UnmanagedType.LPWStr)] string _rgchStyle, int cch, int ws, int ows);

		/// <summary> Creates an empty text property builder. </summary>
		/// <returns></returns>
		[return: MarshalAs(UnmanagedType.Interface)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		ITsPropsBldr GetPropsBldr();
	}

	/// <summary>
	/// REVIEW: ShonK, JeffG(JeffG): Should TsStrBldr derive off of TsStrBase? and
	/// Should Strbuilder(s) accept TsPropsBldrs
	///</summary>
	[ComImport()]
	[InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]
	[Guid("F1EF76E6-BE04-11d3-8D9A-005004DEFEC4")]
	public interface ITsStrBldr
	{

		/// <summary>
		/// With the exception of the Replace, PushEcoding, GetString methods, all other methods are
		/// the same as the methods with the same names found on ITsString. Please refer to ITsString
		/// for documentation.
		///</summary>
		/// <returns>A System.String </returns>
		string Text
		{
			[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
			[return: MarshalAs(UnmanagedType.BStr)]
			get;
		}

		/// <summary> </summary>
		/// <returns>A System.Int32 </returns>
		int Length
		{
			[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
			get;
		}

		/// <summary> </summary>
		/// <returns>A System.Int32 </returns>
		int RunCount
		{
			[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
			get;
		}

		/// <summary> Mapping between character indexes and run indexes. </summary>
		/// <param name='ich'> </param>
		/// <returns></returns>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		int get_RunAt(int ich);

		/// <summary> </summary>
		/// <param name='irun'> </param>
		/// <param name='_ichMin'> </param>
		/// <param name='_ichLim'> </param>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void GetBoundsOfRun(int irun, out int _ichMin, out int _ichLim);

		/// <summary> </summary>
		/// <param name='ich'> </param>
		/// <param name='_tri'> </param>
		/// <returns></returns>
		[return: MarshalAs(UnmanagedType.Interface)]
		[TypeLibFunc(TypeLibFuncFlags.FRestricted)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		ITsTextProps FetchRunInfoAt(int ich, out TsRunInfo _tri);

		/// <summary> </summary>
		/// <param name='irun'> </param>
		/// <param name='_tri'> </param>
		/// <returns></returns>
		[return: MarshalAs(UnmanagedType.Interface)]
		[TypeLibFunc(TypeLibFuncFlags.FRestricted)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		ITsTextProps FetchRunInfo(int irun, out TsRunInfo _tri);

		/// <summary> Fetching characters. </summary>
		/// <param name='irun'> </param>
		/// <returns></returns>
		[return: MarshalAs(UnmanagedType.BStr)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		string get_RunText(int irun);

		/// <summary> </summary>
		/// <param name='ichMin'> </param>
		/// <param name='ichLim'> </param>
		/// <returns></returns>
		[return: MarshalAs(UnmanagedType.BStr)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		string GetChars(int ichMin, int ichLim);

		/// <summary> </summary>
		/// <param name='ichMin'> </param>
		/// <param name='ichLim'> </param>
		/// <param name='_rgch'> </param>
		[Obsolete("Can\'t call COM method marked with [local] attribute in IDL file")]
		[TypeLibFunc(TypeLibFuncFlags.FRestricted)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void FetchChars(int ichMin, int ichLim, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef=typeof(ArrayPtrMarshaler))] ArrayPtr/*OLECHAR[]*/ _rgch);

		/// <summary> Getting properties. </summary>
		/// <param name='ich'> </param>
		/// <returns></returns>
		[return: MarshalAs(UnmanagedType.Interface)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		ITsTextProps get_PropertiesAt(int ich);

		/// <summary> </summary>
		/// <param name='irun'> </param>
		/// <returns></returns>
		[return: MarshalAs(UnmanagedType.Interface)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		ITsTextProps get_Properties(int irun);

		/// <summary>
		/// Methods to modify the current state.
		/// Replace characters from ichMin up to, but not including, ichLim with the text in bstrIns
		/// and the properties pttp. The Replace method an also perform an append by passing the lim
		/// of the string for both ichMin and ichLim. If bstrIns is NULL, the Replace method will
		/// delete the character range specified. If pttp is NULL, the properties found at ichMin
		/// will be assume in which case the new string will join the run at ichMin.
		///</summary>
		/// <param name='ichMin'> </param>
		/// <param name='ichLim'> </param>
		/// <param name='bstrIns'> </param>
		/// <param name='_ttp'> </param>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void Replace(int ichMin, int ichLim, [MarshalAs(UnmanagedType.BStr)] string bstrIns, [MarshalAs(UnmanagedType.Interface)] ITsTextProps _ttp);

		/// <summary>
		/// Replace from ichMin up to, but not including, ichLim with the text and properties of
		/// ptssIns. If ptssIns is NULL, the ReplaceTsString method will delete the character range
		/// specifed.
		///</summary>
		/// <param name='ichMin'> </param>
		/// <param name='ichLim'> </param>
		/// <param name='_tssIns'> </param>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void ReplaceTsString(int ichMin, int ichLim, [MarshalAs(UnmanagedType.Interface)] ITsString _tssIns);

		/// <summary>
		/// Replace characters from ichMin up to, but not including, ichLim with the text in prgchIns
		/// and the properties pttp. If cchIns is zero, the ReplaceRgch method will delete the
		/// character range specifed.
		///</summary>
		/// <param name='ichMin'> </param>
		/// <param name='ichLim'> </param>
		/// <param name='_rgchIns'> </param>
		/// <param name='cchIns'> </param>
		/// <param name='_ttp'> </param>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void ReplaceRgch(int ichMin, int ichLim, [MarshalAs(UnmanagedType.LPWStr)] string _rgchIns, int cchIns, [MarshalAs(UnmanagedType.Interface)] ITsTextProps _ttp);

		/// <summary> Set the properties for the range of characters. </summary>
		/// <param name='ichMin'> </param>
		/// <param name='ichLim'> </param>
		/// <param name='_ttp'> </param>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void SetProperties(int ichMin, int ichLim, [MarshalAs(UnmanagedType.Interface)] ITsTextProps _ttp);

		/// <summary>
		/// Set the integer prop values for the range of characters. If nVar and nVal are both 1,
		/// the integer property is removed.
		///</summary>
		/// <param name='ichMin'> </param>
		/// <param name='ichLim'> </param>
		/// <param name='tpt'> </param>
		/// <param name='nVar'> </param>
		/// <param name='nVal'> </param>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void SetIntPropValues(int ichMin, int ichLim, int tpt, int nVar, int nVal);

		/// <summary>
		/// Set the string prop values for the range of characters. If nVar is 1 and bstrVal is
		/// empty, the string property is removed.
		///</summary>
		/// <param name='ichMin'> </param>
		/// <param name='ichLim'> </param>
		/// <param name='tpt'> </param>
		/// <param name='bstrVal'> </param>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void SetStrPropValue(int ichMin, int ichLim, int tpt, [MarshalAs(UnmanagedType.BStr)] string bstrVal);

		/// <summary> Create an ITsString from the current state. </summary>
		/// <returns></returns>
		[return: MarshalAs(UnmanagedType.Interface)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		ITsString GetString();

		/// <summary> </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void Clear();

		/// <summary> Serialization. </summary>
		/// <returns></returns>
		System.Guid GetBldrClsid();

		/// <summary> </summary>
		/// <param name='_strm'> </param>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void SerializeFmt(System.Runtime.InteropServices.ComTypes.IStream _strm);

		/// <summary> </summary>
		/// <param name='_rgb'> </param>
		/// <param name='cbMax'> </param>
		/// <returns></returns>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		int SerializeFmtRgb([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef=typeof(ArrayPtrMarshaler))] ArrayPtr/*BYTE[]*/ _rgb, int cbMax);
	}

	/// <summary>
	/// ITsIncStrBldr supports the construction of a string with associated encodings, writing
	/// systems and properties by appending BSTRs, OLECHAR strings, ITsString objects and objects on
	/// the end of the string contained in the builder, if any.
	/// The current writing system/ows and properties may be set with the appropiate methods. Calling any
	/// of these methods will make the parameters passed the "current" values which will affect any
	/// subsequent append operation.
	/// An ITsString object and be created by calling GetString.
	/// Hungarian: tisb
	///</summary>
	[ComImport()]
	[InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]
	[Guid("F1EF76E7-BE04-11d3-8D9A-005004DEFEC4")]
	public interface ITsIncStrBldr
	{

		/// <summary> Fetch the raw text. </summary>
		/// <returns>A System.String </returns>
		string Text
		{
			[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
			[return: MarshalAs(UnmanagedType.BStr)]
			get;
		}

		/// <summary> Methods to modify the current state.
		/// Append a BSTR to end of the string. </summary>
		/// <param name='bstrIns'> </param>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void Append([MarshalAs(UnmanagedType.BStr)] string bstrIns);

		/// <summary> Append an ITsString to the end of the string. </summary>
		/// <param name='_tssIns'> </param>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void AppendTsString([MarshalAs(UnmanagedType.Interface)] ITsString _tssIns);

		/// <summary> Append the OLECHAR string to the end of the string. </summary>
		/// <param name='_rgchIns'> </param>
		/// <param name='cchIns'> </param>
		[TypeLibFunc(TypeLibFuncFlags.FRestricted)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void AppendRgch([MarshalAs(UnmanagedType.LPWStr)] string _rgchIns, int cchIns);

		/// <summary>
		/// Set an integer property to be applied to any subsequent append operations. The value of
		/// tpt is not checked for validity, but its value affects how nVar and nVal are interpreted.
		/// If nVar and nVal are 1, the integer property is deleted.
		///</summary>
		/// <param name='tpt'> </param>
		/// <param name='nVar'> </param>
		/// <param name='nVal'> </param>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void SetIntPropValues(int tpt, int nVar, int nVal);

		/// <summary>
		/// Set a string property to be applied to any subsequent append operations. The value of
		/// tpt is not checked for validity. If nVar is 1 and bstrVal is empty, the string
		/// property is deleted.
		///</summary>
		/// <param name='tpt'> </param>
		/// <param name='bstrVal'> </param>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void SetStrPropValue(int tpt, [MarshalAs(UnmanagedType.BStr)] string bstrVal);

		/// <summary> Create an ITsString object from the current state. </summary>
		/// <returns></returns>
		[return: MarshalAs(UnmanagedType.Interface)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		ITsString GetString();

		/// <summary> </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void Clear();

		/// <summary> Serialization. </summary>
		/// <returns></returns>
		System.Guid GetIncBldrClsid();

		/// <summary> </summary>
		/// <param name='_strm'> </param>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void SerializeFmt(System.Runtime.InteropServices.ComTypes.IStream _strm);

		/// <summary> </summary>
		/// <param name='_rgb'> </param>
		/// <param name='cbMax'> </param>
		/// <returns></returns>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		int SerializeFmtRgb([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef=typeof(ArrayPtrMarshaler))] ArrayPtr/*BYTE[]*/ _rgb, int cbMax);
	}

	/// <summary> An ITsPropsBldr object is used to create ITsTextProps objects.
	/// Hungarian: tpb </summary>
	[ComImport()]
	[InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]
	[Guid("F1EF76E8-BE04-11d3-8D9A-005004DEFEC4")]
	public interface ITsPropsBldr
	{

		/// <summary> Fetch the number of integer properties. </summary>
		/// <returns>A System.Int32 </returns>
		int IntPropCount
		{
			[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
			get;
		}

		/// <summary> Fetch the integer property at a particular index. </summary>
		/// <param name='iv'> </param>
		/// <param name='_tpt'> </param>
		/// <param name='_nVar'> </param>
		/// <param name='_nVal'> </param>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void GetIntProp(int iv, out int _tpt, out int _nVar, out int _nVal);

		/// <summary>
		/// Fetch the variation and value of an integer property. If an invalid tpt value is passed,
		/// return S_FALSE and set both pnVar and pnVal to 1.
		///</summary>
		/// <param name='tpt'> </param>
		/// <param name='_nVar'> </param>
		/// <param name='_nVal'> </param>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void GetIntPropValues(int tpt, out int _nVar, out int _nVal);

		/// <summary> Fetch the number of string properties. </summary>
		/// <returns>A System.Int32 </returns>
		int StrPropCount
		{
			[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
			get;
		}

		/// <summary> Fetch the string property at a particular index. </summary>
		/// <param name='iv'> </param>
		/// <param name='_tpt'> </param>
		/// <param name='_bstrVal'> </param>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void GetStrProp(int iv, out int _tpt, [MarshalAs(UnmanagedType.BStr)] out string _bstrVal);

		/// <summary>
		/// Fetch the value of a string property. If an invalid tpt value is passed, return S_FALSE
		/// and set pbstrVal to NULL.
		///</summary>
		/// <param name='tpt'> </param>
		/// <param name='_bstrVal'> </param>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void GetStrPropValue(int tpt, [MarshalAs(UnmanagedType.BStr)] out string _bstrVal);

		/// <summary>
		/// Set an integer property. If nVar and nVal are 1, the integer property is deleted.
		///</summary>
		/// <param name='tpt'> </param>
		/// <param name='nVar'> </param>
		/// <param name='nVal'> </param>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void SetIntPropValues(int tpt, int nVar, int nVal);

		/// <summary> Set a string property. If bstrVal is empty, the string property is deleted. </summary>
		/// <param name='tpt'> </param>
		/// <param name='bstrVal'> </param>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void SetStrPropValue(int tpt, [MarshalAs(UnmanagedType.BStr)] string bstrVal);

		/// <summary>
		/// Set a string property. If bstrVal is empty, the string property is deleted.
		/// Same as above, but in some cases easier to use from C
		///</summary>
		/// <param name='tpt'> </param>
		/// <param name='rgchVal'> </param>
		/// <param name='nValLength'> </param>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void SetStrPropValueRgch(int tpt, [MarshalAs(UnmanagedType.LPArray, SizeParamIndex=2)] byte[] rgchVal, int nValLength);

		/// <summary>
		/// Create an ITsTextProps from the current state. The number of TextProps may be less then
		/// the number pushed or inserted do to the compression of like, adjacent values.
		///</summary>
		/// <returns></returns>
		[return: MarshalAs(UnmanagedType.Interface)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		ITsTextProps GetTextProps();
	}

	/// <summary>
	/// ITsStringMuli is an interface for storing and retrieving writing system/TsString pairs in a
	/// single property (MultiString). These are used for definitions, glosses, etc. in multiple
	/// languages. The pairs are called alternatives, since they are alternate ways of saying the
	/// same thing in different encodings. WritingSystems must be unique in a MultiString. (E.g.,
	/// a TsStringMulti can only have one English alternative.)
	/// Hungarian: tms
	///</summary>
	[ComImport()]
	[InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]
	[Guid("DD409520-C212-11d3-9BB7-00400541F9E9")]
	public interface ITsMultiString
	{

		/// <summary> Gets the number of string alternatives. </summary>
		/// <returns>A System.Int32 </returns>
		int StringCount
		{
			[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
			get;
		}

		/// <summary>
		/// Gets the TsString and writing system of the alternative at index iws. If the
		/// MultiString is empty and iws is 0, returns an empty TsString and 0 as the writing
		/// system. Thus iws == 0 will always return the first string or an empty string.
		/// Other than the above exception, if TsStringMulti does not hold a string at the requested
		/// index, it returns E_INVALIDARG.
		///</summary>
		/// <param name='iws'> </param>
		/// <param name='_ws'> </param>
		/// <returns></returns>
		[return: MarshalAs(UnmanagedType.Interface)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		ITsString GetStringFromIndex(int iws, out int _ws);

		/// <summary>
		/// Gets the TsString for the specified writing system. If the string does not already
		/// exist, an empty string is returned.
		/// Store the given TsString in the specified writing system. If a string already exists for ws,
		/// the original string will be replaced. If ptss is NULL, the alternative is deleted.
		///</summary>
		/// <param name='ws'> </param>
		/// <returns></returns>
		[return: MarshalAs(UnmanagedType.Interface)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		ITsString get_String(int ws);

		/// <summary>
		/// Gets the TsString for the specified writing system. If the string does not already
		/// exist, an empty string is returned.
		/// Store the given TsString in the specified writing system. If a string already exists for ws,
		/// the original string will be replaced. If ptss is NULL, the alternative is deleted.
		///</summary>
		/// <param name='ws'> </param>
		/// <param name='_tss'> </param>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void set_String(int ws, [MarshalAs(UnmanagedType.Interface)] ITsString _tss);
	}

	#region TsStrFactory CoClass definitions
	/// <summary>
	/// The main purpose of ITsStrFactory is to provide the Deserialize method to the persistence
	/// mechanism. It also provides a mechanism to get simple TsStrings and empty builders. Since
	/// TsString objects are imutable, the method to retrieve one from a persistant store must be
	/// provided by the factory.
	/// Hungarian: tsf
	///</summary>
	[ComImport()]
	[CoClass(typeof(_TsStrFactoryClass))]
	[Guid("C10EA417-8317-4048-AC90-103F8BDFB325")]
	public interface TsStrFactory : ITsStrFactory
	{
	}

	#region Private _TsStrFactoryClass class
	/// <summary>_TsStrFactoryClass </summary>
	[ComImport()]
	[ClassInterface(ClassInterfaceType.None)]
	[TypeLibType(TypeLibTypeFlags.FCanCreate)]
	[Guid("F1EF76E9-BE04-11d3-8D9A-005004DEFEC4")]
	internal class _TsStrFactoryClass : ITsStrFactory, TsStrFactory
	{

		/// <summary> </summary>
		/// <param name='_strmTxt'> </param>
		/// <param name='_strmFmt'> </param>
		/// <returns></returns>
		[return: MarshalAs(UnmanagedType.Interface)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		public virtual extern ITsString DeserializeStringStreams(System.Runtime.InteropServices.ComTypes.IStream _strmTxt, System.Runtime.InteropServices.ComTypes.IStream _strmFmt);

		/// <summary> </summary>
		/// <param name='bstrTxt'> </param>
		/// <param name='_strmFmt'> </param>
		/// <returns></returns>
		[return: MarshalAs(UnmanagedType.Interface)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		public virtual extern ITsString DeserializeString([MarshalAs(UnmanagedType.BStr)] string bstrTxt, System.Runtime.InteropServices.ComTypes.IStream _strmFmt);

		/// <summary> </summary>
		/// <param name='bstrTxt'> </param>
		/// <param name='_rgbFmt'> </param>
		/// <param name='cbFmt'> </param>
		/// <returns></returns>
		[return: MarshalAs(UnmanagedType.Interface)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		public virtual extern ITsString DeserializeStringRgb([MarshalAs(UnmanagedType.BStr)] string bstrTxt, [MarshalAs(UnmanagedType.LPArray, SizeParamIndex=2)] byte[] _rgbFmt, int cbFmt);

		/// <summary> </summary>
		/// <param name='_rgchTxt'> </param>
		/// <param name='_cchTxt'> </param>
		/// <param name='_rgbFmt'> </param>
		/// <param name='_cbFmt'> </param>
		/// <returns></returns>
		[return: MarshalAs(UnmanagedType.Interface)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		public virtual extern ITsString DeserializeStringRgch([MarshalAs(UnmanagedType.LPWStr)] string _rgchTxt, ref int _cchTxt, [MarshalAs(UnmanagedType.LPArray, SizeParamIndex=3)] byte[] _rgbFmt, ref int _cbFmt);

		/// <summary>
		/// Creates a simple ITsString from the BSTR with writing system. The default old writing
		/// system is assumed for this string. If ws is zero, the ws/ows stack is empty. If the string
		/// length is zero, properties are not set.
		///</summary>
		/// <param name='bstr'> </param>
		/// <param name='ws'> </param>
		/// <returns></returns>
		[return: MarshalAs(UnmanagedType.Interface)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		public virtual extern ITsString MakeString([MarshalAs(UnmanagedType.BStr)] string bstr, int ws);

		/// <summary>
		/// Creates a simple ITsString from the OLECHAR string with writing system. The default
		/// writing system is assumed for this string. If cch is zero, properties are not set.
		///</summary>
		/// <param name='_rgch'> </param>
		/// <param name='cch'> </param>
		/// <param name='ws'> </param>
		/// <returns></returns>
		[return: MarshalAs(UnmanagedType.Interface)]
		[TypeLibFunc(TypeLibFuncFlags.FRestricted)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		public virtual extern ITsString MakeStringRgch([MarshalAs(UnmanagedType.LPWStr)] string _rgch, int cch, int ws);

		/// <summary>
		/// Creates a simple ITsString from the OLECHAR string with the given properties.
		/// The string might be empty.
		///</summary>
		/// <param name='_rgch'> </param>
		/// <param name='cch'> </param>
		/// <param name='_ttp'> </param>
		/// <returns></returns>
		[return: MarshalAs(UnmanagedType.Interface)]
		[TypeLibFunc(TypeLibFuncFlags.FRestricted)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		public virtual extern ITsString MakeStringWithPropsRgch([MarshalAs(UnmanagedType.LPWStr)] string _rgch, int cch, [MarshalAs(UnmanagedType.Interface)] ITsTextProps _ttp);

		/// <summary> Builders.
		/// Creates an empty string builder object. </summary>
		/// <returns></returns>
		[return: MarshalAs(UnmanagedType.Interface)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		public virtual extern ITsStrBldr GetBldr();

		/// <summary> Creates an empty incremental string builder object. </summary>
		/// <returns></returns>
		[return: MarshalAs(UnmanagedType.Interface)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		public virtual extern ITsIncStrBldr GetIncBldr();

		/// <summary> Run information
		/// Fetch the number of runs in the given format prgch. </summary>
		/// <param name='_rgbFmt'> </param>
		/// <param name='cbFmt'> </param>
		/// <returns></returns>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		public virtual extern int get_RunCount([MarshalAs(UnmanagedType.LPArray, SizeParamIndex=1)] byte[] _rgbFmt, int cbFmt);

		/// <summary>
		/// Fetch the run information at a given character position relative to the format prgch.
		/// ich must be a valid character postion.
		///</summary>
		/// <param name='_rgbFmt'> </param>
		/// <param name='cbFmt'> </param>
		/// <param name='ich'> </param>
		/// <param name='_tri'> </param>
		/// <returns></returns>
		[return: MarshalAs(UnmanagedType.Interface)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		public virtual extern ITsTextProps FetchRunInfoAt([MarshalAs(UnmanagedType.LPArray, SizeParamIndex=1)] byte[] _rgbFmt, int cbFmt, int ich, out TsRunInfo _tri);

		/// <summary>
		/// Fetch the run information for a particular run in for format prgch. irun must be a valid
		/// run index.
		///</summary>
		/// <param name='_rgbFmt'> </param>
		/// <param name='cbFmt'> </param>
		/// <param name='irun'> </param>
		/// <param name='_tri'> </param>
		/// <returns></returns>
		[return: MarshalAs(UnmanagedType.Interface)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		public virtual extern ITsTextProps FetchRunInfo([MarshalAs(UnmanagedType.LPArray, SizeParamIndex=1)] byte[] _rgbFmt, int cbFmt, int irun, out TsRunInfo _tri);

		/// <summary>
		/// Return an empty string in the specified writing system.
		/// These are typically cached so a new object does not have to be created every time.
		///</summary>
		/// <param name='ws'> </param>
		/// <returns></returns>
		[return: MarshalAs(UnmanagedType.Interface)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		public virtual extern ITsString EmptyString(int ws);
	}
	#endregion

	/// <summary>TsStrFactoryClass </summary>
	public static class TsStrFactoryClass
	{

		/// <summary>Member Create </summary>
		/// <returns>A TsStrFactory</returns>
		public static TsStrFactory Create()
		{
			return new _TsStrFactoryClass();
		}
	}
	#endregion

	#region TsPropsFactory CoClass definitions
	/// <summary>
	/// The main purpose of ITsPropsFactory is to provide the Deserialize method to the persistence
	/// mechanism. It also provides a mechanism to create a property object and create an empty
	/// property builder.
	/// Hungarian: tpf
	///</summary>
	[ComImport()]
	[CoClass(typeof(_TsPropsFactoryClass))]
	[Guid("8DCE56A6-CFF1-4402-95FE-2B574912B54E")]
	public interface TsPropsFactory : ITsPropsFactory
	{
	}

	#region Private _TsPropsFactoryClass class
	/// <summary>_TsPropsFactoryClass </summary>
	[ComImport()]
	[ClassInterface(ClassInterfaceType.None)]
	[TypeLibType(TypeLibTypeFlags.FCanCreate)]
	[Guid("F1EF76EA-BE04-11d3-8D9A-005004DEFEC4")]
	internal class _TsPropsFactoryClass : ITsPropsFactory, TsPropsFactory
	{

		/// <summary> </summary>
		/// <param name='_strm'> </param>
		/// <returns></returns>
		[return: MarshalAs(UnmanagedType.Interface)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		public virtual extern ITsTextProps DeserializeProps(System.Runtime.InteropServices.ComTypes.IStream _strm);

		/// <summary> </summary>
		/// <param name='_rgb'> </param>
		/// <param name='_cb'> </param>
		/// <returns></returns>
		[return: MarshalAs(UnmanagedType.Interface)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		public virtual extern ITsTextProps DeserializePropsRgb([MarshalAs(UnmanagedType.LPArray, SizeParamIndex=1)] byte[] _rgb, ref int _cb);

		/// <summary>
		/// Create a set of TsTextProps from the string. DOES NOT create a separate object for
		/// runs that have duplicate properties; the return array will point to duplicate copies
		/// of the TsTextProps.
		///</summary>
		/// <param name='cpttpMax'> </param>
		/// <param name='_rgb'> </param>
		/// <param name='_cb'> </param>
		/// <param name='_cpttpRet'> </param>
		/// <param name='rgpttp'> </param>
		/// <param name='rgich'> </param>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		public virtual extern void DeserializeRgPropsRgb(int cpttpMax, [MarshalAs(UnmanagedType.LPArray, SizeParamIndex=2)] byte[] _rgb, ref int _cb, out int _cpttpRet, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef=typeof(ArrayPtrMarshaler))] ArrayPtr/*ITsTextProps[]*/ rgpttp, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef=typeof(ArrayPtrMarshaler))] ArrayPtr/*int[]*/ rgich);

		/// <summary>
		/// Creates a property object containing ws writing system, ows old writing system, and a character
		/// style (kstpCharStyle) value passed as a BSTR. The ws value may be zero which means
		/// no writing system is specified. bstrStyle may be NULL. If ws is zero, ows must also be zero.
		/// An error will be returned otherwise.
		///</summary>
		/// <param name='bstrStyle'> </param>
		/// <param name='ws'> </param>
		/// <param name='ows'> </param>
		/// <returns></returns>
		[return: MarshalAs(UnmanagedType.Interface)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		public virtual extern ITsTextProps MakeProps([MarshalAs(UnmanagedType.BStr)] string bstrStyle, int ws, int ows);

		/// <summary>
		/// Creates a property object containing ws writing system, ows old writing system, and a character
		/// style (kstpCharStyle) value passed as a OLECHAR array. The ws value may be zero which
		/// means no writing system is specified. prgchStyle may be NULL. If ws is zero, ows must also
		/// be zero. An error will be returned otherwise.
		///</summary>
		/// <param name='_rgchStyle'> </param>
		/// <param name='cch'> </param>
		/// <param name='ws'> </param>
		/// <param name='ows'> </param>
		/// <returns></returns>
		[return: MarshalAs(UnmanagedType.Interface)]
		[TypeLibFunc(TypeLibFuncFlags.FRestricted)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		public virtual extern ITsTextProps MakePropsRgch([MarshalAs(UnmanagedType.LPWStr)] string _rgchStyle, int cch, int ws, int ows);

		/// <summary> Creates an empty text property builder. </summary>
		/// <returns></returns>
		[return: MarshalAs(UnmanagedType.Interface)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		public virtual extern ITsPropsBldr GetPropsBldr();
	}
	#endregion

	/// <summary>TsPropsFactoryClass </summary>
	public static class TsPropsFactoryClass
	{

		/// <summary>Member Create </summary>
		/// <returns>A TsPropsFactory</returns>
		public static TsPropsFactory Create()
		{
			return new _TsPropsFactoryClass();
		}
	}
	#endregion

	#region TsStrBldr CoClass definitions
	/// <summary>
	/// REVIEW: ShonK, JeffG(JeffG): Should TsStrBldr derive off of TsStrBase? and
	/// Should Strbuilder(s) accept TsPropsBldrs
	///</summary>
	[ComImport()]
	[CoClass(typeof(_TsStrBldrClass))]
	[Guid("F1EF76E6-BE04-11d3-8D9A-005004DEFEC4")]
	public interface TsStrBldr : ITsStrBldr
	{
	}

	#region Private _TsStrBldrClass class
	/// <summary>_TsStrBldrClass </summary>
	[ComImport()]
	[ClassInterface(ClassInterfaceType.None)]
	[TypeLibType(TypeLibTypeFlags.FCanCreate)]
	[Guid("F1EF76EB-BE04-11d3-8D9A-005004DEFEC4")]
	internal class _TsStrBldrClass : ITsStrBldr, TsStrBldr
	{

		/// <summary>
		/// With the exception of the Replace, PushEcoding, GetString methods, all other methods are
		/// the same as the methods with the same names found on ITsString. Please refer to ITsString
		/// for documentation.
		///</summary>
		/// <returns>A System.String </returns>
		public virtual extern string Text
		{
			[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
			[return: MarshalAs(UnmanagedType.BStr)]
			get;
		}

		/// <summary> </summary>
		/// <returns>A System.Int32 </returns>
		public virtual extern int Length
		{
			[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
			get;
		}

		/// <summary> </summary>
		/// <returns>A System.Int32 </returns>
		public virtual extern int RunCount
		{
			[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
			get;
		}

		/// <summary> Mapping between character indexes and run indexes. </summary>
		/// <param name='ich'> </param>
		/// <returns></returns>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		public virtual extern int get_RunAt(int ich);

		/// <summary> </summary>
		/// <param name='irun'> </param>
		/// <param name='_ichMin'> </param>
		/// <param name='_ichLim'> </param>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		public virtual extern void GetBoundsOfRun(int irun, out int _ichMin, out int _ichLim);

		/// <summary> </summary>
		/// <param name='ich'> </param>
		/// <param name='_tri'> </param>
		/// <returns></returns>
		[return: MarshalAs(UnmanagedType.Interface)]
		[TypeLibFunc(TypeLibFuncFlags.FRestricted)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		public virtual extern ITsTextProps FetchRunInfoAt(int ich, out TsRunInfo _tri);

		/// <summary> </summary>
		/// <param name='irun'> </param>
		/// <param name='_tri'> </param>
		/// <returns></returns>
		[return: MarshalAs(UnmanagedType.Interface)]
		[TypeLibFunc(TypeLibFuncFlags.FRestricted)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		public virtual extern ITsTextProps FetchRunInfo(int irun, out TsRunInfo _tri);

		/// <summary> Fetching characters. </summary>
		/// <param name='irun'> </param>
		/// <returns></returns>
		[return: MarshalAs(UnmanagedType.BStr)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		public virtual extern string get_RunText(int irun);

		/// <summary> </summary>
		/// <param name='ichMin'> </param>
		/// <param name='ichLim'> </param>
		/// <returns></returns>
		[return: MarshalAs(UnmanagedType.BStr)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		public virtual extern string GetChars(int ichMin, int ichLim);

		/// <summary> </summary>
		/// <param name='ichMin'> </param>
		/// <param name='ichLim'> </param>
		/// <param name='_rgch'> </param>
		[Obsolete("Can\'t call COM method marked with [local] attribute in IDL file")]
		[TypeLibFunc(TypeLibFuncFlags.FRestricted)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		public virtual extern void FetchChars(int ichMin, int ichLim, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef=typeof(ArrayPtrMarshaler))] ArrayPtr/*OLECHAR[]*/ _rgch);

		/// <summary> Getting properties. </summary>
		/// <param name='ich'> </param>
		/// <returns></returns>
		[return: MarshalAs(UnmanagedType.Interface)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		public virtual extern ITsTextProps get_PropertiesAt(int ich);

		/// <summary> </summary>
		/// <param name='irun'> </param>
		/// <returns></returns>
		[return: MarshalAs(UnmanagedType.Interface)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		public virtual extern ITsTextProps get_Properties(int irun);

		/// <summary>
		/// Methods to modify the current state.
		/// Replace characters from ichMin up to, but not including, ichLim with the text in bstrIns
		/// and the properties pttp. The Replace method an also perform an append by passing the lim
		/// of the string for both ichMin and ichLim. If bstrIns is NULL, the Replace method will
		/// delete the character range specified. If pttp is NULL, the properties found at ichMin
		/// will be assume in which case the new string will join the run at ichMin.
		///</summary>
		/// <param name='ichMin'> </param>
		/// <param name='ichLim'> </param>
		/// <param name='bstrIns'> </param>
		/// <param name='_ttp'> </param>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		public virtual extern void Replace(int ichMin, int ichLim, [MarshalAs(UnmanagedType.BStr)] string bstrIns, [MarshalAs(UnmanagedType.Interface)] ITsTextProps _ttp);

		/// <summary>
		/// Replace from ichMin up to, but not including, ichLim with the text and properties of
		/// ptssIns. If ptssIns is NULL, the ReplaceTsString method will delete the character range
		/// specifed.
		///</summary>
		/// <param name='ichMin'> </param>
		/// <param name='ichLim'> </param>
		/// <param name='_tssIns'> </param>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		public virtual extern void ReplaceTsString(int ichMin, int ichLim, [MarshalAs(UnmanagedType.Interface)] ITsString _tssIns);

		/// <summary>
		/// Replace characters from ichMin up to, but not including, ichLim with the text in prgchIns
		/// and the properties pttp. If cchIns is zero, the ReplaceRgch method will delete the
		/// character range specifed.
		///</summary>
		/// <param name='ichMin'> </param>
		/// <param name='ichLim'> </param>
		/// <param name='_rgchIns'> </param>
		/// <param name='cchIns'> </param>
		/// <param name='_ttp'> </param>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		public virtual extern void ReplaceRgch(int ichMin, int ichLim, [MarshalAs(UnmanagedType.LPWStr)] string _rgchIns, int cchIns, [MarshalAs(UnmanagedType.Interface)] ITsTextProps _ttp);

		/// <summary> Set the properties for the range of characters. </summary>
		/// <param name='ichMin'> </param>
		/// <param name='ichLim'> </param>
		/// <param name='_ttp'> </param>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		public virtual extern void SetProperties(int ichMin, int ichLim, [MarshalAs(UnmanagedType.Interface)] ITsTextProps _ttp);

		/// <summary>
		/// Set the integer prop values for the range of characters. If nVar and nVal are both 1,
		/// the integer property is removed.
		///</summary>
		/// <param name='ichMin'> </param>
		/// <param name='ichLim'> </param>
		/// <param name='tpt'> </param>
		/// <param name='nVar'> </param>
		/// <param name='nVal'> </param>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		public virtual extern void SetIntPropValues(int ichMin, int ichLim, int tpt, int nVar, int nVal);

		/// <summary>
		/// Set the string prop values for the range of characters. If nVar is 1 and bstrVal is
		/// empty, the string property is removed.
		///</summary>
		/// <param name='ichMin'> </param>
		/// <param name='ichLim'> </param>
		/// <param name='tpt'> </param>
		/// <param name='bstrVal'> </param>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		public virtual extern void SetStrPropValue(int ichMin, int ichLim, int tpt, [MarshalAs(UnmanagedType.BStr)] string bstrVal);

		/// <summary> Create an ITsString from the current state. </summary>
		/// <returns></returns>
		[return: MarshalAs(UnmanagedType.Interface)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		public virtual extern ITsString GetString();

		/// <summary> </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		public virtual extern void Clear();

		/// <summary> Serialization. </summary>
		/// <returns></returns>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		public virtual extern System.Guid GetBldrClsid();

		/// <summary> </summary>
		/// <param name='_strm'> </param>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		public virtual extern void SerializeFmt(System.Runtime.InteropServices.ComTypes.IStream _strm);

		/// <summary> </summary>
		/// <param name='_rgb'> </param>
		/// <param name='cbMax'> </param>
		/// <returns></returns>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		public virtual extern int SerializeFmtRgb([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef=typeof(ArrayPtrMarshaler))] ArrayPtr/*BYTE[]*/ _rgb, int cbMax);
	}
	#endregion

	/// <summary>TsStrBldrClass </summary>
	public static class TsStrBldrClass
	{

		/// <summary>Member Create </summary>
		/// <returns>A TsStrBldr</returns>
		public static TsStrBldr Create()
		{
			return new _TsStrBldrClass();
		}
	}
	#endregion

	#region TsIncStrBldr CoClass definitions
	/// <summary>
	/// ITsIncStrBldr supports the construction of a string with associated encodings, writing
	/// systems and properties by appending BSTRs, OLECHAR strings, ITsString objects and objects on
	/// the end of the string contained in the builder, if any.
	/// The current writing system/ows and properties may be set with the appropiate methods. Calling any
	/// of these methods will make the parameters passed the "current" values which will affect any
	/// subsequent append operation.
	/// An ITsString object and be created by calling GetString.
	/// Hungarian: tisb
	///</summary>
	[ComImport()]
	[CoClass(typeof(_TsIncStrBldrClass))]
	[Guid("F1EF76E7-BE04-11d3-8D9A-005004DEFEC4")]
	public interface TsIncStrBldr : ITsIncStrBldr
	{
	}

	#region Private _TsIncStrBldrClass class
	/// <summary>_TsIncStrBldrClass </summary>
	[ComImport()]
	[ClassInterface(ClassInterfaceType.None)]
	[TypeLibType(TypeLibTypeFlags.FCanCreate)]
	[Guid("F1EF76EC-BE04-11d3-8D9A-005004DEFEC4")]
	internal class _TsIncStrBldrClass : ITsIncStrBldr, TsIncStrBldr
	{

		/// <summary> Fetch the raw text. </summary>
		/// <returns>A System.String </returns>
		public virtual extern string Text
		{
			[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
			[return: MarshalAs(UnmanagedType.BStr)]
			get;
		}

		/// <summary> Methods to modify the current state.
		/// Append a BSTR to end of the string. </summary>
		/// <param name='bstrIns'> </param>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		public virtual extern void Append([MarshalAs(UnmanagedType.BStr)] string bstrIns);

		/// <summary> Append an ITsString to the end of the string. </summary>
		/// <param name='_tssIns'> </param>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		public virtual extern void AppendTsString([MarshalAs(UnmanagedType.Interface)] ITsString _tssIns);

		/// <summary> Append the OLECHAR string to the end of the string. </summary>
		/// <param name='_rgchIns'> </param>
		/// <param name='cchIns'> </param>
		[TypeLibFunc(TypeLibFuncFlags.FRestricted)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		public virtual extern void AppendRgch([MarshalAs(UnmanagedType.LPWStr)] string _rgchIns, int cchIns);

		/// <summary>
		/// Set an integer property to be applied to any subsequent append operations. The value of
		/// tpt is not checked for validity, but its value affects how nVar and nVal are interpreted.
		/// If nVar and nVal are 1, the integer property is deleted.
		///</summary>
		/// <param name='tpt'> </param>
		/// <param name='nVar'> </param>
		/// <param name='nVal'> </param>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		public virtual extern void SetIntPropValues(int tpt, int nVar, int nVal);

		/// <summary>
		/// Set a string property to be applied to any subsequent append operations. The value of
		/// tpt is not checked for validity. If nVar is 1 and bstrVal is empty, the string
		/// property is deleted.
		///</summary>
		/// <param name='tpt'> </param>
		/// <param name='bstrVal'> </param>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		public virtual extern void SetStrPropValue(int tpt, [MarshalAs(UnmanagedType.BStr)] string bstrVal);

		/// <summary> Create an ITsString object from the current state. </summary>
		/// <returns></returns>
		[return: MarshalAs(UnmanagedType.Interface)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		public virtual extern ITsString GetString();

		/// <summary> </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		public virtual extern void Clear();

		/// <summary> Serialization. </summary>
		/// <returns></returns>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		public virtual extern System.Guid GetIncBldrClsid();

		/// <summary> </summary>
		/// <param name='_strm'> </param>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		public virtual extern void SerializeFmt(System.Runtime.InteropServices.ComTypes.IStream _strm);

		/// <summary> </summary>
		/// <param name='_rgb'> </param>
		/// <param name='cbMax'> </param>
		/// <returns></returns>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		public virtual extern int SerializeFmtRgb([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef=typeof(ArrayPtrMarshaler))] ArrayPtr/*BYTE[]*/ _rgb, int cbMax);
	}
	#endregion

	/// <summary>TsIncStrBldrClass </summary>
	public static class TsIncStrBldrClass
	{

		/// <summary>Member Create </summary>
		/// <returns>A TsIncStrBldr</returns>
		public static TsIncStrBldr Create()
		{
			return new _TsIncStrBldrClass();
		}
	}
	#endregion

	#region TsPropsBldr CoClass definitions
	/// <summary> An ITsPropsBldr object is used to create ITsTextProps objects.
	/// Hungarian: tpb </summary>
	[ComImport()]
	[CoClass(typeof(_TsPropsBldrClass))]
	[Guid("F1EF76E8-BE04-11d3-8D9A-005004DEFEC4")]
	public interface TsPropsBldr : ITsPropsBldr
	{
	}

	#region Private _TsPropsBldrClass class
	/// <summary>_TsPropsBldrClass </summary>
	[ComImport()]
	[ClassInterface(ClassInterfaceType.None)]
	[TypeLibType(TypeLibTypeFlags.FCanCreate)]
	[Guid("F1EF76ED-BE04-11d3-8D9A-005004DEFEC4")]
	internal class _TsPropsBldrClass : ITsPropsBldr, TsPropsBldr
	{

		/// <summary> Fetch the number of integer properties. </summary>
		/// <returns>A System.Int32 </returns>
		public virtual extern int IntPropCount
		{
			[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
			get;
		}

		/// <summary> Fetch the integer property at a particular index. </summary>
		/// <param name='iv'> </param>
		/// <param name='_tpt'> </param>
		/// <param name='_nVar'> </param>
		/// <param name='_nVal'> </param>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		public virtual extern void GetIntProp(int iv, out int _tpt, out int _nVar, out int _nVal);

		/// <summary>
		/// Fetch the variation and value of an integer property. If an invalid tpt value is passed,
		/// return S_FALSE and set both pnVar and pnVal to 1.
		///</summary>
		/// <param name='tpt'> </param>
		/// <param name='_nVar'> </param>
		/// <param name='_nVal'> </param>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		public virtual extern void GetIntPropValues(int tpt, out int _nVar, out int _nVal);

		/// <summary> Fetch the number of string properties. </summary>
		/// <returns>A System.Int32 </returns>
		public virtual extern int StrPropCount
		{
			[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
			get;
		}

		/// <summary> Fetch the string property at a particular index. </summary>
		/// <param name='iv'> </param>
		/// <param name='_tpt'> </param>
		/// <param name='_bstrVal'> </param>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		public virtual extern void GetStrProp(int iv, out int _tpt, [MarshalAs(UnmanagedType.BStr)] out string _bstrVal);

		/// <summary>
		/// Fetch the value of a string property. If an invalid tpt value is passed, return S_FALSE
		/// and set pbstrVal to NULL.
		///</summary>
		/// <param name='tpt'> </param>
		/// <param name='_bstrVal'> </param>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		public virtual extern void GetStrPropValue(int tpt, [MarshalAs(UnmanagedType.BStr)] out string _bstrVal);

		/// <summary>
		/// Set an integer property. If nVar and nVal are 1, the integer property is deleted.
		///</summary>
		/// <param name='tpt'> </param>
		/// <param name='nVar'> </param>
		/// <param name='nVal'> </param>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		public virtual extern void SetIntPropValues(int tpt, int nVar, int nVal);

		/// <summary> Set a string property. If bstrVal is empty, the string property is deleted. </summary>
		/// <param name='tpt'> </param>
		/// <param name='bstrVal'> </param>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		public virtual extern void SetStrPropValue(int tpt, [MarshalAs(UnmanagedType.BStr)] string bstrVal);

		/// <summary>
		/// Set a string property. If bstrVal is empty, the string property is deleted.
		/// Same as above, but in some cases easier to use from C
		///</summary>
		/// <param name='tpt'> </param>
		/// <param name='rgchVal'> </param>
		/// <param name='nValLength'> </param>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		public virtual extern void SetStrPropValueRgch(int tpt, [MarshalAs(UnmanagedType.LPArray, SizeParamIndex=2)] byte[] rgchVal, int nValLength);

		/// <summary>
		/// Create an ITsTextProps from the current state. The number of TextProps may be less then
		/// the number pushed or inserted do to the compression of like, adjacent values.
		///</summary>
		/// <returns></returns>
		[return: MarshalAs(UnmanagedType.Interface)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		public virtual extern ITsTextProps GetTextProps();
	}
	#endregion

	/// <summary>TsPropsBldrClass </summary>
	public static class TsPropsBldrClass
	{

		/// <summary>Member Create </summary>
		/// <returns>A TsPropsBldr</returns>
		public static TsPropsBldr Create()
		{
			return new _TsPropsBldrClass();
		}
	}
	#endregion

	#region TsMultiString CoClass definitions
	/// <summary>
	/// ITsStringMuli is an interface for storing and retrieving writing system/TsString pairs in a
	/// single property (MultiString). These are used for definitions, glosses, etc. in multiple
	/// languages. The pairs are called alternatives, since they are alternate ways of saying the
	/// same thing in different encodings. WritingSystems must be unique in a MultiString. (E.g.,
	/// a TsStringMulti can only have one English alternative.)
	/// Hungarian: tms
	///</summary>
	[ComImport()]
	[CoClass(typeof(_TsMultiStringClass))]
	[Guid("DD409520-C212-11d3-9BB7-00400541F9E9")]
	public interface TsMultiString : ITsMultiString
	{
	}

	#region Private _TsMultiStringClass class
	/// <summary>_TsMultiStringClass </summary>
	[ComImport()]
	[ClassInterface(ClassInterfaceType.None)]
	[TypeLibType(TypeLibTypeFlags.FCanCreate)]
	[Guid("7A1B89C0-C2D6-11d3-9BB7-00400541F9E9")]
	internal class _TsMultiStringClass : ITsMultiString, TsMultiString
	{

		/// <summary> Gets the number of string alternatives. </summary>
		/// <returns>A System.Int32 </returns>
		public virtual extern int StringCount
		{
			[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
			get;
		}

		/// <summary>
		/// Gets the TsString and writing system of the alternative at index iws. If the
		/// MultiString is empty and iws is 0, returns an empty TsString and 0 as the writing
		/// system. Thus iws == 0 will always return the first string or an empty string.
		/// Other than the above exception, if TsStringMulti does not hold a string at the requested
		/// index, it returns E_INVALIDARG.
		///</summary>
		/// <param name='iws'> </param>
		/// <param name='_ws'> </param>
		/// <returns></returns>
		[return: MarshalAs(UnmanagedType.Interface)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		public virtual extern ITsString GetStringFromIndex(int iws, out int _ws);

		/// <summary>
		/// Gets the TsString for the specified writing system. If the string does not already
		/// exist, an empty string is returned.
		/// Store the given TsString in the specified writing system. If a string already exists for ws,
		/// the original string will be replaced. If ptss is NULL, the alternative is deleted.
		///</summary>
		/// <param name='ws'> </param>
		/// <returns></returns>
		[return: MarshalAs(UnmanagedType.Interface)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		public virtual extern ITsString get_String(int ws);

		/// <summary>
		/// Gets the TsString for the specified writing system. If the string does not already
		/// exist, an empty string is returned.
		/// Store the given TsString in the specified writing system. If a string already exists for ws,
		/// the original string will be replaced. If ptss is NULL, the alternative is deleted.
		///</summary>
		/// <param name='ws'> </param>
		/// <param name='_tss'> </param>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		public virtual extern void set_String(int ws, [MarshalAs(UnmanagedType.Interface)] ITsString _tss);
	}
	#endregion

	/// <summary>TsMultiStringClass </summary>
	public static class TsMultiStringClass
	{

		/// <summary>Member Create </summary>
		/// <returns>A TsMultiString</returns>
		public static TsMultiString Create()
		{
			return new _TsMultiStringClass();
		}
	}
	#endregion

	/// <summary> Types of line break, used by the rendering engines. </summary>
	public enum LgLineBreak
	{

		/// <summary> (the segment is not broken at all; the whole run fit); </summary>
		klbNoBreak = 0,

		/// <summary> </summary>
		klbWsBreak = 10,

		/// <summary> (a break at a word boundary: a normal, natural place to break); </summary>
		klbWordBreak = 15,

		/// <summary> (not necessarily known to be a word break but still pretty good); </summary>
		klbGoodBreak = 19,

		/// <summary> (break a word at a known valid hyphenation point, or comparable; </summary>
		klbHyphenBreak = 20,

		/// <summary> (break between letters, but not at a word or normal hyphenation point), </summary>
		klbLetterBreak = 30,

		/// <summary> (had to clip even first letter, worst possible break) </summary>
		klbClipBreak = 40,
	}

	/// <summary> Hungarian: lbrk
	/// typedef [v1_enum] enum LgLineBreak </summary>
	public enum LgLineBreakStatus
	{

		/// <summary> Break (i.e. "word break") after corresponding character is valid. </summary>
		kflbsBrk = 1,

		/// <summary> Corresponding character is a space (strictly, has Zs general </summary>
		kflbsSpace = 2,

		/// <summary>
		/// character property). Exception: space immediately before CM
		/// (combining mark) is not indicated as being a space.
		/// Only "letter break" is allowed after the corresponding character.
		///</summary>
		kflbsBrkL = 4,
	}

	/// <summary> Hungarian lbs </summary>
	public enum LgIPDrawMode
	{

		/// <summary> normal Ibeam </summary>
		kdmNormal,

		/// <summary> primary half of a split insertion point </summary>
		kdmSplitPrimary,

		/// <summary> secondary half of a split insertion point </summary>
		kdmSplitSecondary,
	}

	/// <summary> </summary>
	public enum LgIpValidResult
	{

		/// <summary> IP here is valid </summary>
		kipvrOK,

		/// <summary> IP here no good </summary>
		kipvrBad,

		/// <summary> This seg can't decide, ask the next </summary>
		kipvrUnknown,
	}

	/// <summary> </summary>
	public enum LgTrailingWsHandling
	{

		/// <summary> allow trailing whitespace (normal case) </summary>
		ktwshAll,

		/// <summary> disallow trailing whitespace </summary>
		ktwshNoWs,

		/// <summary> allow nothing but whitespace in the segment </summary>
		ktwshOnlyWs,
	}

	/// <summary> </summary>
	public enum LgUtfForm
	{

		/// <summary> </summary>
		kutf8,

		/// <summary> </summary>
		kutf16,

		/// <summary> </summary>
		kutf32,
	}

	/// <summary>
	/// Typedefs logically part of the Vw subsystem, but defined here to keep dependencies from
	/// being circular.
	///</summary>
	public enum VwGenericFontNames
	{

		/// <summary> not a generic font </summary>
		kvgfnCustom,

		/// <summary> </summary>
		kvgfnSerif,

		/// <summary> </summary>
		kvgfnSansSerif,

		/// <summary> </summary>
		kvgfnMonospace,
	}

	/// <summary> </summary>
	public enum VwFontStyle
	{

		/// <summary> </summary>
		kfsNormal,

		/// <summary> </summary>
		kfsItalic,

		/// <summary> </summary>
		kfsOblique,
	}

	/// <summary> </summary>
	public enum VwTextUnderline
	{

		/// <summary> </summary>
		ktuNoUnderline,

		/// <summary> </summary>
		ktuSingleUnderline,
	}

	/// <summary>
	/// Properties passed to renderer to tell it how to draw text.
	/// An HFONT is typically produced by combining the four font properties specified
	/// into a LOGFONT with lfWidth, lfOrientation, lfEscapement set to zero,
	/// lfUnderline set to false, (Client handles underlining; we want several types)
	/// lfStrikeOut set to false,
	/// lfCharSet set to DEFAULT_CHARSET,
	/// lfOutPrecision set to OUT_TT_ONLY_PRECIS
	/// lfClipPrecision set to CLIP_DEFAULT_PRECIS,
	/// lfQuality set to DEFAULT_QUALITY, and
	/// lfPitchAndFamily set to DEFAULT_PITCH | FF_DONTCARE
	/// szFaceName may be an actual font family name, or one of the names &lt;serif&gt;,
	/// &lt;sansserif&gt;, &lt;monospace&gt;, in which case the renderer must provide an appropriate
	/// interpretation. The magic names must match exactly (including case) and must include
	/// the angle brackets.
	/// The dympHeight value is usually modified by the WS before making an HFONT if
	/// superscript or subscript is specified;
	/// other properties may be modified as desired by the old writing system, by default or as
	/// a result of interpreting a old writing system style. For example, the WS may know of a
	/// minimum useful height for a particular font, and enforce this.
	/// ENHANCE JohnT: do we need a mechanism like that used in views to allow a list of font
	/// names to be passed? Seems the client could handle working out which of a list of
	/// named fonts is availableunless we need to try multiple ones to cover a code point
	/// range.
	/// ENHANCE JohnT: should we somehow make sure that each thread has only one instance of
	/// a chrp with given values, so we can use the pointer to it as a key to look up an
	/// HFONT?
	///</summary>
	[StructLayout(LayoutKind.Sequential, Pack=4)]
	public struct LgCharRenderProps
	{

		/// <summary> </summary>
		public uint clrFore;

		/// <summary> </summary>
		public uint clrBack;

		/// <summary> Underline color. </summary>
		public uint clrUnder;

		/// <summary> Baseline offset (+ve = raise) added to effect of super/subscript </summary>
		public int dympOffset;

		/// <summary> </summary>
		public int ws;

		/// <summary> true if writing system is righttoleft </summary>
		public byte fWsRtl;

		/// <summary> number of levels of direction change, para to this run </summary>
		public int nDirDepth;

		/// <summary> indicates superscript, subscript or normal. </summary>
		public int ssv;

		/// <summary> FwUnderlineType. </summary>
		public int unt;

		/// <summary>
		/// Remaining properties are the interesting ones for a LOGFONT
		/// Warning: these must be kept together at the end of the struct.
		/// Note that this assumes the client resolves wsdependent names like Serif,
		/// and also deals with finding the first available font in a list. This array
		/// has room for only one font name.
		///</summary>
		public int ttvBold;

		/// <summary> </summary>
		public int ttvItalic;

		/// <summary> normal font size. Superscript or subscript will usually reduce. </summary>
		public int dympHeight;

		/// <summary> </summary>
		[MarshalAs(UnmanagedType.ByValArray, SizeConst=32)]
		public ushort[] szFaceName;

		/// <summary> </summary>
		[MarshalAs(UnmanagedType.ByValArray, SizeConst=64)]
		public ushort[] szFontVar;
	}

	/// <summary> Hungarian: chrp
	/// Script direction codes </summary>
	public enum ScriptDirCode
	{

		/// <summary> </summary>
		kfsdcNone = 0,

		/// <summary> horizontal lefttoright </summary>
		kfsdcHorizLtr = 1,

		/// <summary> horizontal righttoleft </summary>
		kfsdcHorizRtl = 2,

		/// <summary> vertical from left </summary>
		kfsdcVertFromLeft = 4,

		/// <summary> vertical from right </summary>
		kfsdcVertFromRight = 8,
	}

	/// <summary> Hungarian: sdc
	/// Glyph attributes for justification </summary>
	public enum JustGlyphAttr
	{

		/// <summary> </summary>
		kjgatStretch = 1,

		/// <summary> </summary>
		kjgatShrink,

		/// <summary> </summary>
		kjgatWeight,

		/// <summary> </summary>
		kjgatStep,

		/// <summary> </summary>
		kjgatChunk,

		/// <summary> </summary>
		kjgatWidth,

		/// <summary> </summary>
		kjgatBreak,

		/// <summary> pseudoattributes for handling steps: </summary>
		kjgatStretchInSteps,

		/// <summary> </summary>
		kjgatWidthInSteps,

		/// <summary> also metrics: </summary>
		kjgatAdvWidth,

		/// <summary> </summary>
		kjgatAdvHeight,

		/// <summary> </summary>
		kjgatBbLeft,

		/// <summary> </summary>
		kjgatBbRight,

		/// <summary> </summary>
		kjgatBbTop,

		/// <summary> </summary>
		kjgatBbBottom,
	}

	/// <summary>
	/// Hungarian: jgat
	/// A placeholder till we figure out what is needed.
	/// But it is used in some application framework code already.
	/// Where will we put things like borders, that could be applied to strings within
	/// a para, or the para as a whole?
	///</summary>
	[StructLayout(LayoutKind.Sequential, Pack=4)]
	public struct LgParaRenderProps
	{

		/// <summary>
		/// int tal; Alignment.
		/// int dxmpFirstIndent;
		/// int dxmpLeadingIndent;
		/// int dxmpTrailingIndent;
		/// int dxmpTabDef;
		/// int relLine;
		/// int dympExtraLine;
		/// int relBefore;
		/// int dympExtraBefore;
		/// int relAfter;
		/// int dympExtraAfter;
		/// COLORREF clrBack;
		/// basic Paragraph directionality.
		///</summary>
		public ScriptDirCode sdcPara;

		/// <summary> basic document/field/?? directionality. </summary>
		public ScriptDirCode sdcOuter;
	}

	/// <summary>
	/// Interface for a simple approach to initializing a class by passing it a raw data buffer.
	/// Primarily for classes intended to be instantiated via an IClassInitMoniker object.
	/// ENHANCE JohnT: Does this definition belong somewhere else?
	/// Hungarian: simi
	///</summary>
	[ComImport()]
	[InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]
	[Guid("6433D19E-2DA2-4041-B202-DB118EE1694D")]
	public interface ISimpleInit
	{

		/// <summary> </summary>
		/// <param name='_rgb'> </param>
		/// <param name='cb'> </param>
		[TypeLibFunc(TypeLibFuncFlags.FRestricted)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void InitNew([MarshalAs(UnmanagedType.LPArray, SizeParamIndex=1)] byte[] _rgb, int cb);

		/// <summary> Return the initialization data previously passed in. </summary>
		/// <returns>A System.String </returns>
		string InitializationData
		{
			[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
			[return: MarshalAs(UnmanagedType.BStr)]
			get;
		}
	}

	/// <summary>
	/// Interface IVwGraphics
	/// Used to actually draw and measure things. It encapsulates an hDC, allowing only those
	/// operations we consider useful and safe; for example, it does not offer methods that
	/// cannot be used with Unicode characters on Win9X.
	///
	/// VwGraphics does not force any particular coordinate system on its clients.
	///</summary>
	[ComImport()]
	[InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]
	[Guid("F7233278-EA87-4FC9-83E2-CB7CC45DEBE7")]
	public interface IVwGraphics
	{

		/// <summary>
		/// Invert the rectangle by performing a logical NOT operation on the color values for
		/// each pixel in the rectangle's interior.
		///</summary>
		/// <param name='xLeft'> </param>
		/// <param name='yTop'> </param>
		/// <param name='xRight'> </param>
		/// <param name='yBottom'> </param>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void InvertRect(int xLeft, int yTop, int xRight, int yBottom);

		/// <summary> Foreground color used for lines, text </summary>
		/// <returns>A System.Int32 </returns>
		int ForeColor
		{
			[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
			set;
		}

		/// <summary> Background color used for shape interior, text background </summary>
		/// <returns>A System.Int32 </returns>
		int BackColor
		{
			[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
			set;
		}

		/// <summary> draw a filled rectangle. Current properties set control border, fill, etc. </summary>
		/// <param name='xLeft'> </param>
		/// <param name='yTop'> </param>
		/// <param name='xRight'> </param>
		/// <param name='yBottom'> </param>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void DrawRectangle(int xLeft, int yTop, int xRight, int yBottom);

		/// <summary>
		/// Draw a horizontal line that may be dotted or dashed.
		/// Consider first the behavior if pdxStart is 0.
		/// If cdx is 0 or, equivalently, cdx is 1 and prgdx is MAXINT, it draws a regular line
		/// line DrawLine from (xLeft, y) to (xRight, y).
		/// If there are multiple dx values, the line is dashed. A segment of length prgdx[0] is
		/// first drawn, then a gap of length prgdx[1] is left, then a segment of length prgdx[2],
		/// and so forth until the specified width is reached (the last segment, if drawn, is
		/// truncated to the specified length).
		/// If all values in prgdx are used up, we start again at prgdx[0]. An odd number of segments
		/// means that on and off alternate; thus, for example, a single width may be used to create
		/// a dashed line with equal gaps and dashes.
		/// The function then sets pdxStart to the distance from xRight to the start of the last
		/// place where prgdx[0] was drawn (not where it was skipped, if there is an odd number).
		/// If pdxStart is not initially zero, it gives a distance to skip through prgdx before
		/// starting. The normal use is to pass the value returned from a previous call, which
		/// can be used to draw several adjacent segments and have them seem continuous. You can also
		/// leave a gap in a dashed line by adding its width to pdxStart.
		/// (Another good way to use pdxStart is to set it to xLeft. This causes all patterns
		/// to be aligned, as if they were segments of one continuous pattern from the left margin.)
		///</summary>
		/// <param name='xLeft'> </param>
		/// <param name='xRight'> </param>
		/// <param name='y'> </param>
		/// <param name='dyHeight'> </param>
		/// <param name='cdx'> </param>
		/// <param name='_rgdx'> </param>
		/// <param name='_dxStart'> </param>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void DrawHorzLine(int xLeft, int xRight, int y, int dyHeight, int cdx, [MarshalAs(UnmanagedType.LPArray, SizeParamIndex=4)] int[] _rgdx, ref int _dxStart);

		/// <summary> </summary>
		/// <param name='xLeft'> </param>
		/// <param name='yTop'> </param>
		/// <param name='xRight'> </param>
		/// <param name='yBottom'> </param>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void DrawLine(int xLeft, int yTop, int xRight, int yBottom);

		/// <summary> </summary>
		/// <param name='x'> </param>
		/// <param name='y'> </param>
		/// <param name='cch'> </param>
		/// <param name='_rgch'> </param>
		/// <param name='xStretch'> make the string this much wider than natural </param>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void DrawText(int x, int y, int cch, [MarshalAs(UnmanagedType.LPWStr)] string _rgch, int xStretch);

		/// <summary> </summary>
		/// <param name='x'> </param>
		/// <param name='y'> </param>
		/// <param name='cch'> </param>
		/// <param name='_rgchw'> </param>
		/// <param name='uOptions'> </param>
		/// <param name='_rect'> </param>
		/// <param name='_rgdx'> </param>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void DrawTextExt(int x, int y, int cch, [MarshalAs(UnmanagedType.LPWStr)] string _rgchw, uint uOptions, ref Rect _rect, int _rgdx);

		/// <summary> </summary>
		/// <param name='cch'> </param>
		/// <param name='_rgch'> </param>
		/// <param name='_x'> </param>
		/// <param name='_y'> </param>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void GetTextExtent(int cch, [MarshalAs(UnmanagedType.LPWStr)] string _rgch, out int _x, out int _y);

		/// <summary>
		/// Get the width of the text up to a certain char position,
		/// assuming the entire string was drawn with the given stretch.
		///</summary>
		/// <param name='cch'> </param>
		/// <param name='_rgch'> </param>
		/// <param name='ich'> </param>
		/// <param name='xStretch'> </param>
		/// <returns></returns>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		int GetTextLeadWidth(int cch, [MarshalAs(UnmanagedType.LPWStr)] string _rgch, int ich, int xStretch);

		/// <summary> </summary>
		/// <param name='_xLeft'> </param>
		/// <param name='_yTop'> </param>
		/// <param name='_xRight'> </param>
		/// <param name='_yBottom'> </param>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void GetClipRect(out int _xLeft, out int _yTop, out int _xRight, out int _yBottom);

		/// <summary> The number of logical units corresponding to the font's emsquare </summary>
		/// <returns></returns>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		int GetFontEmSquare();

		/// <summary> </summary>
		/// <param name='chw'> </param>
		/// <param name='_sBoundingWidth'> </param>
		/// <param name='_yBoundingHeight'> </param>
		/// <param name='_xBoundingX'> </param>
		/// <param name='_yBoundingY'> </param>
		/// <param name='_xAdvanceX'> </param>
		/// <param name='_yAdvanceY'> </param>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void GetGlyphMetrics(int chw, out int _sBoundingWidth, out int _yBoundingHeight, out int _xBoundingX, out int _yBoundingY, out int _xAdvanceX, out int _yAdvanceY);

		/// <summary> Return TrueType table data from font file selected in the dc. </summary>
		/// <param name='nTableId'> </param>
		/// <param name='_cbTableSz'> </param>
		/// <returns></returns>
		[return: MarshalAs(UnmanagedType.BStr)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		string GetFontData(int nTableId, out int _cbTableSz);

		/// <summary> </summary>
		/// <param name='nTableId'> </param>
		/// <param name='_cbTableSz'> </param>
		/// <param name='_rgch'> </param>
		/// <param name='cchMax'> </param>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void GetFontDataRgch(int nTableId, out int _cbTableSz, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef=typeof(ArrayPtrMarshaler))] ArrayPtr/*OLECHAR[]*/ _rgch, int cchMax);

		/// <summary> </summary>
		/// <param name='chw'> </param>
		/// <param name='nPoint'> </param>
		/// <param name='_xRet'> </param>
		/// <param name='_yRet'> </param>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void XYFromGlyphPoint(int chw, int nPoint, out int _xRet, out int _yRet);

		/// <summary> </summary>
		/// <returns>A System.Int32 </returns>
		int FontAscent
		{
			[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
			get;
		}

		/// <summary> </summary>
		/// <returns>A System.Int32 </returns>
		int FontDescent
		{
			[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
			get;
		}

		/// <summary> </summary>
		/// <returns>A LgCharRenderProps </returns>
		LgCharRenderProps FontCharProperties
		{
			[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
			get;
		}

		/// <summary>
		/// This interface is typically subclassed, as here in VwGraphicsWin32,
		/// with a method that provides it with a device context or analogous
		/// drawing environment. A call to ReleaseDC tells the VwGraphics that
		/// it must no longer use that graphics environment. Typically most
		/// calls will fail while no DC is available to work with.
		///</summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void ReleaseDC();

		/// <summary>
		/// Get the resolution of the device in logical units per inch.
		/// Defaults to the actual resolution, but may be set to
		/// something else (e.g., to produce zoom)
		/// Sets the resolution of the device in logical units per inch.
		///</summary>
		/// <returns>A System.Int32 </returns>
		int XUnitsPerInch
		{
			[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
			get;
			[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
			set;
		}

		/// <summary>
		/// Get the resolution of the device in logical units per inch.
		/// Defaults to the actual resolution, but may be set to
		/// something else (e.g., to produce zoom)
		/// Sets the resolution of the device in logical units per inch.
		///</summary>
		/// <returns>A System.Int32 </returns>
		int YUnitsPerInch
		{
			[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
			get;
			[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
			set;
		}

		/// <summary>
		/// Gets the ratio of the superscript height to the normal height of the font
		/// currently selected into the DC
		///</summary>
		/// <param name='_iNumerator'> </param>
		/// <param name='_iDenominator'> </param>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void GetSuperscriptHeightRatio(out int _iNumerator, out int _iDenominator);

		/// <summary>
		/// Gets the ratio of the distance the superscript baseline is raised to the
		/// normal height of the font currently selected into the DC
		///</summary>
		/// <param name='_iNumerator'> </param>
		/// <param name='_iDenominator'> </param>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void GetSuperscriptYOffsetRatio(out int _iNumerator, out int _iDenominator);

		/// <summary>
		/// Gets the ratio of the subscript height to the normal height of the font
		/// currently selected into the DC
		///</summary>
		/// <param name='_iNumerator'> </param>
		/// <param name='_iDenominator'> </param>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void GetSubscriptHeightRatio(out int _iNumerator, out int _iDenominator);

		/// <summary>
		/// Gets the ratio of the distance the subscript baseline is lowered to the
		/// normal height of the font currently selected into the DC
		///</summary>
		/// <param name='_iNumerator'> </param>
		/// <param name='_iDenominator'> </param>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void GetSubscriptYOffsetRatio(out int _iNumerator, out int _iDenominator);

		/// <summary>
		/// Set up to draw text using the properties specified.
		/// super/subscript are ignored, as is baseline adjust; client is
		/// presumed to have handled them. Sets colors and HFONT.
		///</summary>
		/// <param name='_chrp'> </param>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void SetupGraphics(ref LgCharRenderProps _chrp);

		/// <summary>
		/// Invoke a new clipping rectangle; the previous clipping state can be
		/// restored using PopClipRect.
		///</summary>
		/// <param name='rcClip'> </param>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void PushClipRect(Rect rcClip);

		/// <summary> </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void PopClipRect();

		/// <summary> Draw a filled polygon. Current properties set control border, fill, etc. </summary>
		/// <param name='cvpnt'> </param>
		/// <param name='_rgvpnt'> </param>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void DrawPolygon(int cvpnt, [MarshalAs(UnmanagedType.LPArray, SizeParamIndex=0)] System.Drawing.Point[] _rgvpnt);

		/// <summary> Render an IPicture using its Render method </summary>
		/// <param name='_pic'> The picture to render </param>
		/// <param name='x'>Horizontal position of image in hdc </param>
		/// <param name='y'>Vertical position of image in hdc </param>
		/// <param name='cx'>Horizontal dimension of destination rectangle </param>
		/// <param name='cy'>Vertical dimension of destination rectangle </param>
		/// <param name='xSrc'>Horizontal offset in source picture </param>
		/// <param name='ySrc'>Vertical offset in source picture </param>
		/// <param name='cxSrc'>Amount to copy horizontally in source picture </param>
		/// <param name='cySrc'>Amount to copy vertically in source picture </param>
		/// <param name='_rcWBounds'>Pointer to position of destination for a metafile hdc </param>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void RenderPicture([MarshalAs(UnmanagedType.Interface)] IPicture _pic, int x, int y, int cx, int cy, int xSrc, int ySrc, int cxSrc, int cySrc, ref Rect _rcWBounds);

		/// <summary>
		/// Make an IPicture object from binary data.
		/// This is currently implemented using OleLoadPicture, which is able to load binary
		/// data from any of the following:
		/// Bitmaps (.bmp); GIF Files (.gif); JPEG Files (.jpg); Icons (.ico);
		/// Enhanced Metafiles (.emf); Windows Metafiles (.wmf)
		/// Of these JPEG, gif, and bmp are probably the most important, in that order.
		/// For Mac support, we may decide to reduce the set.
		/// The file type is automatically detected from the data.
		///</summary>
		/// <param name='_bData'> </param>
		/// <param name='cbData'> </param>
		/// <returns></returns>
		[return: MarshalAs(UnmanagedType.Interface)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		IPicture MakePicture([MarshalAs(UnmanagedType.LPArray, SizeParamIndex=1)] byte[] _bData, int cbData);
	}

	/// <summary>
	/// Interface IVwGraphicsWin32
	/// Subclasses the IVwGraphics interface to provide Win32specific initialization. For other
	/// platforms, VwGraphics will need to be implemented with another initialization interface.
	///</summary>
	[ComImport()]
	[InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]
	[Guid("C955E295-A259-47D4-8158-4C7A3539D35E")]
	public interface IVwGraphicsWin32 : IVwGraphics
	{

		/// <summary>
		/// Invert the rectangle by performing a logical NOT operation on the color values for
		/// each pixel in the rectangle's interior.
		///</summary>
		/// <param name='xLeft'> </param>
		/// <param name='yTop'> </param>
		/// <param name='xRight'> </param>
		/// <param name='yBottom'> </param>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		new void InvertRect(int xLeft, int yTop, int xRight, int yBottom);

		/// <summary> Foreground color used for lines, text </summary>
		/// <returns>A System.Int32 </returns>
		new int ForeColor
		{
			[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
			set;
		}

		/// <summary> Background color used for shape interior, text background </summary>
		/// <returns>A System.Int32 </returns>
		new int BackColor
		{
			[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
			set;
		}

		/// <summary> draw a filled rectangle. Current properties set control border, fill, etc. </summary>
		/// <param name='xLeft'> </param>
		/// <param name='yTop'> </param>
		/// <param name='xRight'> </param>
		/// <param name='yBottom'> </param>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		new void DrawRectangle(int xLeft, int yTop, int xRight, int yBottom);

		/// <summary>
		/// Draw a horizontal line that may be dotted or dashed.
		/// Consider first the behavior if pdxStart is 0.
		/// If cdx is 0 or, equivalently, cdx is 1 and prgdx is MAXINT, it draws a regular line
		/// line DrawLine from (xLeft, y) to (xRight, y).
		/// If there are multiple dx values, the line is dashed. A segment of length prgdx[0] is
		/// first drawn, then a gap of length prgdx[1] is left, then a segment of length prgdx[2],
		/// and so forth until the specified width is reached (the last segment, if drawn, is
		/// truncated to the specified length).
		/// If all values in prgdx are used up, we start again at prgdx[0]. An odd number of segments
		/// means that on and off alternate; thus, for example, a single width may be used to create
		/// a dashed line with equal gaps and dashes.
		/// The function then sets pdxStart to the distance from xRight to the start of the last
		/// place where prgdx[0] was drawn (not where it was skipped, if there is an odd number).
		/// If pdxStart is not initially zero, it gives a distance to skip through prgdx before
		/// starting. The normal use is to pass the value returned from a previous call, which
		/// can be used to draw several adjacent segments and have them seem continuous. You can also
		/// leave a gap in a dashed line by adding its width to pdxStart.
		/// (Another good way to use pdxStart is to set it to xLeft. This causes all patterns
		/// to be aligned, as if they were segments of one continuous pattern from the left margin.)
		///</summary>
		/// <param name='xLeft'> </param>
		/// <param name='xRight'> </param>
		/// <param name='y'> </param>
		/// <param name='dyHeight'> </param>
		/// <param name='cdx'> </param>
		/// <param name='_rgdx'> </param>
		/// <param name='_dxStart'> </param>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		new void DrawHorzLine(int xLeft, int xRight, int y, int dyHeight, int cdx, [MarshalAs(UnmanagedType.LPArray, SizeParamIndex=4)] int[] _rgdx, ref int _dxStart);

		/// <summary> </summary>
		/// <param name='xLeft'> </param>
		/// <param name='yTop'> </param>
		/// <param name='xRight'> </param>
		/// <param name='yBottom'> </param>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		new void DrawLine(int xLeft, int yTop, int xRight, int yBottom);

		/// <summary> </summary>
		/// <param name='x'> </param>
		/// <param name='y'> </param>
		/// <param name='cch'> </param>
		/// <param name='_rgch'> </param>
		/// <param name='xStretch'> make the string this much wider than natural </param>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		new void DrawText(int x, int y, int cch, [MarshalAs(UnmanagedType.LPWStr)] string _rgch, int xStretch);

		/// <summary> </summary>
		/// <param name='x'> </param>
		/// <param name='y'> </param>
		/// <param name='cch'> </param>
		/// <param name='_rgchw'> </param>
		/// <param name='uOptions'> </param>
		/// <param name='_rect'> </param>
		/// <param name='_rgdx'> </param>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		new void DrawTextExt(int x, int y, int cch, [MarshalAs(UnmanagedType.LPWStr)] string _rgchw, uint uOptions, ref Rect _rect, int _rgdx);

		/// <summary> </summary>
		/// <param name='cch'> </param>
		/// <param name='_rgch'> </param>
		/// <param name='_x'> </param>
		/// <param name='_y'> </param>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		new void GetTextExtent(int cch, [MarshalAs(UnmanagedType.LPWStr)] string _rgch, out int _x, out int _y);

		/// <summary>
		/// Get the width of the text up to a certain char position,
		/// assuming the entire string was drawn with the given stretch.
		///</summary>
		/// <param name='cch'> </param>
		/// <param name='_rgch'> </param>
		/// <param name='ich'> </param>
		/// <param name='xStretch'> </param>
		/// <returns></returns>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		new int GetTextLeadWidth(int cch, [MarshalAs(UnmanagedType.LPWStr)] string _rgch, int ich, int xStretch);

		/// <summary> </summary>
		/// <param name='_xLeft'> </param>
		/// <param name='_yTop'> </param>
		/// <param name='_xRight'> </param>
		/// <param name='_yBottom'> </param>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		new void GetClipRect(out int _xLeft, out int _yTop, out int _xRight, out int _yBottom);

		/// <summary> The number of logical units corresponding to the font's emsquare </summary>
		/// <returns></returns>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		new int GetFontEmSquare();

		/// <summary> </summary>
		/// <param name='chw'> </param>
		/// <param name='_sBoundingWidth'> </param>
		/// <param name='_yBoundingHeight'> </param>
		/// <param name='_xBoundingX'> </param>
		/// <param name='_yBoundingY'> </param>
		/// <param name='_xAdvanceX'> </param>
		/// <param name='_yAdvanceY'> </param>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		new void GetGlyphMetrics(int chw, out int _sBoundingWidth, out int _yBoundingHeight, out int _xBoundingX, out int _yBoundingY, out int _xAdvanceX, out int _yAdvanceY);

		/// <summary> Return TrueType table data from font file selected in the dc. </summary>
		/// <param name='nTableId'> </param>
		/// <param name='_cbTableSz'> </param>
		/// <returns></returns>
		[return: MarshalAs(UnmanagedType.BStr)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		new string GetFontData(int nTableId, out int _cbTableSz);

		/// <summary> </summary>
		/// <param name='nTableId'> </param>
		/// <param name='_cbTableSz'> </param>
		/// <param name='_rgch'> </param>
		/// <param name='cchMax'> </param>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		new void GetFontDataRgch(int nTableId, out int _cbTableSz, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef=typeof(ArrayPtrMarshaler))] ArrayPtr/*OLECHAR[]*/ _rgch, int cchMax);

		/// <summary> </summary>
		/// <param name='chw'> </param>
		/// <param name='nPoint'> </param>
		/// <param name='_xRet'> </param>
		/// <param name='_yRet'> </param>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		new void XYFromGlyphPoint(int chw, int nPoint, out int _xRet, out int _yRet);

		/// <summary> </summary>
		/// <returns>A System.Int32 </returns>
		new int FontAscent
		{
			[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
			get;
		}

		/// <summary> </summary>
		/// <returns>A System.Int32 </returns>
		new int FontDescent
		{
			[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
			get;
		}

		/// <summary> </summary>
		/// <returns>A LgCharRenderProps </returns>
		new LgCharRenderProps FontCharProperties
		{
			[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
			get;
		}

		/// <summary>
		/// This interface is typically subclassed, as here in VwGraphicsWin32,
		/// with a method that provides it with a device context or analogous
		/// drawing environment. A call to ReleaseDC tells the VwGraphics that
		/// it must no longer use that graphics environment. Typically most
		/// calls will fail while no DC is available to work with.
		///</summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		new void ReleaseDC();

		/// <summary>
		/// Get the resolution of the device in logical units per inch.
		/// Defaults to the actual resolution, but may be set to
		/// something else (e.g., to produce zoom)
		/// Sets the resolution of the device in logical units per inch.
		///</summary>
		/// <returns>A System.Int32 </returns>
		new int XUnitsPerInch
		{
			[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
			get;
			[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
			set;
		}

		/// <summary>
		/// Get the resolution of the device in logical units per inch.
		/// Defaults to the actual resolution, but may be set to
		/// something else (e.g., to produce zoom)
		/// Sets the resolution of the device in logical units per inch.
		///</summary>
		/// <returns>A System.Int32 </returns>
		new int YUnitsPerInch
		{
			[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
			get;
			[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
			set;
		}

		/// <summary>
		/// Gets the ratio of the superscript height to the normal height of the font
		/// currently selected into the DC
		///</summary>
		/// <param name='_iNumerator'> </param>
		/// <param name='_iDenominator'> </param>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		new void GetSuperscriptHeightRatio(out int _iNumerator, out int _iDenominator);

		/// <summary>
		/// Gets the ratio of the distance the superscript baseline is raised to the
		/// normal height of the font currently selected into the DC
		///</summary>
		/// <param name='_iNumerator'> </param>
		/// <param name='_iDenominator'> </param>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		new void GetSuperscriptYOffsetRatio(out int _iNumerator, out int _iDenominator);

		/// <summary>
		/// Gets the ratio of the subscript height to the normal height of the font
		/// currently selected into the DC
		///</summary>
		/// <param name='_iNumerator'> </param>
		/// <param name='_iDenominator'> </param>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		new void GetSubscriptHeightRatio(out int _iNumerator, out int _iDenominator);

		/// <summary>
		/// Gets the ratio of the distance the subscript baseline is lowered to the
		/// normal height of the font currently selected into the DC
		///</summary>
		/// <param name='_iNumerator'> </param>
		/// <param name='_iDenominator'> </param>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		new void GetSubscriptYOffsetRatio(out int _iNumerator, out int _iDenominator);

		/// <summary>
		/// Set up to draw text using the properties specified.
		/// super/subscript are ignored, as is baseline adjust; client is
		/// presumed to have handled them. Sets colors and HFONT.
		///</summary>
		/// <param name='_chrp'> </param>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		new void SetupGraphics(ref LgCharRenderProps _chrp);

		/// <summary>
		/// Invoke a new clipping rectangle; the previous clipping state can be
		/// restored using PopClipRect.
		///</summary>
		/// <param name='rcClip'> </param>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		new void PushClipRect(Rect rcClip);

		/// <summary> </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		new void PopClipRect();

		/// <summary> Draw a filled polygon. Current properties set control border, fill, etc. </summary>
		/// <param name='cvpnt'> </param>
		/// <param name='_rgvpnt'> </param>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		new void DrawPolygon(int cvpnt, [MarshalAs(UnmanagedType.LPArray, SizeParamIndex=0)] System.Drawing.Point[] _rgvpnt);

		/// <summary> Render an IPicture using its Render method </summary>
		/// <param name='_pic'> The picture to render </param>
		/// <param name='x'>Horizontal position of image in hdc </param>
		/// <param name='y'>Vertical position of image in hdc </param>
		/// <param name='cx'>Horizontal dimension of destination rectangle </param>
		/// <param name='cy'>Vertical dimension of destination rectangle </param>
		/// <param name='xSrc'>Horizontal offset in source picture </param>
		/// <param name='ySrc'>Vertical offset in source picture </param>
		/// <param name='cxSrc'>Amount to copy horizontally in source picture </param>
		/// <param name='cySrc'>Amount to copy vertically in source picture </param>
		/// <param name='_rcWBounds'>Pointer to position of destination for a metafile hdc </param>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		new void RenderPicture([MarshalAs(UnmanagedType.Interface)] IPicture _pic, int x, int y, int cx, int cy, int xSrc, int ySrc, int cxSrc, int cySrc, ref Rect _rcWBounds);

		/// <summary>
		/// Make an IPicture object from binary data.
		/// This is currently implemented using OleLoadPicture, which is able to load binary
		/// data from any of the following:
		/// Bitmaps (.bmp); GIF Files (.gif); JPEG Files (.jpg); Icons (.ico);
		/// Enhanced Metafiles (.emf); Windows Metafiles (.wmf)
		/// Of these JPEG, gif, and bmp are probably the most important, in that order.
		/// For Mac support, we may decide to reduce the set.
		/// The file type is automatically detected from the data.
		///</summary>
		/// <param name='_bData'> </param>
		/// <param name='cbData'> </param>
		/// <returns></returns>
		[return: MarshalAs(UnmanagedType.Interface)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		new IPicture MakePicture([MarshalAs(UnmanagedType.LPArray, SizeParamIndex=1)] byte[] _bData, int cbData);

		/// <summary>
		/// Provide a device context on which to actually draw or measure.
		/// Note: it is permissible to initialize a VwGraphics repeatedly, with different DCs.
		/// Just call ReleaseDC when it ought to disconnect from the current one.
		///</summary>
		/// <param name='hdc'> </param>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void Initialize(System.IntPtr hdc);

		/// <summary> Recover the last hDC passed to Initialize. </summary>
		/// <returns></returns>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		System.IntPtr GetDeviceContext();

		/// <summary>
		/// Set a separate DC to be used for measuring operations (generally whatever is not
		/// supported in case the output DC is a metafile).
		///</summary>
		/// <param name='hdc'> </param>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void SetMeasureDc(System.IntPtr hdc);

		/// <summary>
		/// Set a clip rectangle, if it is not workable to read it from the HDC (e.g., because
		/// it is a metafile).
		///</summary>
		/// <param name='_rcClip'> </param>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void SetClipRect(ref Rect _rcClip);
	}

	#region VwGraphicsWin32 CoClass definitions
	/// <summary>
	/// Interface IVwGraphicsWin32
	/// Subclasses the IVwGraphics interface to provide Win32specific initialization. For other
	/// platforms, VwGraphics will need to be implemented with another initialization interface.
	///</summary>
	[ComImport()]
	[CoClass(typeof(_VwGraphicsWin32Class))]
	[Guid("C955E295-A259-47D4-8158-4C7A3539D35E")]
	public interface VwGraphicsWin32 : IVwGraphicsWin32
	{
	}

	#region Private _VwGraphicsWin32Class class
	/// <summary>_VwGraphicsWin32Class </summary>
	[ComImport()]
	[ClassInterface(ClassInterfaceType.None)]
	[TypeLibType(TypeLibTypeFlags.FCanCreate)]
	[Guid("D888DB98-83A9-4592-AAD2-F18F6F74AB87")]
	internal class _VwGraphicsWin32Class : IVwGraphicsWin32, VwGraphicsWin32
	{

		/// <summary>Member InvertRect </summary>
		/// <param name='xLeft'> </param>
		/// <param name='yTop'> </param>
		/// <param name='xRight'> </param>
		/// <param name='yBottom'> </param>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		public virtual extern void InvertRect(int xLeft, int yTop, int xRight, int yBottom);

		/// <summary>Sets a ForeColor </summary>
		/// <returns>A System.Int32 </returns>
		public virtual extern int ForeColor
		{
			[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
			set;
		}

		/// <summary>Sets a BackColor </summary>
		/// <returns>A System.Int32 </returns>
		public virtual extern int BackColor
		{
			[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
			set;
		}

		/// <summary>Member DrawRectangle </summary>
		/// <param name='xLeft'> </param>
		/// <param name='yTop'> </param>
		/// <param name='xRight'> </param>
		/// <param name='yBottom'> </param>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		public virtual extern void DrawRectangle(int xLeft, int yTop, int xRight, int yBottom);

		/// <summary>Member DrawHorzLine </summary>
		/// <param name='xLeft'> </param>
		/// <param name='xRight'> </param>
		/// <param name='y'> </param>
		/// <param name='dyHeight'> </param>
		/// <param name='cdx'> </param>
		/// <param name='_rgdx'> </param>
		/// <param name='_dxStart'> </param>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		public virtual extern void DrawHorzLine(int xLeft, int xRight, int y, int dyHeight, int cdx, [MarshalAs(UnmanagedType.LPArray, SizeParamIndex=4)] int[] _rgdx, ref int _dxStart);

		/// <summary>Member DrawLine </summary>
		/// <param name='xLeft'> </param>
		/// <param name='yTop'> </param>
		/// <param name='xRight'> </param>
		/// <param name='yBottom'> </param>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		public virtual extern void DrawLine(int xLeft, int yTop, int xRight, int yBottom);

		/// <summary>Member DrawText </summary>
		/// <param name='x'> </param>
		/// <param name='y'> </param>
		/// <param name='cch'> </param>
		/// <param name='_rgch'> </param>
		/// <param name='xStretch'> </param>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		public virtual extern void DrawText(int x, int y, int cch, [MarshalAs(UnmanagedType.LPWStr)] string _rgch, int xStretch);

		/// <summary>Member DrawTextExt </summary>
		/// <param name='x'> </param>
		/// <param name='y'> </param>
		/// <param name='cch'> </param>
		/// <param name='_rgchw'> </param>
		/// <param name='uOptions'> </param>
		/// <param name='_rect'> </param>
		/// <param name='_rgdx'> </param>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		public virtual extern void DrawTextExt(int x, int y, int cch, [MarshalAs(UnmanagedType.LPWStr)] string _rgchw, uint uOptions, ref Rect _rect, int _rgdx);

		/// <summary>Member GetTextExtent </summary>
		/// <param name='cch'> </param>
		/// <param name='_rgch'> </param>
		/// <param name='_x'> </param>
		/// <param name='_y'> </param>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		public virtual extern void GetTextExtent(int cch, [MarshalAs(UnmanagedType.LPWStr)] string _rgch, out int _x, out int _y);

		/// <summary>Member GetTextLeadWidth </summary>
		/// <param name='cch'> </param>
		/// <param name='_rgch'> </param>
		/// <param name='ich'> </param>
		/// <param name='xStretch'> </param>
		/// <returns>A System.Int32</returns>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		public virtual extern int GetTextLeadWidth(int cch, [MarshalAs(UnmanagedType.LPWStr)] string _rgch, int ich, int xStretch);

		/// <summary>Member GetClipRect </summary>
		/// <param name='_xLeft'> </param>
		/// <param name='_yTop'> </param>
		/// <param name='_xRight'> </param>
		/// <param name='_yBottom'> </param>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		public virtual extern void GetClipRect(out int _xLeft, out int _yTop, out int _xRight, out int _yBottom);

		/// <summary>Member GetFontEmSquare </summary>
		/// <returns>A System.Int32</returns>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		public virtual extern int GetFontEmSquare();

		/// <summary>Member GetGlyphMetrics </summary>
		/// <param name='chw'> </param>
		/// <param name='_sBoundingWidth'> </param>
		/// <param name='_yBoundingHeight'> </param>
		/// <param name='_xBoundingX'> </param>
		/// <param name='_yBoundingY'> </param>
		/// <param name='_xAdvanceX'> </param>
		/// <param name='_yAdvanceY'> </param>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		public virtual extern void GetGlyphMetrics(int chw, out int _sBoundingWidth, out int _yBoundingHeight, out int _xBoundingX, out int _yBoundingY, out int _xAdvanceX, out int _yAdvanceY);

		/// <summary>Member GetFontData </summary>
		/// <param name='nTableId'> </param>
		/// <param name='_cbTableSz'> </param>
		/// <returns>A System.String</returns>
		[return: MarshalAs(UnmanagedType.BStr)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		public virtual extern string GetFontData(int nTableId, out int _cbTableSz);

		/// <summary>Member GetFontDataRgch </summary>
		/// <param name='nTableId'> </param>
		/// <param name='_cbTableSz'> </param>
		/// <param name='_rgch'> </param>
		/// <param name='cchMax'> </param>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		public virtual extern void GetFontDataRgch(int nTableId, out int _cbTableSz, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef=typeof(ArrayPtrMarshaler))] ArrayPtr/*OLECHAR[]*/ _rgch, int cchMax);

		/// <summary>Member XYFromGlyphPoint </summary>
		/// <param name='chw'> </param>
		/// <param name='nPoint'> </param>
		/// <param name='_xRet'> </param>
		/// <param name='_yRet'> </param>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		public virtual extern void XYFromGlyphPoint(int chw, int nPoint, out int _xRet, out int _yRet);

		/// <summary>Gets a FontAscent </summary>
		/// <returns>A System.Int32 </returns>
		public virtual extern int FontAscent
		{
			[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
			get;
		}

		/// <summary>Gets a FontDescent </summary>
		/// <returns>A System.Int32 </returns>
		public virtual extern int FontDescent
		{
			[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
			get;
		}

		/// <summary>Gets a FontCharProperties </summary>
		/// <returns>A LgCharRenderProps </returns>
		public virtual extern LgCharRenderProps FontCharProperties
		{
			[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
			get;
		}

		/// <summary>Member ReleaseDC </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		public virtual extern void ReleaseDC();

		/// <summary>Gets/Sets a XUnitsPerInch </summary>
		/// <returns>A System.Int32 </returns>
		public virtual extern int XUnitsPerInch
		{
			[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
			get;
			[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
			set;
		}

		/// <summary>Gets/Sets a YUnitsPerInch </summary>
		/// <returns>A System.Int32 </returns>
		public virtual extern int YUnitsPerInch
		{
			[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
			get;
			[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
			set;
		}

		/// <summary>Member GetSuperscriptHeightRatio </summary>
		/// <param name='_iNumerator'> </param>
		/// <param name='_iDenominator'> </param>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		public virtual extern void GetSuperscriptHeightRatio(out int _iNumerator, out int _iDenominator);

		/// <summary>Member GetSuperscriptYOffsetRatio </summary>
		/// <param name='_iNumerator'> </param>
		/// <param name='_iDenominator'> </param>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		public virtual extern void GetSuperscriptYOffsetRatio(out int _iNumerator, out int _iDenominator);

		/// <summary>Member GetSubscriptHeightRatio </summary>
		/// <param name='_iNumerator'> </param>
		/// <param name='_iDenominator'> </param>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		public virtual extern void GetSubscriptHeightRatio(out int _iNumerator, out int _iDenominator);

		/// <summary>Member GetSubscriptYOffsetRatio </summary>
		/// <param name='_iNumerator'> </param>
		/// <param name='_iDenominator'> </param>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		public virtual extern void GetSubscriptYOffsetRatio(out int _iNumerator, out int _iDenominator);

		/// <summary>Member SetupGraphics </summary>
		/// <param name='_chrp'> </param>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		public virtual extern void SetupGraphics(ref LgCharRenderProps _chrp);

		/// <summary>Member PushClipRect </summary>
		/// <param name='rcClip'> </param>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		public virtual extern void PushClipRect(Rect rcClip);

		/// <summary>Member PopClipRect </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		public virtual extern void PopClipRect();

		/// <summary>Member DrawPolygon </summary>
		/// <param name='cvpnt'> </param>
		/// <param name='_rgvpnt'> </param>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		public virtual extern void DrawPolygon(int cvpnt, [MarshalAs(UnmanagedType.LPArray, SizeParamIndex=0)] System.Drawing.Point[] _rgvpnt);

		/// <summary>Member RenderPicture </summary>
		/// <param name='_pic'> </param>
		/// <param name='x'> </param>
		/// <param name='y'> </param>
		/// <param name='cx'> </param>
		/// <param name='cy'> </param>
		/// <param name='xSrc'> </param>
		/// <param name='ySrc'> </param>
		/// <param name='cxSrc'> </param>
		/// <param name='cySrc'> </param>
		/// <param name='_rcWBounds'> </param>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		public virtual extern void RenderPicture([MarshalAs(UnmanagedType.Interface)] IPicture _pic, int x, int y, int cx, int cy, int xSrc, int ySrc, int cxSrc, int cySrc, ref Rect _rcWBounds);

		/// <summary>Member MakePicture </summary>
		/// <param name='_bData'> </param>
		/// <param name='cbData'> </param>
		/// <returns>A IPicture</returns>
		[return: MarshalAs(UnmanagedType.Interface)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		public virtual extern IPicture MakePicture([MarshalAs(UnmanagedType.LPArray, SizeParamIndex=1)] byte[] _bData, int cbData);

		/// <summary>
		/// Provide a device context on which to actually draw or measure.
		/// Note: it is permissible to initialize a VwGraphics repeatedly, with different DCs.
		/// Just call ReleaseDC when it ought to disconnect from the current one.
		///</summary>
		/// <param name='hdc'> </param>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		public virtual extern void Initialize(System.IntPtr hdc);

		/// <summary> Recover the last hDC passed to Initialize. </summary>
		/// <returns></returns>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		public virtual extern System.IntPtr GetDeviceContext();

		/// <summary>
		/// Set a separate DC to be used for measuring operations (generally whatever is not
		/// supported in case the output DC is a metafile).
		///</summary>
		/// <param name='hdc'> </param>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		public virtual extern void SetMeasureDc(System.IntPtr hdc);

		/// <summary>
		/// Set a clip rectangle, if it is not workable to read it from the HDC (e.g., because
		/// it is a metafile).
		///</summary>
		/// <param name='_rcClip'> </param>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		public virtual extern void SetClipRect(ref Rect _rcClip);
	}
	#endregion

	/// <summary>VwGraphicsWin32Class </summary>
	public static class VwGraphicsWin32Class
	{

		/// <summary>Member Create </summary>
		/// <returns>A VwGraphicsWin32</returns>
		public static VwGraphicsWin32 Create()
		{
			return new _VwGraphicsWin32Class();
		}
	}
	#endregion

	/// <summary> Interface IVwTextSource </summary>
	[ComImport()]
	[InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]
	[Guid("6C0465AC-17C5-4C9C-8AF3-62221F2F7707")]
	public interface IVwTextSource
	{

		/// <summary>
		/// Get the specified range of chars. Note that there is no guarantee that all
		/// of these characters are in a particular old writing system.
		///</summary>
		/// <param name='ichMin'> </param>
		/// <param name='ichLim'> </param>
		/// <param name='_rgchBuf'> </param>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void Fetch(int ichMin, int ichLim, IntPtr _rgchBuf);

		/// <summary> </summary>
		/// <returns>A System.Int32 </returns>
		int Length
		{
			[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
			get;
		}

		/// <summary>
		/// Get all of the chars from the TxtSrc, eliminating owned ORC characters. Owned
		/// ORCs are special since they represent objects which are logically "owned" by
		/// the text. Therefore, when searching, they should be ignored for the purpose
		/// of identifying a match. Currently, owned ORCs include footnotes and embedded
		/// pictures. Use LengthSearch to get the count of characters to set the buffer size.
		///</summary>
		/// <param name='ichMin'> </param>
		/// <param name='ichLim'> </param>
		/// <param name='_rgchBuf'> </param>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void FetchSearch(int ichMin, int ichLim, IntPtr _rgchBuf);

		/// <summary> Like the Length property, but owned ORC characters will not be counted </summary>
		/// <returns>A System.Int32 </returns>
		int LengthSearch
		{
			[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
			get;
		}

		/// <summary>
		/// Get the actual text properties of the character at ich.
		/// Also obtain a range of characters guaranteed to have the same properties.
		/// Note that it is possible that more than this range of characters have the
		/// same properties. Ideally, the server would figure out how many characters
		/// really have all the same properties; however, the caller should be prepared
		/// to cope with a less smart client that just answers the length of a run, even
		/// if the next run does not differ in any way of interest to rendering.
		/// The range will always be nonempty, except that if the text source is empty,
		/// 0 may be passed as ich and will obtain char props for an empty range.
		///</summary>
		/// <param name='ich'> </param>
		/// <param name='_chrp'> </param>
		/// <param name='_ichMin'> </param>
		/// <param name='_ichLim'> </param>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void GetCharProps(int ich, out LgCharRenderProps _chrp, out int _ichMin, out int _ichLim);

		/// <summary> Similarly get paragraph level properties and the range for which they apply. </summary>
		/// <param name='ich'> </param>
		/// <param name='_chrp'> </param>
		/// <param name='_ichMin'> </param>
		/// <param name='_ichLim'> </param>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void GetParaProps(int ich, out LgParaRenderProps _chrp, out int _ichMin, out int _ichLim);

		/// <summary>
		/// This gets a string property. Some old writing systems may support using extra props
		/// as a way to vary appearance in ways unique to a particular old writing system,
		/// such as showing or hiding Greek breathings.
		/// It is possible we will eventually handle having the WS look for specified props.
		/// It is possible we will define a property in which we make available to the WS
		/// information like the reason for italics ('emphasized'; 'foreign LG'; 'book title').
		/// Renderers should be prepared not to get anything, or to get values not meaningful
		/// to them (intended for some other renderer).
		/// The property in question is stringvalued and applies to arbitrary char runs.
		///</summary>
		/// <param name='ich'> </param>
		/// <param name='nId'> which particular property we want (ENHANCE JohnT: which enumeration?) </param>
		/// <param name='_bstr'> </param>
		/// <param name='_ichMin'> </param>
		/// <param name='_ichLim'> </param>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void GetCharStringProp(int ich, int nId, [MarshalAs(UnmanagedType.BStr)] out string _bstr, out int _ichMin, out int _ichLim);

		/// <summary>
		/// Similar, but a property that is constrained to have the same value for all chars
		/// in a paragraph. Some ids may possibly allow both para and char level values.
		///</summary>
		/// <param name='ich'> </param>
		/// <param name='nId'> which particular property we want (ENHANCE JohnT: which enumeration?) </param>
		/// <param name='_bstr'> </param>
		/// <param name='_ichMin'> </param>
		/// <param name='_ichLim'> </param>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void GetParaStringProp(int ich, int nId, [MarshalAs(UnmanagedType.BStr)] out string _bstr, out int _ichMin, out int _ichLim);

		/// <summary>
		/// Get a TsString representing a range of the text of the input.
		/// This is not fully implemented by all text sources, especially if the range spans
		/// multiple strings. It is not required for rendering, but only for find/replace operations.
		///</summary>
		/// <param name='ichMin'> </param>
		/// <param name='ichLim'> </param>
		/// <returns></returns>
		[return: MarshalAs(UnmanagedType.Interface)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		ITsString GetSubString(int ichMin, int ichLim);

		/// <summary>
		/// Return a writing system factory to use to interpret the writing system information.
		///</summary>
		/// <returns></returns>
		[return: MarshalAs(UnmanagedType.Interface)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		ILgWritingSystemFactory GetWsFactory();

		/// <summary>
		/// Convert a logical to a search position.
		/// This is not required for rendering, but only for find/replace operations.
		///</summary>
		/// <param name='ichlog'> </param>
		/// <returns></returns>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		int LogToSearch(int ichlog);

		/// <summary>
		/// Convert a search to a logical position.
		/// This is not required for rendering, but only for find/replace operations.
		///</summary>
		/// <param name='ichSearch'> </param>
		/// <param name='fAssocPrev'>If an ichSearch position is specified that lands exactly on
		/// an omitted ORC, if this is true, then the position that is returned will be the
		/// ich position previous to the ORC, otherwise it will be the position that is after
		/// the ORC. </param>
		/// <returns></returns>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		int SearchToLog(int ichSearch, [MarshalAs(UnmanagedType.VariantBool)] bool fAssocPrev);

		/// <summary> convert a logical position to a render position </summary>
		/// <param name='ichLog'> </param>
		/// <returns></returns>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		int LogToRen(int ichLog);

		/// <summary> Convert a render position to a logical position </summary>
		/// <param name='ichRen'> </param>
		/// <returns></returns>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		int RenToLog(int ichRen);

		/// <summary> convert a search position to a render position </summary>
		/// <param name='ichSearch'> </param>
		/// <param name='fAssocPrev'>If an ichSearch position is specified that lands exactly on
		/// an omitted ORC, if this is true, then the position that is returned will be the
		/// ich position previous to the ORC, otherwise it will be the position that is after
		/// the ORC. </param>
		/// <returns></returns>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		int SearchToRen(int ichSearch, [MarshalAs(UnmanagedType.VariantBool)] bool fAssocPrev);

		/// <summary> Convert a render position to a search position </summary>
		/// <param name='ichRen'> </param>
		/// <returns></returns>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		int RenToSearch(int ichRen);
	}

	/// <summary>
	/// Interface IVwJustifier
	/// Interface to an object that knows how to make decisions about justification.
	///</summary>
	[ComImport()]
	[InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]
	[Guid("22D5E030-5239-4924-BF1B-6B4F2CBBABA5")]
	public interface IVwJustifier
	{

		/// <summary>
		/// Interact with the Graphite engine to adjust the widths of glyphs to achieve
		/// justification.
		/// Returns S_FALSE if we can't achieve the desired width.
		///</summary>
		/// <param name='_jren'> </param>
		/// <param name='iGlyphMin'> </param>
		/// <param name='iGlyphLim'> </param>
		/// <param name='dxCurrentWidth'> </param>
		/// <param name='dxDesiredWidth'> </param>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void AdjustGlyphWidths([MarshalAs(UnmanagedType.Interface)] IJustifyingRenderer _jren, int iGlyphMin, int iGlyphLim, float dxCurrentWidth, float dxDesiredWidth);
	}

	#region VwJustifier CoClass definitions
	/// <summary>
	/// Interface IVwJustifier
	/// Interface to an object that knows how to make decisions about justification.
	///</summary>
	[ComImport()]
	[CoClass(typeof(_VwJustifierClass))]
	[Guid("22D5E030-5239-4924-BF1B-6B4F2CBBABA5")]
	public interface VwJustifier : IVwJustifier
	{
	}

	#region Private _VwJustifierClass class
	/// <summary>_VwJustifierClass </summary>
	[ComImport()]
	[ClassInterface(ClassInterfaceType.None)]
	[TypeLibType(TypeLibTypeFlags.FCanCreate)]
	[Guid("D3E3ADB7-94CB-443B-BB8F-82A03BF850F3")]
	internal class _VwJustifierClass : IVwJustifier, VwJustifier
	{

		/// <summary>
		/// Interact with the Graphite engine to adjust the widths of glyphs to achieve
		/// justification.
		/// Returns S_FALSE if we can't achieve the desired width.
		///</summary>
		/// <param name='_jren'> </param>
		/// <param name='iGlyphMin'> </param>
		/// <param name='iGlyphLim'> </param>
		/// <param name='dxCurrentWidth'> </param>
		/// <param name='dxDesiredWidth'> </param>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		public virtual extern void AdjustGlyphWidths([MarshalAs(UnmanagedType.Interface)] IJustifyingRenderer _jren, int iGlyphMin, int iGlyphLim, float dxCurrentWidth, float dxDesiredWidth);
	}
	#endregion

	/// <summary>VwJustifierClass </summary>
	public static class VwJustifierClass
	{

		/// <summary>Member Create </summary>
		/// <returns>A VwJustifier</returns>
		public static VwJustifier Create()
		{
			return new _VwJustifierClass();
		}
	}
	#endregion

	/// <summary>
	/// Interface ILgSegment
	///  text segments constructed by the engine
	///  these implement much of its functionality
	///
	///  Segments support the possibility that the device context (VwGraphics) used to create
	///  them has different resolution, zoom factor, and exact text measurements than the
	///  one used to draw. Accordingly, routines responsible for actual drawing are given
	///  two rectangles, rcSrc and rdDst, which allow an appropriate transformation.
	///  The segment is internally laid out as if its top left corner were (0,0), and with
	///  any other measurements based on the device context used to create it and lay it
	///  out (referred to as source coordinates).
	///  To map a point from this to where it should actually be drawn, in the coordinate
	///  system of the VwGraphics where drawing will take place, we do the following:
	///  subtract rcSrc.Origin
	///  multiply by rcDst.
	///</summary>
	[ComImport()]
	[InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]
	[Guid("3818E245-6A0B-45A7-A5D6-52694931279E")]
	public interface ILgSegment
	{

		/// <summary> Draw the segment and compute its width in destination coords. </summary>
		/// <param name='ichBase'> </param>
		/// <param name='_vg'> </param>
		/// <param name='rcSrc'> </param>
		/// <param name='rcDst'> </param>
		/// <param name='dxdWidth'> </param>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void DrawText(int ichBase, [MarshalAs(UnmanagedType.Interface)] IVwGraphics _vg, Rect rcSrc, Rect rcDst, out int dxdWidth);

		/// <summary>
		/// Measurements and other properties. These may be cached. If wanting measurements
		/// with a different device context than when the segment was created or than when
		/// last calling ANY measurement routine, Recompute() must be called.
		///</summary>
		/// <param name='ichBase'> </param>
		/// <param name='_vg'> </param>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void Recompute(int ichBase, [MarshalAs(UnmanagedType.Interface)] IVwGraphics _vg);

		/// <summary> </summary>
		/// <param name='ichBase'> </param>
		/// <param name='_vg'> </param>
		/// <returns></returns>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		int get_Width(int ichBase, [MarshalAs(UnmanagedType.Interface)] IVwGraphics _vg);

		/// <summary> </summary>
		/// <param name='ichBase'> </param>
		/// <param name='_vg'> </param>
		/// <returns></returns>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		int get_RightOverhang(int ichBase, [MarshalAs(UnmanagedType.Interface)] IVwGraphics _vg);

		/// <summary> </summary>
		/// <param name='ichBase'> </param>
		/// <param name='_vg'> </param>
		/// <returns></returns>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		int get_LeftOverhang(int ichBase, [MarshalAs(UnmanagedType.Interface)] IVwGraphics _vg);

		/// <summary> </summary>
		/// <param name='ichBase'> </param>
		/// <param name='_vg'> </param>
		/// <returns></returns>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		int get_Height(int ichBase, [MarshalAs(UnmanagedType.Interface)] IVwGraphics _vg);

		/// <summary> </summary>
		/// <param name='ichBase'> </param>
		/// <param name='_vg'> </param>
		/// <returns></returns>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		int get_Ascent(int ichBase, [MarshalAs(UnmanagedType.Interface)] IVwGraphics _vg);

		/// <summary> </summary>
		/// <param name='ichBase'> </param>
		/// <param name='_vg'> </param>
		/// <param name='_x'> same as Width </param>
		/// <param name='_y'> same as Height </param>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void Extent(int ichBase, [MarshalAs(UnmanagedType.Interface)] IVwGraphics _vg, out int _x, out int _y);

		/// <summary>
		/// Compute the rectangle in destination coords which contains all the pixels
		/// drawn by this segment. This should be a sufficient rectangle to invalidate
		/// if this segment is about to be discarded and replaced by another.
		///</summary>
		/// <param name='ichBase'> </param>
		/// <param name='_vg'> </param>
		/// <param name='rcSrc'> </param>
		/// <param name='rcDst'> </param>
		/// <returns></returns>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		Rect BoundingRect(int ichBase, [MarshalAs(UnmanagedType.Interface)] IVwGraphics _vg, Rect rcSrc, Rect rcDst);

		/// <summary>
		/// Compute the width the segment would occupy if drawn with the specified
		/// parameters. Don't update cached width.
		///</summary>
		/// <param name='ichBase'> </param>
		/// <param name='_vg'> </param>
		/// <param name='rcSrc'> </param>
		/// <param name='rcDst'> </param>
		/// <param name='dxdWidth'> </param>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void GetActualWidth(int ichBase, [MarshalAs(UnmanagedType.Interface)] IVwGraphics _vg, Rect rcSrc, Rect rcDst, out int dxdWidth);

		/// <summary> How much the visible part of the segment exceeds the height. </summary>
		/// <param name='ichBase'> </param>
		/// <param name='_vg'> </param>
		/// <returns></returns>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		int get_AscentOverhang(int ichBase, [MarshalAs(UnmanagedType.Interface)] IVwGraphics _vg);

		/// <summary> </summary>
		/// <param name='ichBase'> </param>
		/// <param name='_vg'> </param>
		/// <returns></returns>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		int get_DescentOverhang(int ichBase, [MarshalAs(UnmanagedType.Interface)] IVwGraphics _vg);

		/// <summary> Return true if this segment is righttoleft. </summary>
		/// <param name='ichBase'> </param>
		/// <returns></returns>
		[return: MarshalAs(UnmanagedType.VariantBool)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		bool get_RightToLeft(int ichBase);

		/// <summary>
		/// Return the depth of embedding of direction changes. Also indicate if the segment
		/// has weak directionality and can change direction depending on its context.
		///</summary>
		/// <param name='ichBase'> </param>
		/// <param name='_nDepth'> </param>
		/// <returns></returns>
		[return: MarshalAs(UnmanagedType.VariantBool)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		bool get_DirectionDepth(int ichBase, out int _nDepth);

		/// <summary>
		/// Change the directionality of the segment. Return E_UNEXPECTED if the segment does
		/// not have weak directionality and therefore cannot be changed.
		///</summary>
		/// <param name='ichwBase'> </param>
		/// <param name='nNewDepth'> </param>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void SetDirectionDepth(int ichwBase, int nNewDepth);

		/// <summary> Get the cookies which identify the old writing system of the segment. </summary>
		/// <param name='ichBase'> </param>
		/// <returns></returns>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		int get_WritingSystem(int ichBase);

		/// <summary>
		/// The logical range of characters covered by the segment. This value should be exact
		/// at a old writing system or string boundary, but may be somewhat fuzzy at a linebreak,
		/// since characters may be reordered across such boundaries. The renderer is free to
		/// apply any definition it likes of where a linebreak occurs. This should always be
		/// the same value obtained from the renderer as pdichLimSeg.
		///</summary>
		/// <param name='ichBase'> </param>
		/// <returns></returns>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		int get_Lim(int ichBase);

		/// <summary>
		/// Indicates the last character of interest to this segment. The meaning of this is
		/// that no behavior of this segment will be affected if characters beyond that change.
		/// This does not necessarily mean that a different line break could not have been
		/// obtained by the renderer if characters beyond that change, just that a segment with
		/// the boundaries of this one would not behave differently.
		///</summary>
		/// <param name='ichBase'> </param>
		/// <returns></returns>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		int get_LimInterest(int ichBase);

		/// <summary> modifying the segment </summary>
		/// <param name='ichBase'> </param>
		/// <param name='_vg'> </param>
		/// <param name='fNewVal'> </param>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void set_EndLine(int ichBase, [MarshalAs(UnmanagedType.Interface)] IVwGraphics _vg, [MarshalAs(UnmanagedType.VariantBool)] bool fNewVal);

		/// <summary> </summary>
		/// <param name='ichBase'> </param>
		/// <param name='_vg'> </param>
		/// <param name='fNewVal'> </param>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void set_StartLine(int ichBase, [MarshalAs(UnmanagedType.Interface)] IVwGraphics _vg, [MarshalAs(UnmanagedType.VariantBool)] bool fNewVal);

		/// <summary> </summary>
		/// <param name='ichBase'> </param>
		/// <param name='_vg'> </param>
		/// <returns></returns>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		LgLineBreak get_StartBreakWeight(int ichBase, [MarshalAs(UnmanagedType.Interface)] IVwGraphics _vg);

		/// <summary> </summary>
		/// <param name='ichBase'> </param>
		/// <param name='_vg'> </param>
		/// <returns></returns>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		LgLineBreak get_EndBreakWeight(int ichBase, [MarshalAs(UnmanagedType.Interface)] IVwGraphics _vg);

		/// <summary> </summary>
		/// <param name='ichBase'> </param>
		/// <returns></returns>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		int get_Stretch(int ichBase);

		/// <summary> </summary>
		/// <param name='ichBase'> </param>
		/// <param name='xs'> </param>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void set_Stretch(int ichBase, int xs);

		/// <summary>
		/// Test whether IP at specified position is valid.
		/// If position is not in this segment, and there are following segments, may
		/// answer kipvrUnknown; client should then try subsequent segments.
		/// Note: This routine gives the finest possible granularity (where IPs can be
		/// rendered). Particular input methods may not support all the positions that
		/// the renderer says are valid. Compare ILgInputMethodEditor&gt;&gt;IsValidInsertionPoint.
		/// Clients should generally check both.
		///</summary>
		/// <param name='ichBase'> </param>
		/// <param name='_vg'> </param>
		/// <param name='ich'> </param>
		/// <returns></returns>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		LgIpValidResult IsValidInsertionPoint(int ichBase, [MarshalAs(UnmanagedType.Interface)] IVwGraphics _vg, int ich);

		/// <summary> </summary>
		/// <param name='ichBase'> </param>
		/// <param name='_vg'> </param>
		/// <param name='fBoundaryEnd'> asking about the logical end boundary? </param>
		/// <param name='fBoundaryRight'> asking about the physical right boundary? </param>
		/// <returns></returns>
		[return: MarshalAs(UnmanagedType.VariantBool)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		bool DoBoundariesCoincide(int ichBase, [MarshalAs(UnmanagedType.Interface)] IVwGraphics _vg, [MarshalAs(UnmanagedType.VariantBool)] bool fBoundaryEnd, [MarshalAs(UnmanagedType.VariantBool)] bool fBoundaryRight);

		/// <summary> </summary>
		/// <param name='ichBase'> </param>
		/// <param name='_vg'> </param>
		/// <param name='rcSrc'> as for DrawText </param>
		/// <param name='rcDst'> </param>
		/// <param name='ich'> must be valid </param>
		/// <param name='fAssocPrev'> primary associated with preceding character? </param>
		/// <param name='fOn'> turning on or off? Caller should alternate, on first. </param>
		/// <param name='dm'> </param>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void DrawInsertionPoint(int ichBase, [MarshalAs(UnmanagedType.Interface)] IVwGraphics _vg, Rect rcSrc, Rect rcDst, int ich, [MarshalAs(UnmanagedType.VariantBool)] bool fAssocPrev, [MarshalAs(UnmanagedType.VariantBool)] bool fOn, LgIPDrawMode dm);

		/// <summary> </summary>
		/// <param name='ichBase'> </param>
		/// <param name='_vg'> </param>
		/// <param name='rcSrc'> as for DrawText </param>
		/// <param name='rcDst'> </param>
		/// <param name='ich'> </param>
		/// <param name='fAssocPrev'> primary associated with preceding character? </param>
		/// <param name='dm'> </param>
		/// <param name='rectPrimary'> source coords </param>
		/// <param name='rectSecondary'> source coords; invalid if Ibeam drawn </param>
		/// <param name='_fPrimaryHere'> set true if this segment renders the primary IP </param>
		/// <param name='_fSecHere'> set true if this segment renders the secondary IP; </param>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void PositionsOfIP(int ichBase, [MarshalAs(UnmanagedType.Interface)] IVwGraphics _vg, Rect rcSrc, Rect rcDst, int ich, [MarshalAs(UnmanagedType.VariantBool)] bool fAssocPrev, LgIPDrawMode dm, out Rect rectPrimary, out Rect rectSecondary, [MarshalAs(UnmanagedType.VariantBool)] out bool _fPrimaryHere, [MarshalAs(UnmanagedType.VariantBool)] out bool _fSecHere);

		/// <summary> false if rectSecondary is invalid. </summary>
		/// <param name='ichBase'> </param>
		/// <param name='_vg'> </param>
		/// <param name='rcSrc'> as for DrawText </param>
		/// <param name='rcDst'> </param>
		/// <param name='ichMin'> must be valid </param>
		/// <param name='ichLim'> </param>
		/// <param name='ydTop'> of area to highlight if whole line height; </param>
		/// <param name='ydBottom'> includes half of interline spacing. </param>
		/// <param name='bOn'> </param>
		/// <param name='fIsLastLineOfSelection'> false if more lines follow in the selection </param>
		/// <returns> source coords; used to return the result</returns>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		Rect DrawRange(int ichBase, [MarshalAs(UnmanagedType.Interface)] IVwGraphics _vg, Rect rcSrc, Rect rcDst, int ichMin, int ichLim, int ydTop, int ydBottom, [MarshalAs(UnmanagedType.VariantBool)] bool bOn, [MarshalAs(UnmanagedType.VariantBool)] bool fIsLastLineOfSelection);

		/// <summary> </summary>
		/// <param name='ichBase'> </param>
		/// <param name='_vg'> </param>
		/// <param name='rcSrc'> as for DrawText </param>
		/// <param name='rcDst'> </param>
		/// <param name='ichMin'> </param>
		/// <param name='ichim'> </param>
		/// <param name='ydTop'> of area to highlight if whole line height; </param>
		/// <param name='ydBottom'> includes half of interline spacing. </param>
		/// <param name='fIsLastLineOfSelection'> false if more lines follow in the selection </param>
		/// <param name='rsBounds'> source coords; used to return the result </param>
		/// <returns>true if any part of range drawn by segment</returns>
		[return: MarshalAs(UnmanagedType.VariantBool)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		bool PositionOfRange(int ichBase, [MarshalAs(UnmanagedType.Interface)] IVwGraphics _vg, Rect rcSrc, Rect rcDst, int ichMin, int ichim, int ydTop, int ydBottom, [MarshalAs(UnmanagedType.VariantBool)] bool fIsLastLineOfSelection, out Rect rsBounds);

		/// <summary> </summary>
		/// <param name='ichBase'> </param>
		/// <param name='_vg'> </param>
		/// <param name='rcSrc'> as for DrawText </param>
		/// <param name='rcDst'> </param>
		/// <param name='_tdClickPosition'> dest coords </param>
		/// <param name='_ich'> </param>
		/// <param name='_fAssocPrev'> true if click was logically before indicated position </param>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void PointToChar(int ichBase, [MarshalAs(UnmanagedType.Interface)] IVwGraphics _vg, Rect rcSrc, Rect rcDst, System.Drawing.Point _tdClickPosition, out int _ich, [MarshalAs(UnmanagedType.VariantBool)] out bool _fAssocPrev);

		/// <summary> </summary>
		/// <param name='ichBase'> </param>
		/// <param name='_vg'> </param>
		/// <param name='_ich'> </param>
		/// <param name='_fAssocPrev'> primary associated with preceding character? </param>
		/// <param name='fRight'> direction of desired movement (physical) </param>
		/// <param name='fMovingIn'> to this segment; if so, initial pich meaningless </param>
		/// <param name='_fResult'> if false, try next segment or string </param>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void ArrowKeyPosition(int ichBase, [MarshalAs(UnmanagedType.Interface)] IVwGraphics _vg, ref int _ich, [MarshalAs(UnmanagedType.VariantBool)] ref bool _fAssocPrev, [MarshalAs(UnmanagedType.VariantBool)] bool fRight, [MarshalAs(UnmanagedType.VariantBool)] bool fMovingIn, [MarshalAs(UnmanagedType.VariantBool)] out bool _fResult);

		/// <summary> </summary>
		/// <param name='ichBase'> </param>
		/// <param name='_vg'> </param>
		/// <param name='_ich'> </param>
		/// <param name='fAssocPrevMatch'> T if we need a certain orientation of the result;
		/// F if pich=0 and moving within the same segment </param>
		/// <param name='fAssocPrevNeeded'> orientation needed </param>
		/// <param name='ichAnchor'> 1 if anchor is in a different segment </param>
		/// <param name='fRight'> direction of desired movement </param>
		/// <param name='fMovingIn'> to this segment? If so, initial pich meaningless </param>
		/// <param name='_fRet'> if false, try next seg or string </param>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void ExtendSelectionPosition(int ichBase, [MarshalAs(UnmanagedType.Interface)] IVwGraphics _vg, ref int _ich, [MarshalAs(UnmanagedType.VariantBool)] bool fAssocPrevMatch, [MarshalAs(UnmanagedType.VariantBool)] bool fAssocPrevNeeded, int ichAnchor, [MarshalAs(UnmanagedType.VariantBool)] bool fRight, [MarshalAs(UnmanagedType.VariantBool)] bool fMovingIn, [MarshalAs(UnmanagedType.VariantBool)] out bool _fRet);

		/// <summary>
		/// Used to find where underlines should be drawn.
		/// As usual, if cxdMax is zero, it just answers the number of slots needed
		/// to return the information.
		/// ENHANCE Johnt: should it also give a top position?
		///</summary>
		/// <param name='ichBase'> </param>
		/// <param name='_vg'> </param>
		/// <param name='ichMin'> </param>
		/// <param name='ichLim'> </param>
		/// <param name='rcSrc'> as for DrawText </param>
		/// <param name='rcDst'> true if white space should not be underlined. Some renderers may ignore this. </param>
		/// <param name='fSkipSpace'> </param>
		/// <param name='cxdMax'> number of ranges allowed </param>
		/// <param name='_cxd'> number of ranges made
		/// Each set of values gives left, right, and top of a place where an underline
		/// could be drawn. The top may overlap descenders, but should not overlap
		/// the baseline. To follow Word, normal and superscript segments put top about
		/// a pixel below the normal baseline, subscripts put it below the baseline
		/// of the subscript.
		/// Underline segments are in logical order. </param>
		/// <param name='_rgxdLefts'> </param>
		/// <param name='_rgxdRights'> </param>
		/// <param name='_rgydUnderTops'> </param>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void GetCharPlacement(int ichBase, [MarshalAs(UnmanagedType.Interface)] IVwGraphics _vg, int ichMin, int ichLim, Rect rcSrc, Rect rcDst, [MarshalAs(UnmanagedType.VariantBool)] bool fSkipSpace, int cxdMax, out int _cxd, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef=typeof(ArrayPtrMarshaler))] ArrayPtr/*int[]*/ _rgxdLefts, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef=typeof(ArrayPtrMarshaler))] ArrayPtr/*int[]*/ _rgxdRights, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef=typeof(ArrayPtrMarshaler))] ArrayPtr/*int[]*/ _rgydUnderTops);

		/// <summary>
		/// This method is used for something like a font testing program.
		/// Review (SharonC): should it be in a separate interface?
		/// HRESULT GetGlyphsAndPositions(
		///  [in] int ichBase,
		///  [in] IVwGraphics pvg,
		///  [in] RECT rcSrc,  as for DrawText
		///  [in] RECT rcDst,
		///  [in] int cchMax,
		///  [out] int pcchRet,
		///  [out, size_is(cchMax)] OLECHAR prgchGlyphs,
		///  [out, size_is(cchMax)] int prgxd,
		///  [out, size_is(cchMax)] int prgyd);
		/// This method is intended for debugging only. Eventually we can get rid of it, but
		/// it seems like it is useful to keep around for a while.
		/// HRESULT GetCharData(
		///  [in] int ichBase,
		///  [in] int cchMax,
		///  [out, size_is(cchMax)] OLECHAR prgch,
		///  [out] int pcchRet);
		/// Should do exactly the same as DrawText would do if all background
		/// colors were transparent. That is, no background is ever painted.
		///</summary>
		/// <param name='ichBase'> </param>
		/// <param name='_vg'> </param>
		/// <param name='rcSrc'> </param>
		/// <param name='rcDst'> </param>
		/// <param name='dxdWidth'> </param>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void DrawTextNoBackground(int ichBase, [MarshalAs(UnmanagedType.Interface)] IVwGraphics _vg, Rect rcSrc, Rect rcDst, out int dxdWidth);
	}

	/// <summary> Used to indicate how a segment (made by FindBreakPoint) ended. </summary>
	public enum LgEndSegmentType
	{

		/// <summary> No more segments are needed, everything in [ichMin, ichLim) fit. </summary>
		kestNoMore,

		/// <summary> We filled the line and need to put the rest of the text on another. </summary>
		kestMoreLines,

		/// <summary>
		/// We found a hard break, e.g., a tab or return. Depending on which
		/// character it is, something more may or may not go on this line.
		/// pdichLimSeg indicates the location of the hard break character.
		///</summary>
		kestHardBreak,

		/// <summary>
		/// We ended this segment for some reason (e.g., change of chrp) at a point
		/// that is not a valid line break. Client must either fit another segment
		/// on this line, or replace this segment with one that breaks sooner.
		///</summary>
		kestBadBreak,

		/// <summary>
		/// We ended this segment for some reason (e.g., change of chrp) at a point
		/// that is a valid line break; however, there may be room for more stuff
		/// on the line.
		///</summary>
		kestOkayBreak,

		/// <summary>
		/// We ended the segment because we hit the end of the writing system,
		/// or for some other reason (e.g., change of font) the subsequent
		/// characters need to be handled by a different renderer;
		/// the caller is responsible to determine if this is in fact a valid break,
		/// and whether there is room to put more stuff on the line.
		///</summary>
		kestWsBreak,

		/// <summary>
		/// We filled the line and need to put the rest of the text on another,
		/// but we didn't include the trailing whitespace in this segment; it needs
		/// its own segment that will go on the same line.
		///</summary>
		kestMoreWhtsp,

		/// <summary> Nothing fit so the segment is invalid. Only used within Graphite. </summary>
		kestNothingFit,
	}

	/// <summary>
	/// Interface IRenderEngine
	///  rendering engine: constructs segments and does a few other
	///  segmentindependent functions.
	///  Hungarian: reneng
	///</summary>
	[ComImport()]
	[InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]
	[Guid("7F4B8F79-2A40-408C-944B-848B14D65D23")]
	public interface IRenderEngine
	{

		/// <summary>
		/// Initialize the engine. This must be called before any oher methods of the interface.
		/// How the data is used is implementation dependent. The UniscribeRenderer does not
		/// use it at all. The Graphite renderer uses font name, bold, and italic settings
		/// to initialize itself with the proper font tables. For Graphite, bstrData contains
		/// (optionally) default settings for any font features.
		///</summary>
		/// <param name='_vg'> </param>
		/// <param name='bstrData'> </param>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void InitRenderer([MarshalAs(UnmanagedType.Interface)] IVwGraphics _vg, [MarshalAs(UnmanagedType.BStr)] string bstrData);

		/// <summary>
		/// Return an indication of whether the font is valid for the renderer.
		/// S_OK means it is valid, E_FAIL means the font was not available,
		/// E_UNEXPECTED means the font could not be used to initialize the renderer in the
		/// expected way (eg, the Graphite tables could not be found).
		/// Assumes InitNew() has already been called to set the font name.
		///</summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void FontIsValid();

		/// <summary>
		/// Give the maximum length of information that this renderer might want to pass
		/// from one segment to another in SimpleBreakPoint&gt;&gt;pbNextSegDat.
		/// An absolute maximum of 256 is imposed; this routine must not return a larger number.
		/// OBSOLETE currently not called by anything but test code.
		///</summary>
		/// <returns>A System.Int32 </returns>
		int SegDatMaxLength
		{
			[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
			get;
		}

		/// <summary> Make a segment. </summary>
		/// <param name='_vg'> </param>
		/// <param name='_ts'> </param>
		/// <param name='_vjus'> start making the segment at ichMin </param>
		/// <param name='ichMin'> Client guarantees that at least [0, ichLimText) characters are available from
		/// the IVwTextSource, but only ichMin is guaranteed to be in the correct WS.
		/// The renderer must not include characters from other writing systems in its
		/// segments, but may look at them (e.g., to help figure line breaks).
		/// The renderer should not include hard break characters in its segments. </param>
		/// <param name='ichLim'> When backtracking, indicates where to start looking for a valid breakpoint;
		/// when not backtracking, should be equal to ichLim. </param>
		/// <param name='ichLimBacktrack'> If this flag is false, assume it is OK to make a segment ending just before
		/// ichLim.
		/// If it is true, assume the text source has at least one more character at
		/// ichLim, and end the segment at ichLim only if that is a valid break point. </param>
		/// <param name='fNeedFinalBreak'> </param>
		/// <param name='fStartLine'> seg is logically first on line? </param>
		/// <param name='dxMaxWidth'> whatever coords pvg is using </param>
		/// <param name='lbPref'> try for longest seg of this weight </param>
		/// <param name='lbMax'> max if no preferred break possible </param>
		/// <param name='twsh'> how we are handling trailing whitespace </param>
		/// <param name='fParaRightToLeft'> overall paragraph direction </param>
		/// <param name='_psegRet'> segment produced, or null if nothing fits </param>
		/// <param name='_dichLimSeg'> offset to last char of segment, first of next if any </param>
		/// <param name='_dxWidth'> of new segment, if any </param>
		/// <param name='_est'> what caused the segment to end? </param>
		/// <param name='_segPrev'> for obtaining context </param>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void FindBreakPoint(
					[MarshalAs(UnmanagedType.Interface)] IVwGraphics _vg,
					[MarshalAs(UnmanagedType.Interface)] IVwTextSource _ts,
					[MarshalAs(UnmanagedType.Interface)] IVwJustifier _vjus,
					int ichMin,
					int ichLim,
					int ichLimBacktrack,
					[MarshalAs(UnmanagedType.VariantBool)] bool fNeedFinalBreak,
					[MarshalAs(UnmanagedType.VariantBool)] bool fStartLine,
					int dxMaxWidth,
					LgLineBreak lbPref,
					LgLineBreak lbMax,
					LgTrailingWsHandling twsh,
					[MarshalAs(UnmanagedType.VariantBool)] bool fParaRightToLeft,
					[MarshalAs(UnmanagedType.Interface)] out ILgSegment _psegRet,
					out int _dichLimSeg,
					out int _dxWidth,
					out LgEndSegmentType _est,
					[MarshalAs(UnmanagedType.Interface)] ILgSegment _segPrev);

		/// <summary>
		/// ENHANCE JohnT: we may need more entry points to handle smart (TeXstyle) para
		/// layout with attempts to optimize line breaks over the whole para.
		/// Return the supported script directions; usually there is only one.
		///</summary>
		/// <returns>A System.Int32 </returns>
		int ScriptDirection
		{
			[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
			get;
		}

		/// <summary> Return the CLSID of the implementation class. </summary>
		/// <returns>A System.Guid </returns>
		System.Guid ClassId
		{
			[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
			get;
		}

		/// <summary>
		/// Get the language writing system factory in use for this rendering engine.
		/// Set the language writing system factory to use with this rendering engine.
		///</summary>
		/// <returns>A ILgWritingSystemFactory </returns>
		ILgWritingSystemFactory WritingSystemFactory
		{
			[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
			[return: MarshalAs(UnmanagedType.Interface)]
			get;
			[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
			[param: MarshalAs(UnmanagedType.Interface)]
			set;
		}
	}

	#region RomRenderEngine CoClass definitions
	/// <summary>RomRenderEngine </summary>
	[ComImport()]
	[CoClass(typeof(_RomRenderEngineClass))]
	[Guid("7F4B8F79-2A40-408C-944B-848B14D65D23")]
	public interface RomRenderEngine : IRenderEngine
	{
	}

	#region Private _RomRenderEngineClass class
	/// <summary>_RomRenderEngineClass </summary>
	[ComImport()]
	[ClassInterface(ClassInterfaceType.None)]
	[TypeLibType(TypeLibTypeFlags.FCanCreate)]
	[Guid("6EACAB83-6BDC-49CA-8F66-8C116D3EEBD8")]
	internal class _RomRenderEngineClass : IRenderEngine, RomRenderEngine
	{

		/// <summary>
		/// Initialize the engine. This must be called before any oher methods of the interface.
		/// How the data is used is implementation dependent. The UniscribeRenderer does not
		/// use it at all. The Graphite renderer uses font name, bold, and italic settings
		/// to initialize itself with the proper font tables. For Graphite, bstrData contains
		/// (optionally) default settings for any font features.
		///</summary>
		/// <param name='_vg'> </param>
		/// <param name='bstrData'> </param>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		public virtual extern void InitRenderer([MarshalAs(UnmanagedType.Interface)] IVwGraphics _vg, [MarshalAs(UnmanagedType.BStr)] string bstrData);

		/// <summary>
		/// Return an indication of whether the font is valid for the renderer.
		/// S_OK means it is valid, E_FAIL means the font was not available,
		/// E_UNEXPECTED means the font could not be used to initialize the renderer in the
		/// expected way (eg, the Graphite tables could not be found).
		/// Assumes InitNew() has already been called to set the font name.
		///</summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		public virtual extern void FontIsValid();

		/// <summary>
		/// Give the maximum length of information that this renderer might want to pass
		/// from one segment to another in SimpleBreakPoint&gt;&gt;pbNextSegDat.
		/// An absolute maximum of 256 is imposed; this routine must not return a larger number.
		/// OBSOLETE currently not called by anything but test code.
		///</summary>
		/// <returns>A System.Int32 </returns>
		public virtual extern int SegDatMaxLength
		{
			[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
			get;
		}

		/// <summary> Make a segment. </summary>
		/// <param name='_vg'> </param>
		/// <param name='_ts'> </param>
		/// <param name='_vjus'> start making the segment at ichMin </param>
		/// <param name='ichMin'> Client guarantees that at least [0, ichLimText) characters are available from
		/// the IVwTextSource, but only ichMin is guaranteed to be in the correct WS.
		/// The renderer must not include characters from other writing systems in its
		/// segments, but may look at them (e.g., to help figure line breaks).
		/// The renderer should not include hard break characters in its segments. </param>
		/// <param name='ichLim'> When backtracking, indicates where to start looking for a valid breakpoint;
		/// when not backtracking, should be equal to ichLim. </param>
		/// <param name='ichLimBacktrack'> If this flag is false, assume it is OK to make a segment ending just before
		/// ichLim.
		/// If it is true, assume the text source has at least one more character at
		/// ichLim, and end the segment at ichLim only if that is a valid break point. </param>
		/// <param name='fNeedFinalBreak'> </param>
		/// <param name='fStartLine'> seg is logically first on line? </param>
		/// <param name='dxMaxWidth'> whatever coords pvg is using </param>
		/// <param name='lbPref'> try for longest seg of this weight </param>
		/// <param name='lbMax'> max if no preferred break possible </param>
		/// <param name='twsh'> how we are handling trailing whitespace </param>
		/// <param name='fParaRightToLeft'> overall paragraph direction </param>
		/// <param name='_psegRet'> segment produced, or null if nothing fits </param>
		/// <param name='_dichLimSeg'> offset to last char of segment, first of next if any </param>
		/// <param name='_dxWidth'> of new segment, if any </param>
		/// <param name='_est'> what caused the segment to end? </param>
		/// <param name='_segPrev'> for obtaining context </param>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		public virtual extern void FindBreakPoint(
					[MarshalAs(UnmanagedType.Interface)] IVwGraphics _vg,
					[MarshalAs(UnmanagedType.Interface)] IVwTextSource _ts,
					[MarshalAs(UnmanagedType.Interface)] IVwJustifier _vjus,
					int ichMin,
					int ichLim,
					int ichLimBacktrack,
					[MarshalAs(UnmanagedType.VariantBool)] bool fNeedFinalBreak,
					[MarshalAs(UnmanagedType.VariantBool)] bool fStartLine,
					int dxMaxWidth,
					LgLineBreak lbPref,
					LgLineBreak lbMax,
					LgTrailingWsHandling twsh,
					[MarshalAs(UnmanagedType.VariantBool)] bool fParaRightToLeft,
					[MarshalAs(UnmanagedType.Interface)] out ILgSegment _psegRet,
					out int _dichLimSeg,
					out int _dxWidth,
					out LgEndSegmentType _est,
					[MarshalAs(UnmanagedType.Interface)] ILgSegment _segPrev);

		/// <summary>
		/// ENHANCE JohnT: we may need more entry points to handle smart (TeXstyle) para
		/// layout with attempts to optimize line breaks over the whole para.
		/// Return the supported script directions; usually there is only one.
		///</summary>
		/// <returns>A System.Int32 </returns>
		public virtual extern int ScriptDirection
		{
			[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
			get;
		}

		/// <summary> Return the CLSID of the implementation class. </summary>
		/// <returns>A System.Guid </returns>
		public virtual extern System.Guid ClassId
		{
			[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
			get;
		}

		/// <summary>
		/// Get the language writing system factory in use for this rendering engine.
		/// Set the language writing system factory to use with this rendering engine.
		///</summary>
		/// <returns>A ILgWritingSystemFactory </returns>
		public virtual extern ILgWritingSystemFactory WritingSystemFactory
		{
			[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
			[return: MarshalAs(UnmanagedType.Interface)]
			get;
			[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
			[param: MarshalAs(UnmanagedType.Interface)]
			set;
		}
	}
	#endregion

	/// <summary>RomRenderEngineClass </summary>
	public static class RomRenderEngineClass
	{

		/// <summary>Member Create </summary>
		/// <returns>A RomRenderEngine</returns>
		public static RomRenderEngine Create()
		{
			return new _RomRenderEngineClass();
		}
	}
	#endregion

	#region UniscribeEngine CoClass definitions
	/// <summary>UniscribeEngine </summary>
	[ComImport()]
	[CoClass(typeof(_UniscribeEngineClass))]
	[Guid("7F4B8F79-2A40-408C-944B-848B14D65D23")]
	public interface UniscribeEngine : IRenderEngine
	{
	}

	#region Private _UniscribeEngineClass class
	/// <summary>_UniscribeEngineClass </summary>
	[ComImport()]
	[ClassInterface(ClassInterfaceType.None)]
	[TypeLibType(TypeLibTypeFlags.FCanCreate)]
	[Guid("1287735C-3CAD-41CD-986C-39D7C0DF0314")]
	internal class _UniscribeEngineClass : IRenderEngine, UniscribeEngine
	{

		/// <summary>
		/// Initialize the engine. This must be called before any oher methods of the interface.
		/// How the data is used is implementation dependent. The UniscribeRenderer does not
		/// use it at all. The Graphite renderer uses font name, bold, and italic settings
		/// to initialize itself with the proper font tables. For Graphite, bstrData contains
		/// (optionally) default settings for any font features.
		///</summary>
		/// <param name='_vg'> </param>
		/// <param name='bstrData'> </param>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		public virtual extern void InitRenderer([MarshalAs(UnmanagedType.Interface)] IVwGraphics _vg, [MarshalAs(UnmanagedType.BStr)] string bstrData);

		/// <summary>
		/// Return an indication of whether the font is valid for the renderer.
		/// S_OK means it is valid, E_FAIL means the font was not available,
		/// E_UNEXPECTED means the font could not be used to initialize the renderer in the
		/// expected way (eg, the Graphite tables could not be found).
		/// Assumes InitNew() has already been called to set the font name.
		///</summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		public virtual extern void FontIsValid();

		/// <summary>
		/// Give the maximum length of information that this renderer might want to pass
		/// from one segment to another in SimpleBreakPoint&gt;&gt;pbNextSegDat.
		/// An absolute maximum of 256 is imposed; this routine must not return a larger number.
		/// OBSOLETE currently not called by anything but test code.
		///</summary>
		/// <returns>A System.Int32 </returns>
		public virtual extern int SegDatMaxLength
		{
			[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
			get;
		}

		/// <summary> Make a segment. </summary>
		/// <param name='_vg'> </param>
		/// <param name='_ts'> </param>
		/// <param name='_vjus'> start making the segment at ichMin </param>
		/// <param name='ichMin'> Client guarantees that at least [0, ichLimText) characters are available from
		/// the IVwTextSource, but only ichMin is guaranteed to be in the correct WS.
		/// The renderer must not include characters from other writing systems in its
		/// segments, but may look at them (e.g., to help figure line breaks).
		/// The renderer should not include hard break characters in its segments. </param>
		/// <param name='ichLim'> When backtracking, indicates where to start looking for a valid breakpoint;
		/// when not backtracking, should be equal to ichLim. </param>
		/// <param name='ichLimBacktrack'> If this flag is false, assume it is OK to make a segment ending just before
		/// ichLim.
		/// If it is true, assume the text source has at least one more character at
		/// ichLim, and end the segment at ichLim only if that is a valid break point. </param>
		/// <param name='fNeedFinalBreak'> </param>
		/// <param name='fStartLine'> seg is logically first on line? </param>
		/// <param name='dxMaxWidth'> whatever coords pvg is using </param>
		/// <param name='lbPref'> try for longest seg of this weight </param>
		/// <param name='lbMax'> max if no preferred break possible </param>
		/// <param name='twsh'> how we are handling trailing whitespace </param>
		/// <param name='fParaRightToLeft'> overall paragraph direction </param>
		/// <param name='_psegRet'> segment produced, or null if nothing fits </param>
		/// <param name='_dichLimSeg'> offset to last char of segment, first of next if any </param>
		/// <param name='_dxWidth'> of new segment, if any </param>
		/// <param name='_est'> what caused the segment to end? </param>
		/// <param name='_segPrev'> for obtaining context </param>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		public virtual extern void FindBreakPoint(
					[MarshalAs(UnmanagedType.Interface)] IVwGraphics _vg,
					[MarshalAs(UnmanagedType.Interface)] IVwTextSource _ts,
					[MarshalAs(UnmanagedType.Interface)] IVwJustifier _vjus,
					int ichMin,
					int ichLim,
					int ichLimBacktrack,
					[MarshalAs(UnmanagedType.VariantBool)] bool fNeedFinalBreak,
					[MarshalAs(UnmanagedType.VariantBool)] bool fStartLine,
					int dxMaxWidth,
					LgLineBreak lbPref,
					LgLineBreak lbMax,
					LgTrailingWsHandling twsh,
					[MarshalAs(UnmanagedType.VariantBool)] bool fParaRightToLeft,
					[MarshalAs(UnmanagedType.Interface)] out ILgSegment _psegRet,
					out int _dichLimSeg,
					out int _dxWidth,
					out LgEndSegmentType _est,
					[MarshalAs(UnmanagedType.Interface)] ILgSegment _segPrev);

		/// <summary>
		/// ENHANCE JohnT: we may need more entry points to handle smart (TeXstyle) para
		/// layout with attempts to optimize line breaks over the whole para.
		/// Return the supported script directions; usually there is only one.
		///</summary>
		/// <returns>A System.Int32 </returns>
		public virtual extern int ScriptDirection
		{
			[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
			get;
		}

		/// <summary> Return the CLSID of the implementation class. </summary>
		/// <returns>A System.Guid </returns>
		public virtual extern System.Guid ClassId
		{
			[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
			get;
		}

		/// <summary>
		/// Get the language writing system factory in use for this rendering engine.
		/// Set the language writing system factory to use with this rendering engine.
		///</summary>
		/// <returns>A ILgWritingSystemFactory </returns>
		public virtual extern ILgWritingSystemFactory WritingSystemFactory
		{
			[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
			[return: MarshalAs(UnmanagedType.Interface)]
			get;
			[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
			[param: MarshalAs(UnmanagedType.Interface)]
			set;
		}
	}
	#endregion

	/// <summary>UniscribeEngineClass </summary>
	public static class UniscribeEngineClass
	{

		/// <summary>Member Create </summary>
		/// <returns>A UniscribeEngine</returns>
		public static UniscribeEngine Create()
		{
			return new _UniscribeEngineClass();
		}
	}
	#endregion

	#region FwGrEngine CoClass definitions
	/// <summary>FwGrEngine </summary>
	[ComImport()]
	[CoClass(typeof(_FwGrEngineClass))]
	[Guid("7F4B8F79-2A40-408C-944B-848B14D65D23")]
	public interface FwGrEngine : IRenderEngine
	{
	}

	#region Private _FwGrEngineClass class
	/// <summary>_FwGrEngineClass </summary>
	[ComImport()]
	[ClassInterface(ClassInterfaceType.None)]
	[TypeLibType(TypeLibTypeFlags.FCanCreate)]
	[Guid("F39F9433-F05A-4A19-8D1E-3C55DD607633")]
	internal class _FwGrEngineClass : IRenderEngine, FwGrEngine
	{

		/// <summary>
		/// Initialize the engine. This must be called before any oher methods of the interface.
		/// How the data is used is implementation dependent. The UniscribeRenderer does not
		/// use it at all. The Graphite renderer uses font name, bold, and italic settings
		/// to initialize itself with the proper font tables. For Graphite, bstrData contains
		/// (optionally) default settings for any font features.
		///</summary>
		/// <param name='_vg'> </param>
		/// <param name='bstrData'> </param>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		public virtual extern void InitRenderer([MarshalAs(UnmanagedType.Interface)] IVwGraphics _vg, [MarshalAs(UnmanagedType.BStr)] string bstrData);

		/// <summary>
		/// Return an indication of whether the font is valid for the renderer.
		/// S_OK means it is valid, E_FAIL means the font was not available,
		/// E_UNEXPECTED means the font could not be used to initialize the renderer in the
		/// expected way (eg, the Graphite tables could not be found).
		/// Assumes InitNew() has already been called to set the font name.
		///</summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		public virtual extern void FontIsValid();

		/// <summary>
		/// Give the maximum length of information that this renderer might want to pass
		/// from one segment to another in SimpleBreakPoint&gt;&gt;pbNextSegDat.
		/// An absolute maximum of 256 is imposed; this routine must not return a larger number.
		/// OBSOLETE currently not called by anything but test code.
		///</summary>
		/// <returns>A System.Int32 </returns>
		public virtual extern int SegDatMaxLength
		{
			[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
			get;
		}

		/// <summary> Make a segment. </summary>
		/// <param name='_vg'> </param>
		/// <param name='_ts'> </param>
		/// <param name='_vjus'> start making the segment at ichMin </param>
		/// <param name='ichMin'> Client guarantees that at least [0, ichLimText) characters are available from
		/// the IVwTextSource, but only ichMin is guaranteed to be in the correct WS.
		/// The renderer must not include characters from other writing systems in its
		/// segments, but may look at them (e.g., to help figure line breaks).
		/// The renderer should not include hard break characters in its segments. </param>
		/// <param name='ichLim'> When backtracking, indicates where to start looking for a valid breakpoint;
		/// when not backtracking, should be equal to ichLim. </param>
		/// <param name='ichLimBacktrack'> If this flag is false, assume it is OK to make a segment ending just before
		/// ichLim.
		/// If it is true, assume the text source has at least one more character at
		/// ichLim, and end the segment at ichLim only if that is a valid break point. </param>
		/// <param name='fNeedFinalBreak'> </param>
		/// <param name='fStartLine'> seg is logically first on line? </param>
		/// <param name='dxMaxWidth'> whatever coords pvg is using </param>
		/// <param name='lbPref'> try for longest seg of this weight </param>
		/// <param name='lbMax'> max if no preferred break possible </param>
		/// <param name='twsh'> how we are handling trailing whitespace </param>
		/// <param name='fParaRightToLeft'> overall paragraph direction </param>
		/// <param name='_psegRet'> segment produced, or null if nothing fits </param>
		/// <param name='_dichLimSeg'> offset to last char of segment, first of next if any </param>
		/// <param name='_dxWidth'> of new segment, if any </param>
		/// <param name='_est'> what caused the segment to end? </param>
		/// <param name='_segPrev'> for obtaining context </param>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		public virtual extern void FindBreakPoint(
					[MarshalAs(UnmanagedType.Interface)] IVwGraphics _vg,
					[MarshalAs(UnmanagedType.Interface)] IVwTextSource _ts,
					[MarshalAs(UnmanagedType.Interface)] IVwJustifier _vjus,
					int ichMin,
					int ichLim,
					int ichLimBacktrack,
					[MarshalAs(UnmanagedType.VariantBool)] bool fNeedFinalBreak,
					[MarshalAs(UnmanagedType.VariantBool)] bool fStartLine,
					int dxMaxWidth,
					LgLineBreak lbPref,
					LgLineBreak lbMax,
					LgTrailingWsHandling twsh,
					[MarshalAs(UnmanagedType.VariantBool)] bool fParaRightToLeft,
					[MarshalAs(UnmanagedType.Interface)] out ILgSegment _psegRet,
					out int _dichLimSeg,
					out int _dxWidth,
					out LgEndSegmentType _est,
					[MarshalAs(UnmanagedType.Interface)] ILgSegment _segPrev);

		/// <summary>
		/// ENHANCE JohnT: we may need more entry points to handle smart (TeXstyle) para
		/// layout with attempts to optimize line breaks over the whole para.
		/// Return the supported script directions; usually there is only one.
		///</summary>
		/// <returns>A System.Int32 </returns>
		public virtual extern int ScriptDirection
		{
			[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
			get;
		}

		/// <summary> Return the CLSID of the implementation class. </summary>
		/// <returns>A System.Guid </returns>
		public virtual extern System.Guid ClassId
		{
			[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
			get;
		}

		/// <summary>
		/// Get the language writing system factory in use for this rendering engine.
		/// Set the language writing system factory to use with this rendering engine.
		///</summary>
		/// <returns>A ILgWritingSystemFactory </returns>
		public virtual extern ILgWritingSystemFactory WritingSystemFactory
		{
			[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
			[return: MarshalAs(UnmanagedType.Interface)]
			get;
			[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
			[param: MarshalAs(UnmanagedType.Interface)]
			set;
		}
	}
	#endregion

	/// <summary>FwGrEngineClass </summary>
	public static class FwGrEngineClass
	{

		/// <summary>Member Create </summary>
		/// <returns>A FwGrEngine</returns>
		public static FwGrEngine Create()
		{
			return new _FwGrEngineClass();
		}
	}
	#endregion

	/// <summary>
	/// Interface IRenderingFeatures
	///  supported by rendering engines that allow the app to specify rendering features
	///  (font variations).
	///  Hungarian: rfeat
	///</summary>
	[ComImport()]
	[InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]
	[Guid("75AFE861-3C17-4F16-851F-A36F5FFABCC6")]
	public interface IRenderingFeatures
	{

		/// <summary>
		/// Return the number of features supported.
		/// [propget] HRESULT NumberOfFeatures(
		///  [out, retval] int pc);
		/// Return a list of the feature IDs. If cMax is zero, returns the number of features
		/// supported in pcfid.
		///</summary>
		/// <param name='cMax'> space available in the buffer </param>
		/// <param name='_rgFids'> buffer of IDs </param>
		/// <param name='_cfid'> how many returned </param>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void GetFeatureIDs(int cMax, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef=typeof(ArrayPtrMarshaler))] ArrayPtr/*int[]*/ _rgFids, out int _cfid);

		/// <summary> Return the UI label for the feature. </summary>
		/// <param name='fid'> </param>
		/// <param name='nLanguage'> </param>
		/// <param name='_bstrLabel'> </param>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void GetFeatureLabel(int fid, int nLanguage, [MarshalAs(UnmanagedType.BStr)] out string _bstrLabel);

		/// <summary>
		/// Return a list of recognized values for the given feature. If cfvalMax is zero,
		/// returns the number of values in pcfval.
		///</summary>
		/// <param name='fid'> </param>
		/// <param name='cfvalMax'> space available in the buffer </param>
		/// <param name='_rgfval'> list of values </param>
		/// <param name='_cfval'> how many returned </param>
		/// <param name='_fvalDefault'> default value </param>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void GetFeatureValues(int fid, int cfvalMax, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef=typeof(ArrayPtrMarshaler))] ArrayPtr/*int[]*/ _rgfval, out int _cfval, out int _fvalDefault);

		/// <summary> Return the UI label for the given feature value. </summary>
		/// <param name='fid'> </param>
		/// <param name='fval'> </param>
		/// <param name='nLanguage'> </param>
		/// <param name='_bstrLabel'> </param>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void GetFeatureValueLabel(int fid, int fval, int nLanguage, [MarshalAs(UnmanagedType.BStr)] out string _bstrLabel);
	}

	/// <summary>
	/// Interface IJustifyingRenderer
	///  Supported by rendering engines that interact with IVwJustifiers to accomplish
	///  justification.
	///  These methods return E_FAIL if the engine is not in a valid state to return
	///  the information.
	///  Hungarian: jren
	///</summary>
	[ComImport()]
	[InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]
	[Guid("1141174B-923F-4C43-BA43-8A326B76A3F2")]
	public interface IJustifyingRenderer
	{

		/// <summary> Returns E_INVALIDARG if the attribute is not one that can be read. </summary>
		/// <param name='iGlyph'> glyph index </param>
		/// <param name='kjgatId'> attribute ID </param>
		/// <param name='nLevel'> justification level </param>
		/// <param name='_ValueRet'> attribute value </param>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void GetGlyphAttributeFloat(int iGlyph, int kjgatId, int nLevel, out float _ValueRet);

		/// <summary> </summary>
		/// <param name='iGlyph'> glyph index </param>
		/// <param name='kjgatId'> attribute ID </param>
		/// <param name='nLevel'> justification level </param>
		/// <param name='_ValueRet'> attribute value </param>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void GetGlyphAttributeInt(int iGlyph, int kjgatId, int nLevel, out int _ValueRet);

		/// <summary> Returns E_INVALIDARG if the attribute is not one that can be set. </summary>
		/// <param name='iGlyph'> glyph index </param>
		/// <param name='kjgatId'> attribute ID </param>
		/// <param name='nLevel'> justification level </param>
		/// <param name='value'> attribute value </param>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void SetGlyphAttributeFloat(int iGlyph, int kjgatId, int nLevel, float value);

		/// <summary> </summary>
		/// <param name='iGlyph'> glyph index </param>
		/// <param name='kjgatId'> attribute ID </param>
		/// <param name='nLevel'> justification level </param>
		/// <param name='value'> attribute value </param>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void SetGlyphAttributeInt(int iGlyph, int kjgatId, int nLevel, int value);
	}

	#region FwGraphiteProcess CoClass definitions
	/// <summary>FwGraphiteProcess </summary>
	[ComImport()]
	[CoClass(typeof(_FwGraphiteProcessClass))]
	[Guid("1141174B-923F-4C43-BA43-8A326B76A3F2")]
	public interface FwGraphiteProcess : IJustifyingRenderer
	{
	}

	#region Private _FwGraphiteProcessClass class
	/// <summary>_FwGraphiteProcessClass </summary>
	[ComImport()]
	[ClassInterface(ClassInterfaceType.None)]
	[TypeLibType(TypeLibTypeFlags.FCanCreate)]
	[Guid("B56AEFB9-96B4-4415-8415-64CBF3826704")]
	internal class _FwGraphiteProcessClass : IJustifyingRenderer, FwGraphiteProcess
	{

		/// <summary> Returns E_INVALIDARG if the attribute is not one that can be read. </summary>
		/// <param name='iGlyph'> glyph index </param>
		/// <param name='kjgatId'> attribute ID </param>
		/// <param name='nLevel'> justification level </param>
		/// <param name='_ValueRet'> attribute value </param>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		public virtual extern void GetGlyphAttributeFloat(int iGlyph, int kjgatId, int nLevel, out float _ValueRet);

		/// <summary> </summary>
		/// <param name='iGlyph'> glyph index </param>
		/// <param name='kjgatId'> attribute ID </param>
		/// <param name='nLevel'> justification level </param>
		/// <param name='_ValueRet'> attribute value </param>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		public virtual extern void GetGlyphAttributeInt(int iGlyph, int kjgatId, int nLevel, out int _ValueRet);

		/// <summary> Returns E_INVALIDARG if the attribute is not one that can be set. </summary>
		/// <param name='iGlyph'> glyph index </param>
		/// <param name='kjgatId'> attribute ID </param>
		/// <param name='nLevel'> justification level </param>
		/// <param name='value'> attribute value </param>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		public virtual extern void SetGlyphAttributeFloat(int iGlyph, int kjgatId, int nLevel, float value);

		/// <summary> </summary>
		/// <param name='iGlyph'> glyph index </param>
		/// <param name='kjgatId'> attribute ID </param>
		/// <param name='nLevel'> justification level </param>
		/// <param name='value'> attribute value </param>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		public virtual extern void SetGlyphAttributeInt(int iGlyph, int kjgatId, int nLevel, int value);
	}
	#endregion

	/// <summary>FwGraphiteProcessClass </summary>
	public static class FwGraphiteProcessClass
	{

		/// <summary>Member Create </summary>
		/// <returns>A FwGraphiteProcess</returns>
		public static FwGraphiteProcess Create()
		{
			return new _FwGraphiteProcessClass();
		}
	}
	#endregion

	/// <summary>
	///:&gt;:&gt; Enumerations
	///:&gt; Main types of characters, as defined by Unicode and used by the character
	/// property engine.
	///</summary>
	public enum LgGeneralCharCategory
	{

		/// <summary> = Letter, Uppercase </summary>
		kccLu,

		/// <summary> = Letter, Lowercase </summary>
		kccLl,

		/// <summary> = Letter, Titlecase (e.g., Dz digraph as single code point) </summary>
		kccLt,

		/// <summary> = Letter, Modifier </summary>
		kccLm,

		/// <summary> = Letter, Other </summary>
		kccLo,

		/// <summary> = Mark, NonSpacing </summary>
		kccMn,

		/// <summary> = Mark, Spacing Combining </summary>
		kccMc,

		/// <summary> = Mark, Enclosing </summary>
		kccMe,

		/// <summary> = Number, Decimal Digit </summary>
		kccNd,

		/// <summary> = Number, Letter </summary>
		kccNl,

		/// <summary> = Number, Other </summary>
		kccNo,

		/// <summary> = Separator, Space </summary>
		kccZs,

		/// <summary> = Separator, Line </summary>
		kccZl,

		/// <summary> = Separator, Paragraph </summary>
		kccZp,

		/// <summary> = Other, Control </summary>
		kccCc,

		/// <summary> = Other, Format </summary>
		kccCf,

		/// <summary> = Other, Surrogate </summary>
		kccCs,

		/// <summary> = Other, Private Use </summary>
		kccCo,

		/// <summary> = Other, Not Assigned </summary>
		kccCn,

		/// <summary> = Punctuation, Connector </summary>
		kccPc,

		/// <summary> = Punctuation, Dash </summary>
		kccPd,

		/// <summary> = Punctuation, Open </summary>
		kccPs,

		/// <summary> = Punctuation, Close </summary>
		kccPe,

		/// <summary> = Punctuation, Initial quote (may behave like Ps or Pe depending </summary>
		kccPi,

		/// <summary>   on usage)
		/// = Punctuation, Final quote (may behave like Ps or Pe depending </summary>
		kccPf,

		/// <summary>   on usage)
		/// = Punctuation, Other </summary>
		kccPo,

		/// <summary> = Symbol, Math </summary>
		kccSm,

		/// <summary> = Symbol, Currency </summary>
		kccSc,

		/// <summary> = Symbol, Modifier </summary>
		kccSk,

		/// <summary> = Symbol, Other </summary>
		kccSo,
	}

	/// <summary>
	/// Hungarian: cc
	/// Unicode Bidirectional Categories, used by character property engine
	///</summary>
	public enum LgBidiCategory
	{

		/// <summary> Strong
		/// LeftRight; most alphabetic chars, etc. </summary>
		kbicL,

		/// <summary> LeftRight Embedding </summary>
		kbicLRE,

		/// <summary> LeftRight Override </summary>
		kbicLRO,

		/// <summary> RightLeft; Hebrew and its punctuation </summary>
		kbicR,

		/// <summary> RightLeft Arabic </summary>
		kbicAL,

		/// <summary> RightLeft Embedding </summary>
		kbicRLE,

		/// <summary> RightLeft Override </summary>
		kbicRLO,

		/// <summary> Pop Directional Format </summary>
		kbicPDF,

		/// <summary> Weak
		/// European Number </summary>
		kbicEN,

		/// <summary> European Number Separator </summary>
		kbicES,

		/// <summary> European Number Terminator </summary>
		kbicET,

		/// <summary> Arabic Number </summary>
		kbicAN,

		/// <summary> Common Number Separator </summary>
		kbicCS,

		/// <summary> Separators:
		/// NonSpacing Mark </summary>
		kbicNSM,

		/// <summary> Boundary Neutral </summary>
		kbicBN,

		/// <summary> Paragraph Separator </summary>
		kbicB,

		/// <summary> Segment Separator </summary>
		kbicS,

		/// <summary> Neutrals:
		/// Whitespace </summary>
		kbicWS,

		/// <summary> Other Neutrals ; All other characters: punctuation, symbols </summary>
		kbicON,
	}

	/// <summary> Hungarian: bic
	/// Line Breaking Character classes defined by Unicode. </summary>
	public enum LgLBP
	{

		/// <summary> '' indicates normative property
		/// 0  Ambiguous (Alphabetic or Ideographic) </summary>
		klbpAI,

		/// <summary> 1  Ordinary Alphabetic </summary>
		klbpAL,

		/// <summary> 2  Break Opportunity Before and After </summary>
		klbpB2,

		/// <summary> 3  Break Opportunity After </summary>
		klbpBA,

		/// <summary> 4  Break Opportunity Before </summary>
		klbpBB,

		/// <summary> 5 Mandatory Break </summary>
		klbpBK,

		/// <summary> 6 Contingent Break Opportunity </summary>
		klbpCB,

		/// <summary> 7  Closing </summary>
		klbpCL,

		/// <summary> 8 Combining Marks </summary>
		klbpCM,

		/// <summary> 9 Carriage Return </summary>
		klbpCR,

		/// <summary> 10  Exclamation </summary>
		klbpEX,

		/// <summary> 11 Nonbreaking ("Glue") </summary>
		klbpGL,

		/// <summary> 12  Hyphen </summary>
		klbpHY,

		/// <summary> 13  Ideographic </summary>
		klbpID,

		/// <summary> 14  Inseparable </summary>
		klbpIN,

		/// <summary> 15  Infix Separator (Numeric) </summary>
		klbpIS,

		/// <summary> 16 Line Feed </summary>
		klbpLF,

		/// <summary> 17  Non Starter </summary>
		klbpNS,

		/// <summary> 18  Numeric </summary>
		klbpNU,

		/// <summary> 19  Opening </summary>
		klbpOP,

		/// <summary> 20  Postfix (Numeric) </summary>
		klbpPO,

		/// <summary> 21  Prefix (Numeric) </summary>
		klbpPR,

		/// <summary> 22  Ambiguous Quotation </summary>
		klbpQU,

		/// <summary> 23  Complex Context </summary>
		klbpSA,

		/// <summary> 24 Surrogates </summary>
		klbpSG,

		/// <summary> 25 Space </summary>
		klbpSP,

		/// <summary> 26  Symbols Allowing Breaks </summary>
		klbpSY,

		/// <summary> 27  Unknown (used for unassigned characters) </summary>
		klbpXX,

		/// <summary> 28 Zero Width Space </summary>
		klbpZW,
	}

	/// <summary> Hungarian lbp
	/// Character decomposition tags </summary>
	public enum LgDecompMapTag
	{

		/// <summary> </summary>
		kdtNoTag,

		/// <summary> </summary>
		kdtFont,

		/// <summary> </summary>
		kdtNoBreak,

		/// <summary> </summary>
		kdtInitial,

		/// <summary> </summary>
		kdtMedial,

		/// <summary> </summary>
		kdtFinal,

		/// <summary> </summary>
		kdtIsolated,

		/// <summary> </summary>
		kdtCircle,

		/// <summary> </summary>
		kdtSuper,

		/// <summary> </summary>
		kdtSub,

		/// <summary> </summary>
		kdtVertical,

		/// <summary> </summary>
		kdtWide,

		/// <summary> </summary>
		kdtNarrow,

		/// <summary> </summary>
		kdtSmall,

		/// <summary> </summary>
		kdtSquare,

		/// <summary> </summary>
		kdtFraction,

		/// <summary> </summary>
		kdtCompat,
	}

	/// <summary> Hungarian dt
	/// XML tags </summary>
	public enum LgXMLTag
	{

		/// <summary> </summary>
		kxmlInvalid,

		/// <summary> </summary>
		kxmlChardefs,

		/// <summary> </summary>
		kxmlDef,

		/// <summary> </summary>
		kxmlUdata,

		/// <summary> </summary>
		kxmlLinebrk,
	}

	/// <summary>
	/// Interface ILgWritingSystem
	/// An LgWritingSystem represents one way of writing data in a particular language
	/// (or dialect). It has a number of engines which implement various aspects of writing
	/// system behavior.
	///
	/// ENHANCE: May need some more 'documentation' type attributes, such as
	/// an author, region, countrywhat exactly is useful?
	///
	/// <h3>When to implement</h3>
	/// Clients should not implement this interface.
	///
	/// <h3>When to use</h3>
	/// Use this class when you need to get one of the engines or other bits of information
	/// it stores about an writing system. In some cases, if you need only one engine, it is
	/// simpler to ask the <c>LgWritingSystemFactory</c> for it in a single step.
	///
	/// Don't use an ILgWritingSystem when you just need to identify an writing system, but
	/// don't actually need any of the engines. Use the integer which stands for the writing
	/// system.
	///
	/// <h3>How to obtain an instance</h3>
	/// Normally, use the get_Engine method of an <c>LgWritingSystemFactory</c>. This will create
	/// and writing system with all default engines if one does not already exist. To avoid
	/// this, use get_EngineOrNull instead.
	///
	/// Hungarian: <c>ws or wseng</c>
	/// (Note: use wseng when you need to distinguish the interface/object from the writing
	/// system's integer code, which uses ws as its Hungarian.)
	///</summary>
	[ComImport()]
	[InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]
	[Guid("9F74A170-E8BB-466d-8848-5FDB28AC5AF8")]
	public interface ILgWritingSystem
	{

		/// <summary> The identifier for this writing system. </summary>
		/// <returns>A System.String </returns>
		string Id
		{
			[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
			[return: MarshalAs(UnmanagedType.BStr)]
			get;
		}

		/// <summary>
		/// GET THE WRITING SYSTEM INTEGER that identifies this writing system to classes which
		/// don't actually need to use its methods
		///</summary>
		/// <returns>A System.Int32 </returns>
		int Handle
		{
			[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
			get;
		}

		/// <summary> Get the language name. </summary>
		/// <returns>A System.String </returns>
		string LanguageName
		{
			[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
			[return: MarshalAs(UnmanagedType.BStr)]
			get;
		}

		/// <summary> Get the ISO 6393 language code (Ethnologue code). </summary>
		/// <returns>A System.String </returns>
		string ISO3
		{
			[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
			[return: MarshalAs(UnmanagedType.BStr)]
			get;
		}

		/// <summary>
		/// Get the locale assigned to this writing system.
		/// Set the locale for this writing system.
		///</summary>
		/// <returns>A System.Int32 </returns>
		int LCID
		{
			[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
			get;
			[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
			set;
		}

		/// <summary>
		/// Get the name of the spelling dictionary to use for this writing system.
		/// Currently returns a generallyuseful default, unless explicitly set to empty
		/// to prevent this.
		/// Set the name of the spelling dictionary to use for this writing system.
		/// Eventually we plan to persist this fully; for now, it is useful only for setting
		/// to null to disable it for this session.
		///</summary>
		/// <returns>A System.String </returns>
		string SpellCheckingId
		{
			[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
			[return: MarshalAs(UnmanagedType.BStr)]
			get;
			[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
			[param: MarshalAs(UnmanagedType.BStr)]
			set;
		}

		/// <summary>
		/// Get the primary direction, used for complex embedding; may have fragments like
		/// numbers that go the other way internally.
		/// Set the primary direction, used for complex embedding; may have fragments like
		/// numbers that go the other way internally.
		///</summary>
		/// <returns>A System.Boolean </returns>
		bool RightToLeftScript
		{
			[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
			[return: MarshalAs(UnmanagedType.VariantBool)]
			get;
			[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
			[param: MarshalAs(UnmanagedType.VariantBool)]
			set;
		}

		/// <summary>
		/// Get the engine used to render text with the specified properties. At present only
		/// font, bold, and italic properties are significant.
		/// Font name may be '&lt;default serif&gt;' which produces a renderer suitable for the default
		/// serif font.
		///</summary>
		/// <param name='_vg'> </param>
		/// <returns></returns>
		[return: MarshalAs(UnmanagedType.Interface)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		IRenderEngine get_Renderer([MarshalAs(UnmanagedType.Interface)] IVwGraphics _vg);

		/// <summary>
		/// Get the "serif font variation" string which is used, for instance, to specify
		/// Graphite features.
		/// Set the "serif font variation" string which is used, for instance, to specify
		/// Graphite features.
		///</summary>
		/// <returns>A System.String </returns>
		string DefaultFontFeatures
		{
			[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
			[return: MarshalAs(UnmanagedType.BStr)]
			get;
			[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
			[param: MarshalAs(UnmanagedType.BStr)]
			set;
		}

		/// <summary>
		/// Get the default serif font; usually used for the main body of text in a document.
		/// Set the default serif font; usually used for the main body of text in a document.
		///</summary>
		/// <returns>A System.String </returns>
		string DefaultFontName
		{
			[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
			[return: MarshalAs(UnmanagedType.BStr)]
			get;
			[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
			[param: MarshalAs(UnmanagedType.BStr)]
			set;
		}

		/// <summary>
		/// Get the engine used to find character properties, including figuring out where line
		/// breaks are allowed.
		///</summary>
		/// <returns>A ILgCharacterPropertyEngine </returns>
		ILgCharacterPropertyEngine CharPropEngine
		{
			[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
			[return: MarshalAs(UnmanagedType.Interface)]
			get;
		}

		/// <summary>
		/// Apply any changes to the chrp before it is used for real: currently,
		/// interpret the magic font names.
		///</summary>
		/// <param name='_chrp'> </param>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void InterpretChrp(ref LgCharRenderProps _chrp);

		/// <summary>
		/// A Keyman keyboard name that should be used to invoke the appropriate
		/// Keyman keyboard if the writing sytem requires it. Leave as empty string
		/// for nonKeyman IMs.
		///</summary>
		/// <returns>A System.String </returns>
		string Keyboard
		{
			[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
			[return: MarshalAs(UnmanagedType.BStr)]
			get;
			[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
			[param: MarshalAs(UnmanagedType.BStr)]
			set;
		}

		/// <summary>
		/// The current input language. By default this is derived from LCID, but it can be
		/// overridden temporarily (for one session). Note that this is not persisted.
		/// Set the current (temporary) LangId for this writing system.
		///</summary>
		/// <returns>A System.Int32 </returns>
		int CurrentLCID
		{
			[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
			get;
			[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
			set;
		}
	}

	/// <summary>
	/// Interface ILgInputMethodEditor
	/// Functions related to special ways of typing for exotic writing systems.
	/// The <c>Setup</c> method is called before the user types something and may do things at the
	/// system level (such as setting the current system IME or Keyman file) to change what is
	/// received through WM_CHAR. The other methods allow postprocessing of what is received
	/// through WM_CHAR.
	///
	/// <h3>When to implement</h3>
	/// Clients should not normally implement this interface. Standard implementations are in
	/// Language.dll. If you have a very unusual input method requirement, you could make your
	/// own implementation.
	///
	/// Note: current FieldWorks code is <i>not</i> using this approach to typing. Check out
	/// <see href="intranet.sil.org/softwaredev/project_status.htm">intranet.sil.org/softwaredev/project_status.htm</see> to see if there are any plans.
	///
	/// <h3>When to use</h3>
	/// Most programmers will not use this interface directly. It is used by the Views
	/// subsystem and controls that accept typing in vernacular scripts.
	///
	/// <h3>How to obtain an instance</h3>
	/// At present, you can't. Eventually OldWritingSystem will implement a method. Some
	/// implemenations may also be available through CoCreateInstance.
	///
	/// Hungarian: <c>ime</c>
	///</summary>
	[ComImport()]
	[InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]
	[Guid("E1B27A5F-DD1B-4BBA-9B72-00BDE03162FC")]
	public interface ILgInputMethodEditor
	{

		/// <summary>
		/// GET THE SYSTEM READY TO use this input method; for example, switch Keyman to the
		/// proper table.
		///</summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void Setup();

		/// <summary>
		/// Given something the user typed, following any preprocessing that happens
		/// automatically as a result of Setup (e.g., Keyman processing), do any further
		/// processing required to actually replace the selected part of the string with what
		/// the user typed.
		/// The default implementation just replaces characters from ichMin to ichLim with
		/// those from bstrInput, then sets pichModMin to ichMin, and pichModLim and
		/// pichIP both to ichMin + BstrLen(bstrInput).
		///</summary>
		/// <param name='bstrInput'>What the user typed. </param>
		/// <param name='_ttpInput'>Text properties desired for new text </param>
		/// <param name='_tsbOld'>Original, unedited text, gets modified by this method </param>
		/// <param name='ichMin'>Range in old ptsbOld to replace </param>
		/// <param name='ichLim'>Range in old ptsbOld to replace </param>
		/// <param name='_ichModMin'>Range in modified ptsbOld that is different from before </param>
		/// <param name='_ichModLim'>Range in modified ptsbOld that is different from before </param>
		/// <param name='_ichIP'>Position of insertion point in modified string
		/// The result is the modified string represented by ptsbOld. </param>
		/// <exception cref="ArgumentException">ichMin/Lim is not a valid range within ptsbOld (E_INVALIDARG)</exception>
		[Obsolete("Can\'t call COM method marked with [local] attribute in IDL file")]
		[TypeLibFunc(TypeLibFuncFlags.FRestricted)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void Replace([MarshalAs(UnmanagedType.BStr)] string bstrInput, [MarshalAs(UnmanagedType.Interface)] ITsTextProps _ttpInput, [MarshalAs(UnmanagedType.Interface)] ITsStrBldr _tsbOld, int ichMin, int ichLim, out int _ichModMin, out int _ichModLim, out int _ichIP);

		/// <summary>
		/// The user pressed a certain number of backspaces. Delete an appropriate amount of
		/// the string represented by the input string builder, indicating exactly what changed.
		/// Also, if there were not enough characters to delete, indicate how many backspaces
		/// were left over.
		///</summary>
		/// <param name='_ichStart'>start position (delete characters before here) </param>
		/// <param name='cactBackspace'>number of backspaces pressed </param>
		/// <param name='_tsbOld'>the text being edited; gets changed by this call </param>
		/// <param name='_ichModMin'>range in output text affected </param>
		/// <param name='_ichModLim'>range in output text affected </param>
		/// <param name='_ichIP'>position of IP in modified string </param>
		/// <param name='_cactBsRemaining'>Number not handled, caller should apply to previous run or
		/// string </param>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void Backspace(int _ichStart, int cactBackspace, [MarshalAs(UnmanagedType.Interface)] ITsStrBldr _tsbOld, out int _ichModMin, out int _ichModLim, out int _ichIP, out int _cactBsRemaining);

		/// <summary>
		/// The user pressed a certain number of delete forward characters. Compute the effect on
		/// ptsbInOut
		/// Also, if there were not enough characters to delete, indicate how many backspaces
		/// were left over.
		///</summary>
		/// <param name='_ichStart'>start position (delete characters after here) </param>
		/// <param name='cactDelForward'>number of DF pressed </param>
		/// <param name='_tsbInOut'>the text being edited; gets changed by this call </param>
		/// <param name='_ichModMin'>range in output text affected </param>
		/// <param name='_ichModLim'>range in output text affected </param>
		/// <param name='_ichIP'>position of IP in modified string </param>
		/// <param name='_cactDfRemaining'>Number not handled, caller should apply to next run or string </param>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void DeleteForward(int _ichStart, int cactDelForward, [MarshalAs(UnmanagedType.Interface)] ITsStrBldr _tsbInOut, out int _ichModMin, out int _ichModLim, out int _ichIP, out int _cactDfRemaining);

		/// <summary>
		/// Return true if input method considers an IP at the specified index reasonable.
		/// Note that really useful IPs should also satisfy the Renderer; see
		/// <c>ILgSegment.IsValidInsertionPoint</c>.
		///</summary>
		/// <param name='ich'> </param>
		/// <param name='_tss'> </param>
		/// <returns></returns>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		int IsValidInsertionPoint(int ich, [MarshalAs(UnmanagedType.Interface)] ITsString _tss);
	}

	/// <summary>
	/// Interface ILgFontManager
	/// Obtain a list of the (TrueType) fonts that are available on the system, and handle
	/// simple queries about font availability.
	///
	/// Note: the font manager may load the available fonts once, and use this cached list
	/// to answer subsequent queries. To be sure the answer to a query is current, call
	/// RefreshFontList.
	///
	/// <h3>When to implement</h3>
	/// Clients should not implement this interface. There is a standard implementation in
	/// Language.dll.
	///
	/// <h3>When to use</h3>
	/// Use this interface when you need to know whether a given font is available on the
	/// system, or to get a list of available fonts.
	///
	/// <h3>How to obtain an instance</h3>
	/// Use CoCreateInstance, CLSID_LgFontManager. Or use the CreateInstance() method of a
	/// smart pointer.
	///
	/// Hungarian: <c>fm</c>
	///</summary>
	[ComImport()]
	[InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]
	[Guid("73718689-B701-4241-A408-4C389ECD6664")]
	public interface ILgFontManager
	{

		/// <summary> Is the given font available? </summary>
		/// <param name='bstrName'> </param>
		/// <returns></returns>
		[return: MarshalAs(UnmanagedType.VariantBool)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		bool IsFontAvailable([MarshalAs(UnmanagedType.BStr)] string bstrName);

		/// <summary> Is the given font available? </summary>
		/// <param name='cch'> </param>
		/// <param name='_rgchName'> </param>
		/// <returns></returns>
		[return: MarshalAs(UnmanagedType.VariantBool)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		bool IsFontAvailableRgch(int cch, ushort _rgchName);

		/// <summary> Get the list of available fonts delimited by L'\0'. </summary>
		/// <param name='_bstrNames'> </param>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void AvailableFonts([MarshalAs(UnmanagedType.BStr)] out string _bstrNames);

		/// <summary> Update the list of fonts (by rereading from the OS). </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void RefreshFontList();
	}

	#region LgInputMethodEditor CoClass definitions
	/// <summary>
	/// Interface ILgInputMethodEditor
	/// Functions related to special ways of typing for exotic writing systems.
	/// The <c>Setup</c> method is called before the user types something and may do things at the
	/// system level (such as setting the current system IME or Keyman file) to change what is
	/// received through WM_CHAR. The other methods allow postprocessing of what is received
	/// through WM_CHAR.
	///
	/// <h3>When to implement</h3>
	/// Clients should not normally implement this interface. Standard implementations are in
	/// Language.dll. If you have a very unusual input method requirement, you could make your
	/// own implementation.
	///
	/// Note: current FieldWorks code is <i>not</i> using this approach to typing. Check out
	/// <see href="intranet.sil.org/softwaredev/project_status.htm">intranet.sil.org/softwaredev/project_status.htm</see> to see if there are any plans.
	///
	/// <h3>When to use</h3>
	/// Most programmers will not use this interface directly. It is used by the Views
	/// subsystem and controls that accept typing in vernacular scripts.
	///
	/// <h3>How to obtain an instance</h3>
	/// At present, you can't. Eventually OldWritingSystem will implement a method. Some
	/// implemenations may also be available through CoCreateInstance.
	///
	/// Hungarian: <c>ime</c>
	///</summary>
	[ComImport()]
	[CoClass(typeof(_LgInputMethodEditorClass))]
	[Guid("E1B27A5F-DD1B-4BBA-9B72-00BDE03162FC")]
	public interface LgInputMethodEditor : ILgInputMethodEditor
	{
	}

	#region Private _LgInputMethodEditorClass class
	/// <summary>_LgInputMethodEditorClass </summary>
	[ComImport()]
	[ClassInterface(ClassInterfaceType.None)]
	[TypeLibType(TypeLibTypeFlags.FCanCreate)]
	[Guid("659C2C2F-7AF6-4F9E-AC6F-7A03C8418FC9")]
	internal class _LgInputMethodEditorClass : ILgInputMethodEditor, LgInputMethodEditor
	{

		/// <summary>
		/// GET THE SYSTEM READY TO use this input method; for example, switch Keyman to the
		/// proper table.
		///</summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		public virtual extern void Setup();

		/// <summary>
		/// Given something the user typed, following any preprocessing that happens
		/// automatically as a result of Setup (e.g., Keyman processing), do any further
		/// processing required to actually replace the selected part of the string with what
		/// the user typed.
		/// The default implementation just replaces characters from ichMin to ichLim with
		/// those from bstrInput, then sets pichModMin to ichMin, and pichModLim and
		/// pichIP both to ichMin + BstrLen(bstrInput).
		///</summary>
		/// <param name='bstrInput'>What the user typed. </param>
		/// <param name='_ttpInput'>Text properties desired for new text </param>
		/// <param name='_tsbOld'>Original, unedited text, gets modified by this method </param>
		/// <param name='ichMin'>Range in old ptsbOld to replace </param>
		/// <param name='ichLim'>Range in old ptsbOld to replace </param>
		/// <param name='_ichModMin'>Range in modified ptsbOld that is different from before </param>
		/// <param name='_ichModLim'>Range in modified ptsbOld that is different from before </param>
		/// <param name='_ichIP'>Position of insertion point in modified string
		/// The result is the modified string represented by ptsbOld. </param>
		/// <exception cref="ArgumentException">ichMin/Lim is not a valid range within ptsbOld (E_INVALIDARG)</exception>
		[Obsolete("Can\'t call COM method marked with [local] attribute in IDL file")]
		[TypeLibFunc(TypeLibFuncFlags.FRestricted)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		public virtual extern void Replace([MarshalAs(UnmanagedType.BStr)] string bstrInput, [MarshalAs(UnmanagedType.Interface)] ITsTextProps _ttpInput, [MarshalAs(UnmanagedType.Interface)] ITsStrBldr _tsbOld, int ichMin, int ichLim, out int _ichModMin, out int _ichModLim, out int _ichIP);

		/// <summary>
		/// The user pressed a certain number of backspaces. Delete an appropriate amount of
		/// the string represented by the input string builder, indicating exactly what changed.
		/// Also, if there were not enough characters to delete, indicate how many backspaces
		/// were left over.
		///</summary>
		/// <param name='_ichStart'>start position (delete characters before here) </param>
		/// <param name='cactBackspace'>number of backspaces pressed </param>
		/// <param name='_tsbOld'>the text being edited; gets changed by this call </param>
		/// <param name='_ichModMin'>range in output text affected </param>
		/// <param name='_ichModLim'>range in output text affected </param>
		/// <param name='_ichIP'>position of IP in modified string </param>
		/// <param name='_cactBsRemaining'>Number not handled, caller should apply to previous run or
		/// string </param>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		public virtual extern void Backspace(int _ichStart, int cactBackspace, [MarshalAs(UnmanagedType.Interface)] ITsStrBldr _tsbOld, out int _ichModMin, out int _ichModLim, out int _ichIP, out int _cactBsRemaining);

		/// <summary>
		/// The user pressed a certain number of delete forward characters. Compute the effect on
		/// ptsbInOut
		/// Also, if there were not enough characters to delete, indicate how many backspaces
		/// were left over.
		///</summary>
		/// <param name='_ichStart'>start position (delete characters after here) </param>
		/// <param name='cactDelForward'>number of DF pressed </param>
		/// <param name='_tsbInOut'>the text being edited; gets changed by this call </param>
		/// <param name='_ichModMin'>range in output text affected </param>
		/// <param name='_ichModLim'>range in output text affected </param>
		/// <param name='_ichIP'>position of IP in modified string </param>
		/// <param name='_cactDfRemaining'>Number not handled, caller should apply to next run or string </param>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		public virtual extern void DeleteForward(int _ichStart, int cactDelForward, [MarshalAs(UnmanagedType.Interface)] ITsStrBldr _tsbInOut, out int _ichModMin, out int _ichModLim, out int _ichIP, out int _cactDfRemaining);

		/// <summary>
		/// Return true if input method considers an IP at the specified index reasonable.
		/// Note that really useful IPs should also satisfy the Renderer; see
		/// <c>ILgSegment.IsValidInsertionPoint</c>.
		///</summary>
		/// <param name='ich'> </param>
		/// <param name='_tss'> </param>
		/// <returns></returns>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		public virtual extern int IsValidInsertionPoint(int ich, [MarshalAs(UnmanagedType.Interface)] ITsString _tss);
	}
	#endregion

	/// <summary>LgInputMethodEditorClass </summary>
	public static class LgInputMethodEditorClass
	{

		/// <summary>Member Create </summary>
		/// <returns>A LgInputMethodEditor</returns>
		public static LgInputMethodEditor Create()
		{
			return new _LgInputMethodEditorClass();
		}
	}
	#endregion

	#region LgFontManager CoClass definitions
	/// <summary>
	/// Interface ILgFontManager
	/// Obtain a list of the (TrueType) fonts that are available on the system, and handle
	/// simple queries about font availability.
	///
	/// Note: the font manager may load the available fonts once, and use this cached list
	/// to answer subsequent queries. To be sure the answer to a query is current, call
	/// RefreshFontList.
	///
	/// <h3>When to implement</h3>
	/// Clients should not implement this interface. There is a standard implementation in
	/// Language.dll.
	///
	/// <h3>When to use</h3>
	/// Use this interface when you need to know whether a given font is available on the
	/// system, or to get a list of available fonts.
	///
	/// <h3>How to obtain an instance</h3>
	/// Use CoCreateInstance, CLSID_LgFontManager. Or use the CreateInstance() method of a
	/// smart pointer.
	///
	/// Hungarian: <c>fm</c>
	///</summary>
	[ComImport()]
	[CoClass(typeof(_LgFontManagerClass))]
	[Guid("73718689-B701-4241-A408-4C389ECD6664")]
	public interface LgFontManager : ILgFontManager
	{
	}

	#region Private _LgFontManagerClass class
	/// <summary>_LgFontManagerClass </summary>
	[ComImport()]
	[ClassInterface(ClassInterfaceType.None)]
	[TypeLibType(TypeLibTypeFlags.FCanCreate)]
	[Guid("02C3F580-796D-4B5F-BE43-166D97319DA5")]
	internal class _LgFontManagerClass : ILgFontManager, LgFontManager
	{

		/// <summary> Is the given font available? </summary>
		/// <param name='bstrName'> </param>
		/// <returns></returns>
		[return: MarshalAs(UnmanagedType.VariantBool)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		public virtual extern bool IsFontAvailable([MarshalAs(UnmanagedType.BStr)] string bstrName);

		/// <summary> Is the given font available? </summary>
		/// <param name='cch'> </param>
		/// <param name='_rgchName'> </param>
		/// <returns></returns>
		[return: MarshalAs(UnmanagedType.VariantBool)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		public virtual extern bool IsFontAvailableRgch(int cch, ushort _rgchName);

		/// <summary> Get the list of available fonts delimited by L'\0'. </summary>
		/// <param name='_bstrNames'> </param>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		public virtual extern void AvailableFonts([MarshalAs(UnmanagedType.BStr)] out string _bstrNames);

		/// <summary> Update the list of fonts (by rereading from the OS). </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		public virtual extern void RefreshFontList();
	}
	#endregion

	/// <summary>LgFontManagerClass </summary>
	public static class LgFontManagerClass
	{

		/// <summary>Member Create </summary>
		/// <returns>A LgFontManager</returns>
		public static LgFontManager Create()
		{
			return new _LgFontManagerClass();
		}
	}
	#endregion

	/// <summary>
	/// !NO_COCLASSES
	/// Flags used to specify variations on how to collate.
	/// Default is all listed options off.
	/// Except where noted, options are orthogonal and may be ORed together for combined
	/// effect.
	/// Unrecognized options are ignored. This allows for forwards compatibility: as we
	/// introduce new options, older engines will continue to work but ignore them.
	/// (An unrecognized option is any bit not used by any of the options defined here.)
	///</summary>
	public enum LgCollatingOptions
	{

		/// <summary> </summary>
		fcoDefault = 0,

		/// <summary> </summary>
		fcoIgnoreCase = 1,

		/// <summary> </summary>
		fcoDontIgnoreVariant = 2,

		/// <summary> max valid value. </summary>
		fcoLim,
	}

	/// <summary>
	/// Interface ILgCollatingEngine
	/// A collating engine knows how to compare strings in the same writing system.
	///
	/// <h3>When to implement</h3>
	/// Clients should not normally implement this interface. There are standard implementations
	/// in Language.dll. A new implementation might possibly be made for a language with very
	/// unusual collating requirements, if none of the standard implementations can be
	/// configured to suit.
	///
	/// <h3>When to use</h3>
	/// Use this interface when you need to know whether a given string collates before or after
	/// another, or to create a list of keys that can be simply compared in order to sort a
	/// larger list.
	///
	/// <h3>How to obtain an instance</h3>
	/// Obtain a collating engine from the writing system using
	/// <c>LgWritingSystem.get_CollatingEngine</c>. Obtain a default Unicode collater from
	/// <c>LgWritingSystemFactory.get_DefaultCollater</c>.
	///
	/// Hungarian: <c>coleng</c>
	///</summary>
	[ComImport()]
	[InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]
	[Guid("D27A3D8C-D3FE-4E25-9097-8F4A1FB30361")]
	public interface ILgCollatingEngine
	{

		/// <summary>
		/// Get a sort key which may be compared to any other sort key produced by this
		/// object via a simple BSTR comparison. This is especially useful in largescale
		/// sorting, where the work to generate the key only needs to be done once per key
		///</summary>
		/// <param name='bstrValue'> </param>
		/// <param name='colopt'> </param>
		/// <returns></returns>
		[return: MarshalAs(UnmanagedType.BStr)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		string get_SortKey([MarshalAs(UnmanagedType.BStr)] string bstrValue, LgCollatingOptions colopt);

		/// <summary>
		/// Get a sort key which may be compared to any other sort key produced by this
		/// object via a simple wcscmp comparison. This is especially useful in largescale
		/// sorting, where the work to generate the key only needs to be done once per key
		///</summary>
		/// <param name='_ch'> </param>
		/// <param name='cchIn'> </param>
		/// <param name='colopt'> </param>
		/// <param name='cchMaxOut'>Available space in output buffer. If 0, the method just sets
		/// pchKey to the number required. </param>
		/// <param name='_chKey'> </param>
		/// <param name='_cchOut'> </param>
		/// <exception cref="COMException">if not enough space in output buffer (gives
		/// needed amount in pcchOut). (ERROR_INSUFFICIENT_BUFFER)</exception>
		[TypeLibFunc(TypeLibFuncFlags.FRestricted)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void SortKeyRgch([MarshalAs(UnmanagedType.LPWStr)] string _ch, int cchIn, LgCollatingOptions colopt, int cchMaxOut, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef=typeof(ArrayPtrMarshaler))] ArrayPtr/*OLECHAR[]*/ _chKey, out int _cchOut);

		/// <summary>
		/// Return in pnVal (&lt;0, 0, or &gt;0) depending on whether the first string is
		/// (less than, equal, or greater than) the second string passed. This in principle
		/// creates a SortKey for each string using the SortKey method, then compares them.
		/// Any actual implementation promises to give the same results as doing that.
		/// However, the actual implementation may be more efficient than that, saving time
		/// when only a single comparison is to be made involving each string.
		///</summary>
		/// <param name='bstrValue1'> </param>
		/// <param name='bstrValue2'> </param>
		/// <param name='colopt'> </param>
		/// <returns></returns>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		int Compare([MarshalAs(UnmanagedType.BStr)] string bstrValue1, [MarshalAs(UnmanagedType.BStr)] string bstrValue2, LgCollatingOptions colopt);

		/// <summary>
		/// Get the language writing system factory used with this collating engine object.
		/// Set the language writing system factory to use with this collating engine object.
		///</summary>
		/// <returns>A ILgWritingSystemFactory </returns>
		ILgWritingSystemFactory WritingSystemFactory
		{
			[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
			[return: MarshalAs(UnmanagedType.Interface)]
			get;
			[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
			[param: MarshalAs(UnmanagedType.Interface)]
			set;
		}

		/// <summary> The next two methods are required by C </summary>
		/// <param name='bstrValue'> </param>
		/// <param name='colopt'> </param>
		/// <returns> will be a "safearray".</returns>
		[return: MarshalAs(UnmanagedType.Struct)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		object get_SortKeyVariant([MarshalAs(UnmanagedType.BStr)] string bstrValue, LgCollatingOptions colopt);

		/// <summary>
		/// Return in pnVal (&lt;0, 0, or &gt;0) depending on whether the first string is
		/// (less than, equal, or greater than) the second string passed. This in principle
		/// creates a SortKey for each string using the SortKey method, then compares them.
		/// Any actual implementation promises to give the same results as doing that.
		/// However, the actual implementation may be more efficient than that, saving time
		/// when only a single comparison is to be made involving each string.
		///</summary>
		/// <param name='saValue1'> "safearray" </param>
		/// <param name='saValue2'> "safearray" </param>
		/// <param name='colopt'> </param>
		/// <returns></returns>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		int CompareVariant([MarshalAs(UnmanagedType.Struct)] object saValue1, [MarshalAs(UnmanagedType.Struct)] object saValue2, LgCollatingOptions colopt);

		/// <summary> Initialize the collating engine to the given locale. </summary>
		/// <param name='bstrLocale'> </param>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void Open([MarshalAs(UnmanagedType.BStr)] string bstrLocale);

		/// <summary> Close and free the currently open collating engine, if any. </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void Close();
	}

	/// <summary>
	/// Interface ILgCharacterPropertyEngine
	/// This interface provides information about character properties and converting between
	/// characters.
	///
	/// Note the use of int rather than OLECHAR throughout for character codes. This allows
	/// for the possibility of characters not in plane 0, though the current base implementation
	/// considers all characters outside plane 0 to be unassigned.
	///
	/// In general, routines which take a single character as input return E_INVALIDARG if the
	/// character is outside the extended Unicode range (i.e., it could not be represented as
	/// two surrogate pair characters).
	///
	/// <h3>When to implement</h3>
	/// Clients should not normally implement this interface. There are standard implementations
	/// in Language.dll.
	///
	/// <h3>When to use</h3>
	/// Use this interface when you need to know properties of characters, such as whether a
	/// character is a letter, how it behaves in the Unicode bidi algorithm, how it combines
	/// with other characters, whether it is a symbol, separator, etc, its case, how it
	/// might decompose, and so forth. A particularly important use is to determine possible
	/// line break positions in a string.
	///
	/// <h3>How to obtain an instance</h3>
	/// Obtain a collating engine from the writing system using
	/// <c>LgWritingSystem.get_CharPropEngine</c>. Obtain a default Unicode char props engine from
	/// <c>LgWritingSystemFactory.get_UnicodeCharProps</c>.
	///
	/// Hungarian: <c>propeng</c>
	///</summary>
	[ComImport()]
	[InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]
	[Guid("890C5B18-6E95-438E-8ADE-A4FFADDF0684")]
	public interface ILgCharacterPropertyEngine
	{

		/// <summary>
		/// Get the exact character category as defined in the Unicode standard.
		/// See <see href="www.unicode.org/Public/UNIDATA/UnicodeData.html#General%20Category">www.unicode.org/Public/UNIDATA/UnicodeData.html#General%20Category</see>
		///</summary>
		/// <param name='ch'> </param>
		/// <returns></returns>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		LgGeneralCharCategory get_GeneralCategory(int ch);

		/// <summary>
		/// Get the Bidi category of a character as defined in the Unicode standard.
		/// See <see href="www.unicode.org/Public/UNIDATA/UnicodeData.html#Bidirectional%20Category">www.unicode.org/Public/UNIDATA/UnicodeData.html#Bidirectional%20Category</see>
		/// See <see href="www.unicode.org/unicode/reports/tr9/">www.unicode.org/unicode/reports/tr9/</see> for the full algorithm
		///</summary>
		/// <param name='ch'> </param>
		/// <returns></returns>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		LgBidiCategory get_BidiCategory(int ch);

		/// <summary>
		/// Return true if Unicode general category starts with L. See <c>get_GeneralCategory</c>
		/// If this returns true, exactly one of <c>get_IsUpper</c>, <c>get_IsLower</c>,
		/// <c>get_IsTitle</c>, <c>get_IsModifier</c>, or <c>get_IsOtherLetter</c> will return true.
		///</summary>
		/// <param name='ch'> </param>
		/// <returns></returns>
		[return: MarshalAs(UnmanagedType.VariantBool)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		bool get_IsLetter(int ch);

		/// <summary>
		/// Return true if character is considered to be part of a word (by default, this
		/// corresponds to Unicode general category Mc, Mn, and categories starting with L.
		/// ENHANCE: Eventually, this method may need to be altered or replaced to acocunt
		/// for the reality that some languages have context rules to determine whether a
		/// character is wordforming or not (e.g., apostrophes).
		/// See <c>get_GeneralCategory</c>
		///</summary>
		/// <param name='ch'> </param>
		/// <returns></returns>
		[return: MarshalAs(UnmanagedType.VariantBool)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		bool get_IsWordForming(int ch);

		/// <summary>
		/// Return true if Unicode general category starts with P. See <c>get_GeneralCategory</c>
		///</summary>
		/// <param name='ch'> </param>
		/// <returns></returns>
		[return: MarshalAs(UnmanagedType.VariantBool)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		bool get_IsPunctuation(int ch);

		/// <summary>
		/// Return true if Unicode general category starts with N. See <c>get_GeneralCategory</c>
		///</summary>
		/// <param name='ch'> </param>
		/// <returns></returns>
		[return: MarshalAs(UnmanagedType.VariantBool)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		bool get_IsNumber(int ch);

		/// <summary>
		/// Return true if Unicode general category starts with Z. See <c>get_GeneralCategory</c>
		///</summary>
		/// <param name='ch'> </param>
		/// <returns></returns>
		[return: MarshalAs(UnmanagedType.VariantBool)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		bool get_IsSeparator(int ch);

		/// <summary>
		/// Return true if Unicode general category starts with S. See <c>get_GeneralCategory</c>
		///</summary>
		/// <param name='ch'> </param>
		/// <returns></returns>
		[return: MarshalAs(UnmanagedType.VariantBool)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		bool get_IsSymbol(int ch);

		/// <summary>
		/// Return true if Unicode general category starts with M. See <c>get_GeneralCategory</c>
		///</summary>
		/// <param name='ch'> </param>
		/// <returns></returns>
		[return: MarshalAs(UnmanagedType.VariantBool)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		bool get_IsMark(int ch);

		/// <summary>
		/// Return true if Unicode general category starts with C. See <c>get_GeneralCategory</c>
		///</summary>
		/// <param name='ch'> </param>
		/// <returns></returns>
		[return: MarshalAs(UnmanagedType.VariantBool)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		bool get_IsOther(int ch);

		/// <summary> Return true if Unicode general category is Lu. See <c>get_GeneralCategory</c> </summary>
		/// <param name='ch'> </param>
		/// <returns></returns>
		[return: MarshalAs(UnmanagedType.VariantBool)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		bool get_IsUpper(int ch);

		/// <summary>
		/// Return true if Unicode general category is Ll. See <c>get_GeneralCategory</c>
		/// In languages without case all characters are considered lower case.
		///</summary>
		/// <param name='ch'> </param>
		/// <returns></returns>
		[return: MarshalAs(UnmanagedType.VariantBool)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		bool get_IsLower(int ch);

		/// <summary>
		/// Return true if Unicode general category is Lt. See <c>get_GeneralCategory</c>
		/// This refers to "Title case" characters, typically a single code point standing for
		/// two letters, where the first is upper case and the second is lower.
		/// Unicode general category Lt, typically digraph with first upper
		///</summary>
		/// <param name='ch'> </param>
		/// <returns></returns>
		[return: MarshalAs(UnmanagedType.VariantBool)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		bool get_IsTitle(int ch);

		/// <summary> Return true if Unicode general category is Lm. See <c>get_GeneralCategory</c> </summary>
		/// <param name='ch'> </param>
		/// <returns></returns>
		[return: MarshalAs(UnmanagedType.VariantBool)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		bool get_IsModifier(int ch);

		/// <summary> Return true if Unicode general category is Lo. See <c>get_GeneralCategory</c> </summary>
		/// <param name='ch'> </param>
		/// <returns></returns>
		[return: MarshalAs(UnmanagedType.VariantBool)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		bool get_IsOtherLetter(int ch);

		/// <summary>
		/// Return true if Unicode general category is Ps. See <c>get_GeneralCategory</c>
		/// Signifies opening punctuation, like left paren
		/// ENHANCE JohnT: Should opening include Pi, Initial quote?
		///</summary>
		/// <param name='ch'> </param>
		/// <returns></returns>
		[return: MarshalAs(UnmanagedType.VariantBool)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		bool get_IsOpen(int ch);

		/// <summary>
		/// Return true if Unicode general category is Pe. See <c>get_GeneralCategory</c>
		/// Signifies closing punctuation, like right paren.
		/// ENHANCE JohnT: should we also include Pf, final quote?
		///</summary>
		/// <param name='ch'> </param>
		/// <returns></returns>
		[return: MarshalAs(UnmanagedType.VariantBool)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		bool get_IsClose(int ch);

		/// <summary>
		/// Return true if Unicode general category is Pc. See <c>get_GeneralCategory</c>
		/// Signifies middle of a word, like hyphen.
		/// ENHANCE JohnT: should we also include Pd, dash
		///</summary>
		/// <param name='ch'> </param>
		/// <returns></returns>
		[return: MarshalAs(UnmanagedType.VariantBool)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		bool get_IsWordMedial(int ch);

		/// <summary> Return true if Unicode general category is Cc. See <c>get_GeneralCategory</c> </summary>
		/// <param name='ch'> </param>
		/// <returns></returns>
		[return: MarshalAs(UnmanagedType.VariantBool)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		bool get_IsControl(int ch);

		/// <summary>
		/// Convert a character to lower case if it is Lu or Lt; otherwise return it unchanged.
		/// ENHANCE JohnT: should we convert characters that are not Lu or Lt but for which
		/// UnicodeData.txt specifies a case conversion?
		///
		/// See <c>ToLower</c> to convert an entire string, or to make use of Unicode mulicharacter
		/// conversions.
		///</summary>
		/// <param name='ch'> </param>
		/// <returns></returns>
		/// <exception cref="ArgumentException">if passed invalid Unicode code point, including one half
		/// of a surrogate pair. (E_INVALIDARG)</exception>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		int get_ToLowerCh(int ch);

		/// <summary>
		/// Convert a character to upper case if it is Ll or Lt; otherwise return it unchanged.
		/// ENHANCE JohnT: should we convert characters that are not Ll or Lt but for which
		/// UnicodeData.txt specifies a case conversion?
		///
		/// See <c>ToUpper</c> to convert an entire string, or to make use of Unicode mulicharacter
		/// conversions.
		///</summary>
		/// <param name='ch'> </param>
		/// <returns></returns>
		/// <exception cref="ArgumentException">if passed invalid Unicode code point, including one half
		/// of a surrogate pair. (E_INVALIDARG)</exception>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		int get_ToUpperCh(int ch);

		/// <summary>
		/// Convert a character to title case if it is Lu or Ll; otherwise return it unchanged.
		/// Usually this is the same as converting it to upper case.
		/// ENHANCE JohnT: should we convert characters that are not Lu or Ll but for which
		/// UnicodeData.txt specifies a case conversion?
		///
		/// See <c>ToTitle</c> to convert an entire string, or to make use of Unicode mulicharacter
		/// conversions.
		///</summary>
		/// <param name='ch'> </param>
		/// <returns></returns>
		/// <exception cref="ArgumentException">if passed invalid Unicode code point, including one half
		/// of a surrogate pair. (E_INVALIDARG)</exception>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		int get_ToTitleCh(int ch);

		/// <summary>
		/// Convert a string to lower case. Characters that are not Lu or Lt pass through
		/// unchanged. Note that the output may be longer than the input! This function, unlike
		/// <c>get_ToLowerCh</c>, will apply multicharacter conversions if Unicode specifies them.
		///</summary>
		/// <param name='bstr'> </param>
		/// <returns></returns>
		/// <exception cref="ArgumentException">if characters in input are not valid Unicode. (E_INVALIDARG)</exception>
		[return: MarshalAs(UnmanagedType.BStr)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		string ToLower([MarshalAs(UnmanagedType.BStr)] string bstr);

		/// <summary>
		/// Convert a string to upper case. Characters that are not Ll or Lt pass through
		/// unchanged. Note that the output may be longer than the input! This function, unlike
		/// <c>get_ToUpperCh</c>, will apply multicharacter conversions if Unicode specifies them.
		///</summary>
		/// <param name='bstr'> </param>
		/// <returns></returns>
		/// <exception cref="ArgumentException">if characters in input are not valid Unicode. (E_INVALIDARG)</exception>
		[return: MarshalAs(UnmanagedType.BStr)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		string ToUpper([MarshalAs(UnmanagedType.BStr)] string bstr);

		/// <summary>
		/// Convert a string to title case. Characters that are not Lu or Ll pass through
		/// unchanged. Note that the output may be longer than the input! This function, unlike
		/// <c>get_ToUpperCh</c>, will apply multicharacter conversions if Unicode specifies them.
		/// Note that this is not usually useful, because if you want title case, you usually
		/// want to convert only the first nonpunctuation character, or perhaps the first of
		/// each word. However, this at least provides a way to get at multicharacter
		/// conversions by passing a single character input string.
		///</summary>
		/// <param name='bstr'> </param>
		/// <returns></returns>
		/// <exception cref="ArgumentException">if characters in input are not valid Unicode. (E_INVALIDARG)</exception>
		[return: MarshalAs(UnmanagedType.BStr)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		string ToTitle([MarshalAs(UnmanagedType.BStr)] string bstr);

		/// <summary>
		/// Convert a string to lower case. Characters that are not Lu or Lt pass through
		/// unchanged. Note that the output may be longer than the input! This function, unlike
		/// <c>get_ToLowerCh</c>, will apply multicharacter conversions if Unicode specifies them.
		/// If cchOut is zero, just return the length needed.
		///</summary>
		/// <param name='_rgchIn'> </param>
		/// <param name='cchIn'> </param>
		/// <param name='_rgchOut'> </param>
		/// <param name='cchOut'> </param>
		/// <param name='_cchRet'> </param>
		/// <exception cref="ArgumentException">if characters in input are not valid Unicode. (E_INVALIDARG)</exception>
		/// <exception cref="COMException">if cchOut is nonzero and too small (E_FAIL)</exception>
		[TypeLibFunc(TypeLibFuncFlags.FRestricted)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void ToLowerRgch([MarshalAs(UnmanagedType.LPWStr)] string _rgchIn, int cchIn, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef=typeof(ArrayPtrMarshaler))] ArrayPtr/*OLECHAR[]*/ _rgchOut, int cchOut, out int _cchRet);

		/// <summary>
		/// Convert a string to upper case. Characters that are not Ll or Lt pass through
		/// unchanged. Note that the output may be longer than the input! This function, unlike
		/// <c>get_ToUpperCh</c>, will apply multicharacter conversions if Unicode specifies them.
		/// If cchOut is zero, just return the length needed.
		///</summary>
		/// <param name='_rgchIn'> </param>
		/// <param name='cchIn'> </param>
		/// <param name='_rgchOut'> </param>
		/// <param name='cchOut'> </param>
		/// <param name='_cchRet'> </param>
		/// <exception cref="ArgumentException">if characters in input are not valid Unicode. (E_INVALIDARG)</exception>
		/// <exception cref="COMException">if cchOut is nonzero and too small (E_FAIL)</exception>
		[TypeLibFunc(TypeLibFuncFlags.FRestricted)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void ToUpperRgch([MarshalAs(UnmanagedType.LPWStr)] string _rgchIn, int cchIn, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef=typeof(ArrayPtrMarshaler))] ArrayPtr/*OLECHAR[]*/ _rgchOut, int cchOut, out int _cchRet);

		/// <summary>
		/// Convert a string to title case. Characters that are not Lu or Ll pass through
		/// unchanged. Note that the output may be longer than the input! This function, unlike
		/// <c>get_ToUpperCh</c>, will apply multicharacter conversions if Unicode specifies them.
		/// Note that this is not usually useful, because if you want title case, you usually
		/// want to convert only the first nonpunctuation character, or perhaps the first of
		/// each word. However, this at least provides a way to get at multicharacter
		/// conversions by passing a single character input string.
		/// If cchOut is zero, just return the length needed.
		///</summary>
		/// <param name='_rgchIn'> </param>
		/// <param name='cchIn'> </param>
		/// <param name='_rgchOut'> </param>
		/// <param name='cchOut'> </param>
		/// <param name='_cchRet'> </param>
		/// <exception cref="ArgumentException">if characters in input are not valid Unicode. (E_INVALIDARG)</exception>
		/// <exception cref="COMException">if cchOut is nonzero and too small (E_FAIL)</exception>
		[TypeLibFunc(TypeLibFuncFlags.FRestricted)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void ToTitleRgch([MarshalAs(UnmanagedType.LPWStr)] string _rgchIn, int cchIn, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef=typeof(ArrayPtrMarshaler))] ArrayPtr/*OLECHAR[]*/ _rgchOut, int cchOut, out int _cchRet);

		/// <summary>
		/// Returns true if the specified code point is a member of the specified user defined
		/// class of code points. Nathan thinks we should restrict class names to a single
		/// character to make patterns containing them more readable. Example \C\Vxyz for all
		/// words containing a consonant, followed by a vowel, followed by xyz.
		///
		/// Not yet implemented, and may not be, as it is not clear that this is the right place
		/// to store user defined character classes.
		///</summary>
		/// <param name='ch'> </param>
		/// <param name='chClass'> </param>
		/// <returns></returns>
		[return: MarshalAs(UnmanagedType.VariantBool)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		bool get_IsUserDefinedClass(int ch, int chClass);

		/// <summary>
		/// Converts a string into another string in which all characters are replaced with their
		/// sound alike equivalent. For example, if for this language s and z where specified to
		/// sound alike, we could take s as the generic form and convert all z's to this form.
		/// Note that we need to support the possibility that 0 (empty code point) and x and y
		/// sound alike which means that all x's and 's and y's will be ignored when testing for
		/// sound alikeness.
		///
		/// ENHANCE JohnT: Should this be a separate engine? Does it belong to the spelling
		/// engine?
		/// ENHANCE Development(JohnT): enhance the specification so it can specify soundalikes.
		///
		/// Not yet implemented, and may never be.
		///</summary>
		/// <param name='bstrValue'> </param>
		/// <returns></returns>
		[return: MarshalAs(UnmanagedType.BStr)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		string get_SoundAlikeKey([MarshalAs(UnmanagedType.BStr)] string bstrValue);

		/// <summary>
		/// Get the official Unicode character name (character database field 1).
		/// Will also produce a somewhat helpful descriptive string for surrogate halves and
		/// PUA characters, though officially they have no name.
		/// (Warning: obtaining this for the first character in each page will be somewhat slow,
		/// and will use up something like 10K of RAM).
		///</summary>
		/// <param name='ch'> </param>
		/// <returns></returns>
		/// <exception cref="ArgumentException">if character input is not valid Unicode. (E_INVALIDARG)</exception>
		[return: MarshalAs(UnmanagedType.BStr)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		string get_CharacterName(int ch);

		/// <summary>
		/// Get the decomposition of this character (Unicode char database field 5).
		/// Empty string if it does not decompose.
		///</summary>
		/// <param name='ch'> </param>
		/// <returns></returns>
		/// <exception cref="ArgumentException">if character input is not valid Unicode. (E_INVALIDARG)</exception>
		[return: MarshalAs(UnmanagedType.BStr)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		string get_Decomposition(int ch);

		/// <summary>
		/// Get the decomposition of this character (Unicode char database field 5).
		/// Empty string if it does not decompose.
		///</summary>
		/// <param name='ch'> </param>
		/// <param name='cchMax'> </param>
		/// <param name='_rgch'> </param>
		/// <param name='_cch'> </param>
		/// <param name='_fHasDecomp'> </param>
		/// <exception cref="ArgumentException">if character input is not valid Unicode. (E_INVALIDARG)</exception>
		[TypeLibFunc(TypeLibFuncFlags.FRestricted)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void DecompositionRgch(int ch, int cchMax, out ushort _rgch, out int _cch, [MarshalAs(UnmanagedType.VariantBool)] out bool _fHasDecomp);

		/// <summary>
		/// Get the recursive canonical decomposition of a character. Empty string if it does
		/// not decompose at all.
		///</summary>
		/// <param name='ch'> </param>
		/// <returns></returns>
		/// <exception cref="ArgumentException">if character input is not valid Unicode. (E_INVALIDARG)</exception>
		[return: MarshalAs(UnmanagedType.BStr)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		string get_FullDecomp(int ch);

		/// <summary>
		/// Get the recursive canonical decomposition of a character. The character itself if it
		/// does not decompose at all.
		///</summary>
		/// <param name='ch'> </param>
		/// <param name='cchMax'> </param>
		/// <param name='_rgch'> </param>
		/// <param name='_cch'> </param>
		/// <param name='_fHasDecomp'> </param>
		/// <exception cref="ArgumentException">if character input is not valid Unicode. (E_INVALIDARG)</exception>
		[TypeLibFunc(TypeLibFuncFlags.FRestricted)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void FullDecompRgch(int ch, int cchMax, out ushort _rgch, out int _cch, [MarshalAs(UnmanagedType.VariantBool)] out bool _fHasDecomp);

		/// <summary>
		/// Get the character's value as a number.(Field 8 in
		/// <see href="www.unicode.org/Public/UNIDATA/UnicodeData.html">www.unicode.org/Public/UNIDATA/UnicodeData.html</see>).
		///
		/// ENHANCE JohnT: is there a more useful behavior for the fraction case?
		/// Would it be better to return 0 for all cases where we don't know a useful answer?
		///</summary>
		/// <param name='ch'> </param>
		/// <returns></returns>
		/// <exception cref="COMException">if the character is not
		/// one of the Nd, Nl, or No types, or if it is one of those types but the
		/// Unicode database gives no numeric value for it.
		/// Currently also if the character represents a fraction. (E_UNEXPECTED)</exception>
		/// <exception cref="ArgumentException">if character input is not valid Unicode. (E_INVALIDARG)</exception>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		int get_NumericValue(int ch);

		/// <summary>
		/// Get the character's combining class (Unicode char database field 3; see
		/// <see href="www.unicode.org/Public/UNIDATA/UnicodeData.html#Canonical%20Combining%20Classes">www.unicode.org/Public/UNIDATA/UnicodeData.html#Canonical%20Combining%20Classes</see>)
		///</summary>
		/// <param name='ch'> </param>
		/// <returns></returns>
		/// <exception cref="ArgumentException">if character input is not valid Unicode. (E_INVALIDARG)</exception>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		int get_CombiningClass(int ch);

		/// <summary>
		/// Get any comment recorded about this character (Unicode char database field 11).
		/// Note: currently this is not implemented to obtain the rather uninteresting comments
		/// recorded in the standard UnicodeDatabase file. It will give interesting answers only
		/// if a comment is provided in the specification for this writing system.
		///</summary>
		/// <param name='ch'> </param>
		/// <returns></returns>
		[return: MarshalAs(UnmanagedType.BStr)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		string get_Comment(int ch);

		/// <summary>
		/// Get line breaking properties (from enumeration LgLBP) for an array of characters.
		/// This passes an array in, and an array with the same number of elements out, to
		/// improve efficiency when properties are required for a string of characters.
		/// See <see href="www.unicode.org/unicode/reports/tr14/">www.unicode.org/unicode/reports/tr14/</see>.
		///</summary>
		/// <param name='_rgchIn'> </param>
		/// <param name='cchIn'> </param>
		/// <param name='_rglbOut'> </param>
		/// <exception cref="ArgumentException">if characters in input are not valid Unicode. (E_INVALIDARG)</exception>
		[TypeLibFunc(TypeLibFuncFlags.FRestricted)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void GetLineBreakProps([MarshalAs(UnmanagedType.LPWStr)] string _rgchIn, int cchIn, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef=typeof(ArrayPtrMarshaler))] ArrayPtr/*byte[]*/ _rglbOut);

		/// <summary>
		/// Get line break status (from combinations of values in enumeration LgLineBreakStatus)
		/// of each character in the input array.
		///</summary>
		/// <param name='_rglbpIn'> </param>
		/// <param name='cb'> </param>
		/// <param name='_rglbsOut'> </param>
		/// <exception cref="ArgumentException">if characters in input are not valid Unicode. (E_INVALIDARG)</exception>
		[TypeLibFunc(TypeLibFuncFlags.FRestricted)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void GetLineBreakStatus([MarshalAs(UnmanagedType.LPArray, SizeParamIndex=1)] byte[] _rglbpIn, int cb, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef=typeof(ArrayPtrMarshaler))] ArrayPtr/*byte[]*/ _rglbsOut);

		/// <summary>
		/// This combines the functions of <c>GetLineBreakProps</c> and <c>GetLineBreakStatus</c>,
		/// plus the ability to skip part of the string, and stop at break characters.
		///
		/// The first two arguments define an array of characters as for <c>GetLineBreakProps</c>.
		/// The output is basically what would be produced by passing the output of
		/// that method as input to GetLineBreakStatus, with two exceptions:
		///
		/// 1. We only want line break status info for characters from ichMin to ichLim.
		/// (A larger array is passed in because we may need to look at preceding characters
		/// to confidently know whether we can break after the char at ichMin.)
		///
		/// 2. If we detect a character which forces a line or segment break in the range
		/// ichMin..ichLim, we stop and do not return any info about subsequent characters.
		///
		/// Also, we set pichBreak to the index of the break character.
		/// pichBreak is set to 1 if we don't find a break character.
		/// Break characters are things like CR, LF, TAB, or the embedded object character.
		///</summary>
		/// <param name='_rgchIn'> </param>
		/// <param name='cchIn'> </param>
		/// <param name='ichMin'> </param>
		/// <param name='ichLim'> </param>
		/// <param name='_rglbsOut'> </param>
		/// <param name='_ichBreak'> </param>
		[TypeLibFunc(TypeLibFuncFlags.FRestricted)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void GetLineBreakInfo([MarshalAs(UnmanagedType.LPWStr)] string _rgchIn, int cchIn, int ichMin, int ichLim, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef=typeof(ArrayPtrMarshaler))] ArrayPtr/*byte[]*/ _rglbsOut, out int _ichBreak);

		/// <summary>
		/// Strip diacritics. Specifically, removes all characters that have the property Lm on
		/// Mn. Note that this will not comvert a single code point that includes a diacritic to
		/// its unmodified equivalent. It is usually desireable to first perform normalization
		/// (form D or KD) before stripping diacritics.
		///</summary>
		/// <param name='bstr'> </param>
		/// <returns></returns>
		[return: MarshalAs(UnmanagedType.BStr)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		string StripDiacritics([MarshalAs(UnmanagedType.BStr)] string bstr);

		/// <summary>
		/// Strip diacritics. Specifically, removes all characters that have the property Lm or
		/// Mn. Note that this will not comvert a single code point that includes a diacritic to
		/// its unmodified equivalent. It is usually desireable to first perform normalization
		/// (form D or KD) before stripping diacritics.
		///</summary>
		/// <param name='_rgchIn'> </param>
		/// <param name='cchIn'> </param>
		/// <param name='_rgchOut'> </param>
		/// <param name='cchMaxOut'> </param>
		/// <param name='_cchOut'> </param>
		[TypeLibFunc(TypeLibFuncFlags.FRestricted)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void StripDiacriticsRgch([MarshalAs(UnmanagedType.LPWStr)] string _rgchIn, int cchIn, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef=typeof(ArrayPtrMarshaler))] ArrayPtr/*OLECHAR[]*/ _rgchOut, int cchMaxOut, out int _cchOut);

		/// <summary>
		/// Perform compatibility normalization of the input string, that is, every character
		/// which has a compatibility decomposition is decomposed (recursively). This is
		/// Normalization Form KD (NFKD) as defined by Unicode TR 15.
		///</summary>
		/// <param name='_rgchIn'> </param>
		/// <param name='cchIn'> </param>
		/// <param name='_rgchOut'> </param>
		/// <param name='cchMaxOut'> </param>
		/// <param name='_cchOut'> </param>
		[TypeLibFunc(TypeLibFuncFlags.FRestricted)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void NormalizeKdRgch([MarshalAs(UnmanagedType.LPWStr)] string _rgchIn, int cchIn, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef=typeof(ArrayPtrMarshaler))] ArrayPtr/*OLECHAR[]*/ _rgchOut, int cchMaxOut, out int _cchOut);

		/// <summary>
		/// Perform normalization of the input string, that is, every character
		/// which has a decomposition is decomposed (recursively). This is
		/// Normalization Form D (NFD) as defined by Unicode TR 15.
		///</summary>
		/// <param name='bstr'> </param>
		/// <returns></returns>
		[return: MarshalAs(UnmanagedType.BStr)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		string NormalizeD([MarshalAs(UnmanagedType.BStr)] string bstr);

		/// <summary>
		/// Perform compatibility normalization of the input string, that is, every character
		/// which has a compatibility decomposition is decomposed (recursively). This is
		/// Normalization Form D (NFD) as defined by Unicode TR 15.
		///</summary>
		/// <param name='_rgchIn'> </param>
		/// <param name='cchIn'> </param>
		/// <param name='_rgchOut'> </param>
		/// <param name='cchMaxOut'> </param>
		/// <param name='_cchOut'> </param>
		[TypeLibFunc(TypeLibFuncFlags.FRestricted)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void NormalizeDRgch([MarshalAs(UnmanagedType.LPWStr)] string _rgchIn, int cchIn, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef=typeof(ArrayPtrMarshaler))] ArrayPtr/*OLECHAR[]*/ _rgchOut, int cchMaxOut, out int _cchOut);

		/// <summary>
		/// Returns the locale of the engine. See put_Locale for more notes.
		/// Assigns the locale of the engine. The locale affects the ICU functions called for
		/// line breaking and changing cases. Note that the locale is read in using the
		/// Microsoft format we've been using for the rest of FieldWorks, as opposed to the ICU
		/// format (which it's translated into inside the class implementation).
		///</summary>
		/// <returns>A System.Int32 </returns>
		int Locale
		{
			[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
			get;
			[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
			set;
		}

		/// <summary>
		/// Gets the text that the LineBreakBefore and LineBreakAfter functions are using. This
		/// function is included for completion.
		///</summary>
		/// <param name='cchMax'> </param>
		/// <param name='_rgchOut'> </param>
		/// <param name='_cchOut'> </param>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void GetLineBreakText(int cchMax, out ushort _rgchOut, out int _cchOut);

		/// <summary> Sets the text for the LineBreakBefore and the LineBreakAfter functions to use. </summary>
		/// <param name='_rgchIn'> </param>
		/// <param name='cchMax'> </param>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void set_LineBreakText([MarshalAs(UnmanagedType.LPWStr)] string _rgchIn, int cchMax);

		/// <summary>
		/// Finds the nearest line break immediately before the given index (ichIn). The
		/// function returns not only a location but the weight of the line break (currently not
		/// implemented). See http:www.unicode.org/unicode/reports/tr14/ for more information
		/// on line breaking properties.
		///</summary>
		/// <param name='ichIn'> </param>
		/// <param name='_ichOut'> </param>
		/// <param name='_lbWeight'> </param>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void LineBreakBefore(int ichIn, out int _ichOut, out LgLineBreak _lbWeight);

		/// <summary>
		/// Finds the nearest line break immediately after the given index (ichIn). The function
		/// returns not only a location but the weight of the line break (currently not
		/// implemented). See http:www.unicode.org/unicode/reports/tr14/ for more information
		/// on line breaking properties.
		///</summary>
		/// <param name='ichIn'> </param>
		/// <param name='_ichOut'> </param>
		/// <param name='_lbWeight'> </param>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void LineBreakAfter(int ichIn, out int _ichOut, out LgLineBreak _lbWeight);
	}

	/// <summary>
	/// Interface ILgIcuCharPropEngine
	/// This interface provides initialization functions for an ICU character property engine.
	///
	/// <h3>When to implement</h3>
	/// Clients should not normally implement this interface. There are standard implementations
	/// in Language.dll.
	///
	/// <h3>When to use</h3>
	/// Use this interface when you need to initialize an ICU character property engine.
	///
	/// <h3>How to obtain an instance</h3>
	/// For now the only way is to create one using CoCreateInstance, with
	/// CLSID_LgIcuCharPropEngine.
	///
	/// Hungarian: <c>ipropeng</c>
	///</summary>
	[ComImport()]
	[InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]
	[Guid("E8689492-7622-427b-8518-6339294FD227")]
	public interface ILgIcuCharPropEngine : ILgCharacterPropertyEngine
	{

		/// <summary>
		/// Get the exact character category as defined in the Unicode standard.
		/// See <see href="www.unicode.org/Public/UNIDATA/UnicodeData.html#General%20Category">www.unicode.org/Public/UNIDATA/UnicodeData.html#General%20Category</see>
		///</summary>
		/// <param name='ch'> </param>
		/// <returns></returns>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		new LgGeneralCharCategory get_GeneralCategory(int ch);

		/// <summary>
		/// Get the Bidi category of a character as defined in the Unicode standard.
		/// See <see href="www.unicode.org/Public/UNIDATA/UnicodeData.html#Bidirectional%20Category">www.unicode.org/Public/UNIDATA/UnicodeData.html#Bidirectional%20Category</see>
		/// See <see href="www.unicode.org/unicode/reports/tr9/">www.unicode.org/unicode/reports/tr9/</see> for the full algorithm
		///</summary>
		/// <param name='ch'> </param>
		/// <returns></returns>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		new LgBidiCategory get_BidiCategory(int ch);

		/// <summary>
		/// Return true if Unicode general category starts with L. See <c>get_GeneralCategory</c>
		/// If this returns true, exactly one of <c>get_IsUpper</c>, <c>get_IsLower</c>,
		/// <c>get_IsTitle</c>, <c>get_IsModifier</c>, or <c>get_IsOtherLetter</c> will return true.
		///</summary>
		/// <param name='ch'> </param>
		/// <returns></returns>
		[return: MarshalAs(UnmanagedType.VariantBool)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		new bool get_IsLetter(int ch);

		/// <summary>
		/// Return true if character is considered to be part of a word (by default, this
		/// corresponds to Unicode general category Mc, Mn, and categories starting with L.
		/// ENHANCE: Eventually, this method may need to be altered or replaced to acocunt
		/// for the reality that some languages have context rules to determine whether a
		/// character is wordforming or not (e.g., apostrophes).
		/// See <c>get_GeneralCategory</c>
		///</summary>
		/// <param name='ch'> </param>
		/// <returns></returns>
		[return: MarshalAs(UnmanagedType.VariantBool)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		new bool get_IsWordForming(int ch);

		/// <summary>
		/// Return true if Unicode general category starts with P. See <c>get_GeneralCategory</c>
		///</summary>
		/// <param name='ch'> </param>
		/// <returns></returns>
		[return: MarshalAs(UnmanagedType.VariantBool)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		new bool get_IsPunctuation(int ch);

		/// <summary>
		/// Return true if Unicode general category starts with N. See <c>get_GeneralCategory</c>
		///</summary>
		/// <param name='ch'> </param>
		/// <returns></returns>
		[return: MarshalAs(UnmanagedType.VariantBool)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		new bool get_IsNumber(int ch);

		/// <summary>
		/// Return true if Unicode general category starts with Z. See <c>get_GeneralCategory</c>
		///</summary>
		/// <param name='ch'> </param>
		/// <returns></returns>
		[return: MarshalAs(UnmanagedType.VariantBool)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		new bool get_IsSeparator(int ch);

		/// <summary>
		/// Return true if Unicode general category starts with S. See <c>get_GeneralCategory</c>
		///</summary>
		/// <param name='ch'> </param>
		/// <returns></returns>
		[return: MarshalAs(UnmanagedType.VariantBool)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		new bool get_IsSymbol(int ch);

		/// <summary>
		/// Return true if Unicode general category starts with M. See <c>get_GeneralCategory</c>
		///</summary>
		/// <param name='ch'> </param>
		/// <returns></returns>
		[return: MarshalAs(UnmanagedType.VariantBool)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		new bool get_IsMark(int ch);

		/// <summary>
		/// Return true if Unicode general category starts with C. See <c>get_GeneralCategory</c>
		///</summary>
		/// <param name='ch'> </param>
		/// <returns></returns>
		[return: MarshalAs(UnmanagedType.VariantBool)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		new bool get_IsOther(int ch);

		/// <summary> Return true if Unicode general category is Lu. See <c>get_GeneralCategory</c> </summary>
		/// <param name='ch'> </param>
		/// <returns></returns>
		[return: MarshalAs(UnmanagedType.VariantBool)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		new bool get_IsUpper(int ch);

		/// <summary>
		/// Return true if Unicode general category is Ll. See <c>get_GeneralCategory</c>
		/// In languages without case all characters are considered lower case.
		///</summary>
		/// <param name='ch'> </param>
		/// <returns></returns>
		[return: MarshalAs(UnmanagedType.VariantBool)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		new bool get_IsLower(int ch);

		/// <summary>
		/// Return true if Unicode general category is Lt. See <c>get_GeneralCategory</c>
		/// This refers to "Title case" characters, typically a single code point standing for
		/// two letters, where the first is upper case and the second is lower.
		/// Unicode general category Lt, typically digraph with first upper
		///</summary>
		/// <param name='ch'> </param>
		/// <returns></returns>
		[return: MarshalAs(UnmanagedType.VariantBool)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		new bool get_IsTitle(int ch);

		/// <summary> Return true if Unicode general category is Lm. See <c>get_GeneralCategory</c> </summary>
		/// <param name='ch'> </param>
		/// <returns></returns>
		[return: MarshalAs(UnmanagedType.VariantBool)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		new bool get_IsModifier(int ch);

		/// <summary> Return true if Unicode general category is Lo. See <c>get_GeneralCategory</c> </summary>
		/// <param name='ch'> </param>
		/// <returns></returns>
		[return: MarshalAs(UnmanagedType.VariantBool)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		new bool get_IsOtherLetter(int ch);

		/// <summary>
		/// Return true if Unicode general category is Ps. See <c>get_GeneralCategory</c>
		/// Signifies opening punctuation, like left paren
		/// ENHANCE JohnT: Should opening include Pi, Initial quote?
		///</summary>
		/// <param name='ch'> </param>
		/// <returns></returns>
		[return: MarshalAs(UnmanagedType.VariantBool)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		new bool get_IsOpen(int ch);

		/// <summary>
		/// Return true if Unicode general category is Pe. See <c>get_GeneralCategory</c>
		/// Signifies closing punctuation, like right paren.
		/// ENHANCE JohnT: should we also include Pf, final quote?
		///</summary>
		/// <param name='ch'> </param>
		/// <returns></returns>
		[return: MarshalAs(UnmanagedType.VariantBool)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		new bool get_IsClose(int ch);

		/// <summary>
		/// Return true if Unicode general category is Pc. See <c>get_GeneralCategory</c>
		/// Signifies middle of a word, like hyphen.
		/// ENHANCE JohnT: should we also include Pd, dash
		///</summary>
		/// <param name='ch'> </param>
		/// <returns></returns>
		[return: MarshalAs(UnmanagedType.VariantBool)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		new bool get_IsWordMedial(int ch);

		/// <summary> Return true if Unicode general category is Cc. See <c>get_GeneralCategory</c> </summary>
		/// <param name='ch'> </param>
		/// <returns></returns>
		[return: MarshalAs(UnmanagedType.VariantBool)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		new bool get_IsControl(int ch);

		/// <summary>
		/// Convert a character to lower case if it is Lu or Lt; otherwise return it unchanged.
		/// ENHANCE JohnT: should we convert characters that are not Lu or Lt but for which
		/// UnicodeData.txt specifies a case conversion?
		///
		/// See <c>ToLower</c> to convert an entire string, or to make use of Unicode mulicharacter
		/// conversions.
		///</summary>
		/// <param name='ch'> </param>
		/// <returns></returns>
		/// <exception cref="ArgumentException">if passed invalid Unicode code point, including one half
		/// of a surrogate pair. (E_INVALIDARG)</exception>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		new int get_ToLowerCh(int ch);

		/// <summary>
		/// Convert a character to upper case if it is Ll or Lt; otherwise return it unchanged.
		/// ENHANCE JohnT: should we convert characters that are not Ll or Lt but for which
		/// UnicodeData.txt specifies a case conversion?
		///
		/// See <c>ToUpper</c> to convert an entire string, or to make use of Unicode mulicharacter
		/// conversions.
		///</summary>
		/// <param name='ch'> </param>
		/// <returns></returns>
		/// <exception cref="ArgumentException">if passed invalid Unicode code point, including one half
		/// of a surrogate pair. (E_INVALIDARG)</exception>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		new int get_ToUpperCh(int ch);

		/// <summary>
		/// Convert a character to title case if it is Lu or Ll; otherwise return it unchanged.
		/// Usually this is the same as converting it to upper case.
		/// ENHANCE JohnT: should we convert characters that are not Lu or Ll but for which
		/// UnicodeData.txt specifies a case conversion?
		///
		/// See <c>ToTitle</c> to convert an entire string, or to make use of Unicode mulicharacter
		/// conversions.
		///</summary>
		/// <param name='ch'> </param>
		/// <returns></returns>
		/// <exception cref="ArgumentException">if passed invalid Unicode code point, including one half
		/// of a surrogate pair. (E_INVALIDARG)</exception>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		new int get_ToTitleCh(int ch);

		/// <summary>
		/// Convert a string to lower case. Characters that are not Lu or Lt pass through
		/// unchanged. Note that the output may be longer than the input! This function, unlike
		/// <c>get_ToLowerCh</c>, will apply multicharacter conversions if Unicode specifies them.
		///</summary>
		/// <param name='bstr'> </param>
		/// <returns></returns>
		/// <exception cref="ArgumentException">if characters in input are not valid Unicode. (E_INVALIDARG)</exception>
		[return: MarshalAs(UnmanagedType.BStr)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		new string ToLower([MarshalAs(UnmanagedType.BStr)] string bstr);

		/// <summary>
		/// Convert a string to upper case. Characters that are not Ll or Lt pass through
		/// unchanged. Note that the output may be longer than the input! This function, unlike
		/// <c>get_ToUpperCh</c>, will apply multicharacter conversions if Unicode specifies them.
		///</summary>
		/// <param name='bstr'> </param>
		/// <returns></returns>
		/// <exception cref="ArgumentException">if characters in input are not valid Unicode. (E_INVALIDARG)</exception>
		[return: MarshalAs(UnmanagedType.BStr)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		new string ToUpper([MarshalAs(UnmanagedType.BStr)] string bstr);

		/// <summary>
		/// Convert a string to title case. Characters that are not Lu or Ll pass through
		/// unchanged. Note that the output may be longer than the input! This function, unlike
		/// <c>get_ToUpperCh</c>, will apply multicharacter conversions if Unicode specifies them.
		/// Note that this is not usually useful, because if you want title case, you usually
		/// want to convert only the first nonpunctuation character, or perhaps the first of
		/// each word. However, this at least provides a way to get at multicharacter
		/// conversions by passing a single character input string.
		///</summary>
		/// <param name='bstr'> </param>
		/// <returns></returns>
		/// <exception cref="ArgumentException">if characters in input are not valid Unicode. (E_INVALIDARG)</exception>
		[return: MarshalAs(UnmanagedType.BStr)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		new string ToTitle([MarshalAs(UnmanagedType.BStr)] string bstr);

		/// <summary>
		/// Convert a string to lower case. Characters that are not Lu or Lt pass through
		/// unchanged. Note that the output may be longer than the input! This function, unlike
		/// <c>get_ToLowerCh</c>, will apply multicharacter conversions if Unicode specifies them.
		/// If cchOut is zero, just return the length needed.
		///</summary>
		/// <param name='_rgchIn'> </param>
		/// <param name='cchIn'> </param>
		/// <param name='_rgchOut'> </param>
		/// <param name='cchOut'> </param>
		/// <param name='_cchRet'> </param>
		/// <exception cref="ArgumentException">if characters in input are not valid Unicode. (E_INVALIDARG)</exception>
		/// <exception cref="COMException">if cchOut is nonzero and too small (E_FAIL)</exception>
		[TypeLibFunc(TypeLibFuncFlags.FRestricted)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		new void ToLowerRgch([MarshalAs(UnmanagedType.LPWStr)] string _rgchIn, int cchIn, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef=typeof(ArrayPtrMarshaler))] ArrayPtr/*OLECHAR[]*/ _rgchOut, int cchOut, out int _cchRet);

		/// <summary>
		/// Convert a string to upper case. Characters that are not Ll or Lt pass through
		/// unchanged. Note that the output may be longer than the input! This function, unlike
		/// <c>get_ToUpperCh</c>, will apply multicharacter conversions if Unicode specifies them.
		/// If cchOut is zero, just return the length needed.
		///</summary>
		/// <param name='_rgchIn'> </param>
		/// <param name='cchIn'> </param>
		/// <param name='_rgchOut'> </param>
		/// <param name='cchOut'> </param>
		/// <param name='_cchRet'> </param>
		/// <exception cref="ArgumentException">if characters in input are not valid Unicode. (E_INVALIDARG)</exception>
		/// <exception cref="COMException">if cchOut is nonzero and too small (E_FAIL)</exception>
		[TypeLibFunc(TypeLibFuncFlags.FRestricted)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		new void ToUpperRgch([MarshalAs(UnmanagedType.LPWStr)] string _rgchIn, int cchIn, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef=typeof(ArrayPtrMarshaler))] ArrayPtr/*OLECHAR[]*/ _rgchOut, int cchOut, out int _cchRet);

		/// <summary>
		/// Convert a string to title case. Characters that are not Lu or Ll pass through
		/// unchanged. Note that the output may be longer than the input! This function, unlike
		/// <c>get_ToUpperCh</c>, will apply multicharacter conversions if Unicode specifies them.
		/// Note that this is not usually useful, because if you want title case, you usually
		/// want to convert only the first nonpunctuation character, or perhaps the first of
		/// each word. However, this at least provides a way to get at multicharacter
		/// conversions by passing a single character input string.
		/// If cchOut is zero, just return the length needed.
		///</summary>
		/// <param name='_rgchIn'> </param>
		/// <param name='cchIn'> </param>
		/// <param name='_rgchOut'> </param>
		/// <param name='cchOut'> </param>
		/// <param name='_cchRet'> </param>
		/// <exception cref="ArgumentException">if characters in input are not valid Unicode. (E_INVALIDARG)</exception>
		/// <exception cref="COMException">if cchOut is nonzero and too small (E_FAIL)</exception>
		[TypeLibFunc(TypeLibFuncFlags.FRestricted)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		new void ToTitleRgch([MarshalAs(UnmanagedType.LPWStr)] string _rgchIn, int cchIn, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef=typeof(ArrayPtrMarshaler))] ArrayPtr/*OLECHAR[]*/ _rgchOut, int cchOut, out int _cchRet);

		/// <summary>
		/// Returns true if the specified code point is a member of the specified user defined
		/// class of code points. Nathan thinks we should restrict class names to a single
		/// character to make patterns containing them more readable. Example \C\Vxyz for all
		/// words containing a consonant, followed by a vowel, followed by xyz.
		///
		/// Not yet implemented, and may not be, as it is not clear that this is the right place
		/// to store user defined character classes.
		///</summary>
		/// <param name='ch'> </param>
		/// <param name='chClass'> </param>
		/// <returns></returns>
		[return: MarshalAs(UnmanagedType.VariantBool)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		new bool get_IsUserDefinedClass(int ch, int chClass);

		/// <summary>
		/// Converts a string into another string in which all characters are replaced with their
		/// sound alike equivalent. For example, if for this language s and z where specified to
		/// sound alike, we could take s as the generic form and convert all z's to this form.
		/// Note that we need to support the possibility that 0 (empty code point) and x and y
		/// sound alike which means that all x's and 's and y's will be ignored when testing for
		/// sound alikeness.
		///
		/// ENHANCE JohnT: Should this be a separate engine? Does it belong to the spelling
		/// engine?
		/// ENHANCE Development(JohnT): enhance the specification so it can specify soundalikes.
		///
		/// Not yet implemented, and may never be.
		///</summary>
		/// <param name='bstrValue'> </param>
		/// <returns></returns>
		[return: MarshalAs(UnmanagedType.BStr)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		new string get_SoundAlikeKey([MarshalAs(UnmanagedType.BStr)] string bstrValue);

		/// <summary>
		/// Get the official Unicode character name (character database field 1).
		/// Will also produce a somewhat helpful descriptive string for surrogate halves and
		/// PUA characters, though officially they have no name.
		/// (Warning: obtaining this for the first character in each page will be somewhat slow,
		/// and will use up something like 10K of RAM).
		///</summary>
		/// <param name='ch'> </param>
		/// <returns></returns>
		/// <exception cref="ArgumentException">if character input is not valid Unicode. (E_INVALIDARG)</exception>
		[return: MarshalAs(UnmanagedType.BStr)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		new string get_CharacterName(int ch);

		/// <summary>
		/// Get the decomposition of this character (Unicode char database field 5).
		/// Empty string if it does not decompose.
		///</summary>
		/// <param name='ch'> </param>
		/// <returns></returns>
		/// <exception cref="ArgumentException">if character input is not valid Unicode. (E_INVALIDARG)</exception>
		[return: MarshalAs(UnmanagedType.BStr)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		new string get_Decomposition(int ch);

		/// <summary>
		/// Get the decomposition of this character (Unicode char database field 5).
		/// Empty string if it does not decompose.
		///</summary>
		/// <param name='ch'> </param>
		/// <param name='cchMax'> </param>
		/// <param name='_rgch'> </param>
		/// <param name='_cch'> </param>
		/// <param name='_fHasDecomp'> </param>
		/// <exception cref="ArgumentException">if character input is not valid Unicode. (E_INVALIDARG)</exception>
		[TypeLibFunc(TypeLibFuncFlags.FRestricted)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		new void DecompositionRgch(int ch, int cchMax, out ushort _rgch, out int _cch, [MarshalAs(UnmanagedType.VariantBool)] out bool _fHasDecomp);

		/// <summary>
		/// Get the recursive canonical decomposition of a character. Empty string if it does
		/// not decompose at all.
		///</summary>
		/// <param name='ch'> </param>
		/// <returns></returns>
		/// <exception cref="ArgumentException">if character input is not valid Unicode. (E_INVALIDARG)</exception>
		[return: MarshalAs(UnmanagedType.BStr)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		new string get_FullDecomp(int ch);

		/// <summary>
		/// Get the recursive canonical decomposition of a character. The character itself if it
		/// does not decompose at all.
		///</summary>
		/// <param name='ch'> </param>
		/// <param name='cchMax'> </param>
		/// <param name='_rgch'> </param>
		/// <param name='_cch'> </param>
		/// <param name='_fHasDecomp'> </param>
		/// <exception cref="ArgumentException">if character input is not valid Unicode. (E_INVALIDARG)</exception>
		[TypeLibFunc(TypeLibFuncFlags.FRestricted)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		new void FullDecompRgch(int ch, int cchMax, out ushort _rgch, out int _cch, [MarshalAs(UnmanagedType.VariantBool)] out bool _fHasDecomp);

		/// <summary>
		/// Get the character's value as a number.(Field 8 in
		/// <see href="www.unicode.org/Public/UNIDATA/UnicodeData.html">www.unicode.org/Public/UNIDATA/UnicodeData.html</see>).
		///
		/// ENHANCE JohnT: is there a more useful behavior for the fraction case?
		/// Would it be better to return 0 for all cases where we don't know a useful answer?
		///</summary>
		/// <param name='ch'> </param>
		/// <returns></returns>
		/// <exception cref="COMException">if the character is not
		/// one of the Nd, Nl, or No types, or if it is one of those types but the
		/// Unicode database gives no numeric value for it.
		/// Currently also if the character represents a fraction. (E_UNEXPECTED)</exception>
		/// <exception cref="ArgumentException">if character input is not valid Unicode. (E_INVALIDARG)</exception>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		new int get_NumericValue(int ch);

		/// <summary>
		/// Get the character's combining class (Unicode char database field 3; see
		/// <see href="www.unicode.org/Public/UNIDATA/UnicodeData.html#Canonical%20Combining%20Classes">www.unicode.org/Public/UNIDATA/UnicodeData.html#Canonical%20Combining%20Classes</see>)
		///</summary>
		/// <param name='ch'> </param>
		/// <returns></returns>
		/// <exception cref="ArgumentException">if character input is not valid Unicode. (E_INVALIDARG)</exception>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		new int get_CombiningClass(int ch);

		/// <summary>
		/// Get any comment recorded about this character (Unicode char database field 11).
		/// Note: currently this is not implemented to obtain the rather uninteresting comments
		/// recorded in the standard UnicodeDatabase file. It will give interesting answers only
		/// if a comment is provided in the specification for this writing system.
		///</summary>
		/// <param name='ch'> </param>
		/// <returns></returns>
		[return: MarshalAs(UnmanagedType.BStr)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		new string get_Comment(int ch);

		/// <summary>
		/// Get line breaking properties (from enumeration LgLBP) for an array of characters.
		/// This passes an array in, and an array with the same number of elements out, to
		/// improve efficiency when properties are required for a string of characters.
		/// See <see href="www.unicode.org/unicode/reports/tr14/">www.unicode.org/unicode/reports/tr14/</see>.
		///</summary>
		/// <param name='_rgchIn'> </param>
		/// <param name='cchIn'> </param>
		/// <param name='_rglbOut'> </param>
		/// <exception cref="ArgumentException">if characters in input are not valid Unicode. (E_INVALIDARG)</exception>
		[TypeLibFunc(TypeLibFuncFlags.FRestricted)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		new void GetLineBreakProps([MarshalAs(UnmanagedType.LPWStr)] string _rgchIn, int cchIn, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef=typeof(ArrayPtrMarshaler))] ArrayPtr/*byte[]*/ _rglbOut);

		/// <summary>
		/// Get line break status (from combinations of values in enumeration LgLineBreakStatus)
		/// of each character in the input array.
		///</summary>
		/// <param name='_rglbpIn'> </param>
		/// <param name='cb'> </param>
		/// <param name='_rglbsOut'> </param>
		/// <exception cref="ArgumentException">if characters in input are not valid Unicode. (E_INVALIDARG)</exception>
		[TypeLibFunc(TypeLibFuncFlags.FRestricted)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		new void GetLineBreakStatus([MarshalAs(UnmanagedType.LPArray, SizeParamIndex=1)] byte[] _rglbpIn, int cb, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef=typeof(ArrayPtrMarshaler))] ArrayPtr/*byte[]*/ _rglbsOut);

		/// <summary>
		/// This combines the functions of <c>GetLineBreakProps</c> and <c>GetLineBreakStatus</c>,
		/// plus the ability to skip part of the string, and stop at break characters.
		///
		/// The first two arguments define an array of characters as for <c>GetLineBreakProps</c>.
		/// The output is basically what would be produced by passing the output of
		/// that method as input to GetLineBreakStatus, with two exceptions:
		///
		/// 1. We only want line break status info for characters from ichMin to ichLim.
		/// (A larger array is passed in because we may need to look at preceding characters
		/// to confidently know whether we can break after the char at ichMin.)
		///
		/// 2. If we detect a character which forces a line or segment break in the range
		/// ichMin..ichLim, we stop and do not return any info about subsequent characters.
		///
		/// Also, we set pichBreak to the index of the break character.
		/// pichBreak is set to 1 if we don't find a break character.
		/// Break characters are things like CR, LF, TAB, or the embedded object character.
		///</summary>
		/// <param name='_rgchIn'> </param>
		/// <param name='cchIn'> </param>
		/// <param name='ichMin'> </param>
		/// <param name='ichLim'> </param>
		/// <param name='_rglbsOut'> </param>
		/// <param name='_ichBreak'> </param>
		[TypeLibFunc(TypeLibFuncFlags.FRestricted)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		new void GetLineBreakInfo([MarshalAs(UnmanagedType.LPWStr)] string _rgchIn, int cchIn, int ichMin, int ichLim, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef=typeof(ArrayPtrMarshaler))] ArrayPtr/*byte[]*/ _rglbsOut, out int _ichBreak);

		/// <summary>
		/// Strip diacritics. Specifically, removes all characters that have the property Lm on
		/// Mn. Note that this will not comvert a single code point that includes a diacritic to
		/// its unmodified equivalent. It is usually desireable to first perform normalization
		/// (form D or KD) before stripping diacritics.
		///</summary>
		/// <param name='bstr'> </param>
		/// <returns></returns>
		[return: MarshalAs(UnmanagedType.BStr)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		new string StripDiacritics([MarshalAs(UnmanagedType.BStr)] string bstr);

		/// <summary>
		/// Strip diacritics. Specifically, removes all characters that have the property Lm or
		/// Mn. Note that this will not comvert a single code point that includes a diacritic to
		/// its unmodified equivalent. It is usually desireable to first perform normalization
		/// (form D or KD) before stripping diacritics.
		///</summary>
		/// <param name='_rgchIn'> </param>
		/// <param name='cchIn'> </param>
		/// <param name='_rgchOut'> </param>
		/// <param name='cchMaxOut'> </param>
		/// <param name='_cchOut'> </param>
		[TypeLibFunc(TypeLibFuncFlags.FRestricted)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		new void StripDiacriticsRgch([MarshalAs(UnmanagedType.LPWStr)] string _rgchIn, int cchIn, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef=typeof(ArrayPtrMarshaler))] ArrayPtr/*OLECHAR[]*/ _rgchOut, int cchMaxOut, out int _cchOut);

		/// <summary>
		/// Perform compatibility normalization of the input string, that is, every character
		/// which has a compatibility decomposition is decomposed (recursively). This is
		/// Normalization Form KD (NFKD) as defined by Unicode TR 15.
		///</summary>
		/// <param name='_rgchIn'> </param>
		/// <param name='cchIn'> </param>
		/// <param name='_rgchOut'> </param>
		/// <param name='cchMaxOut'> </param>
		/// <param name='_cchOut'> </param>
		[TypeLibFunc(TypeLibFuncFlags.FRestricted)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		new void NormalizeKdRgch([MarshalAs(UnmanagedType.LPWStr)] string _rgchIn, int cchIn, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef=typeof(ArrayPtrMarshaler))] ArrayPtr/*OLECHAR[]*/ _rgchOut, int cchMaxOut, out int _cchOut);

		/// <summary>
		/// Perform normalization of the input string, that is, every character
		/// which has a decomposition is decomposed (recursively). This is
		/// Normalization Form D (NFD) as defined by Unicode TR 15.
		///</summary>
		/// <param name='bstr'> </param>
		/// <returns></returns>
		[return: MarshalAs(UnmanagedType.BStr)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		new string NormalizeD([MarshalAs(UnmanagedType.BStr)] string bstr);

		/// <summary>
		/// Perform compatibility normalization of the input string, that is, every character
		/// which has a compatibility decomposition is decomposed (recursively). This is
		/// Normalization Form D (NFD) as defined by Unicode TR 15.
		///</summary>
		/// <param name='_rgchIn'> </param>
		/// <param name='cchIn'> </param>
		/// <param name='_rgchOut'> </param>
		/// <param name='cchMaxOut'> </param>
		/// <param name='_cchOut'> </param>
		[TypeLibFunc(TypeLibFuncFlags.FRestricted)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		new void NormalizeDRgch([MarshalAs(UnmanagedType.LPWStr)] string _rgchIn, int cchIn, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef=typeof(ArrayPtrMarshaler))] ArrayPtr/*OLECHAR[]*/ _rgchOut, int cchMaxOut, out int _cchOut);

		/// <summary>
		/// Returns the locale of the engine. See put_Locale for more notes.
		/// Assigns the locale of the engine. The locale affects the ICU functions called for
		/// line breaking and changing cases. Note that the locale is read in using the
		/// Microsoft format we've been using for the rest of FieldWorks, as opposed to the ICU
		/// format (which it's translated into inside the class implementation).
		///</summary>
		/// <returns>A System.Int32 </returns>
		new int Locale
		{
			[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
			get;
			[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
			set;
		}

		/// <summary>
		/// Gets the text that the LineBreakBefore and LineBreakAfter functions are using. This
		/// function is included for completion.
		///</summary>
		/// <param name='cchMax'> </param>
		/// <param name='_rgchOut'> </param>
		/// <param name='_cchOut'> </param>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		new void GetLineBreakText(int cchMax, out ushort _rgchOut, out int _cchOut);

		/// <summary> Sets the text for the LineBreakBefore and the LineBreakAfter functions to use. </summary>
		/// <param name='_rgchIn'> </param>
		/// <param name='cchMax'> </param>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		new void set_LineBreakText([MarshalAs(UnmanagedType.LPWStr)] string _rgchIn, int cchMax);

		/// <summary>
		/// Finds the nearest line break immediately before the given index (ichIn). The
		/// function returns not only a location but the weight of the line break (currently not
		/// implemented). See http:www.unicode.org/unicode/reports/tr14/ for more information
		/// on line breaking properties.
		///</summary>
		/// <param name='ichIn'> </param>
		/// <param name='_ichOut'> </param>
		/// <param name='_lbWeight'> </param>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		new void LineBreakBefore(int ichIn, out int _ichOut, out LgLineBreak _lbWeight);

		/// <summary>
		/// Finds the nearest line break immediately after the given index (ichIn). The function
		/// returns not only a location but the weight of the line break (currently not
		/// implemented). See http:www.unicode.org/unicode/reports/tr14/ for more information
		/// on line breaking properties.
		///</summary>
		/// <param name='ichIn'> </param>
		/// <param name='_ichOut'> </param>
		/// <param name='_lbWeight'> </param>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		new void LineBreakAfter(int ichIn, out int _ichOut, out LgLineBreak _lbWeight);

		/// <summary> </summary>
		/// <param name='bstrLanguage'> </param>
		/// <param name='bstrScript'> </param>
		/// <param name='bstrCountry'> </param>
		/// <param name='bstrVariant'> </param>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void Initialize([MarshalAs(UnmanagedType.BStr)] string bstrLanguage, [MarshalAs(UnmanagedType.BStr)] string bstrScript, [MarshalAs(UnmanagedType.BStr)] string bstrCountry, [MarshalAs(UnmanagedType.BStr)] string bstrVariant);

		/// <summary> </summary>
		/// <param name='bstrWsCharsList'> </param>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void InitCharOverrides([MarshalAs(UnmanagedType.BStr)] string bstrWsCharsList);
	}

	/// <summary>
	/// Interface ILgSearchEngine
	/// Knows how to search for a pattern in a string. Also how to throw up a dialog for
	/// asking what to search for.
	/// ENHANCE JohnT: does throwing up the dialog belong here? That is a UI function...
	/// ENHANCE JohnT: does a search engine belong in the Language component?
	///
	/// <h3>When to implement</h3>
	/// We expect that the standard implementations will be all you need.
	///
	/// <h3>When to use</h3>
	/// Use this interface to search for a pattern in a string.
	///
	/// <h3>How to obtain an instance</h3>
	/// Currently you can't. No implementations have been attempted.
	///
	/// Hungarian: <c>srcheng</c>
	///</summary>
	[ComImport()]
	[InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]
	[Guid("09FCA8D5-5BF6-4BFF-A317-E0126410D79A")]
	public interface ILgSearchEngine
	{

		/// <summary>
		/// Set up the search engine with a specified pattern.
		/// ENHANCE JohnT: do we need "match whole words only"? Does soundalike make sense
		/// otherwise?
		/// ENHANCE: define wild card syntax to use. (Should they be characters at all? Should we
		/// mark pattern characters with a different writing system and display them specially,
		/// e.g., &lt;start word&gt;?)
		/// ESCES needs at least the following wild card capabilities:
		/// word begin, end
		/// string begin, end. The size of string is up to the caller of FindString,
		/// typically a paragraph.
		/// predefined character classes: punctuation, white space, letter, symbol, number,
		/// the various types of letter defined for character classification.
		/// userdefined character classes (e.g., consonants, low vowels)
		/// (The find dialog should allow these to be edited.)
		/// occurrence specifications (optional, 0 or more, 1 or more, range)
		/// ENHANCE: for a replace method, we would also need wild cards to mark start and end
		/// of substring for use in the output. This can also be useful in the find pattern,
		/// to say "what I found earlier must occur again"e.g. for vowel harmony.
		///</summary>
		/// <param name='bstrPattern'> </param>
		/// <param name='fIgnoreCase'> </param>
		/// <param name='fIgnoreModifiers'> </param>
		/// <param name='fUseSoundAlike'> </param>
		/// <param name='fUseWildCards'> </param>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void SetPattern([MarshalAs(UnmanagedType.BStr)] string bstrPattern, [MarshalAs(UnmanagedType.VariantBool)] bool fIgnoreCase, [MarshalAs(UnmanagedType.VariantBool)] bool fIgnoreModifiers, [MarshalAs(UnmanagedType.VariantBool)] bool fUseSoundAlike, [MarshalAs(UnmanagedType.VariantBool)] bool fUseWildCards);

		/// <summary>
		/// Set the replacement string/pattern. Required only if replacing.
		/// ENHANCE JohnT: should this be an optional argument to SetPattern? Or, should this
		/// method have all the arguments of SetPattern as well?
		///</summary>
		/// <param name='bstrPattern'> </param>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void SetReplacePattern([MarshalAs(UnmanagedType.BStr)] string bstrPattern);

		/// <summary>
		/// Throw up a dialog which requests from the user, in an appropriate form for the
		/// specified writing system, a search pattern. The information requested is that
		/// provided by the SetPattern method.
		///</summary>
		/// <param name='bstrTitle'> To show in dialogClarify: in title bar? </param>
		/// <param name='_wse'> WS to use for display; if NULL, use default ws </param>
		/// <param name='fForReplace'> If true, include replace with field </param>
		/// <returns> true to proceed with search, false to cancel</returns>
		[return: MarshalAs(UnmanagedType.VariantBool)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		bool ShowPatternDialog([MarshalAs(UnmanagedType.BStr)] string bstrTitle, [MarshalAs(UnmanagedType.Interface)] ILgWritingSystem _wse, [MarshalAs(UnmanagedType.VariantBool)] bool fForReplace);

		/// <summary>
		/// Search for a string.
		/// ENHANCE JohnT: probably a similar method FindStringRgch, probably also FindStringTss
		///</summary>
		/// <param name='bstrSource'> </param>
		/// <param name='ichFirst'> start searching here </param>
		/// <param name='ichMinFound'> </param>
		/// <param name='ichLimFound'> </param>
		/// <returns></returns>
		[return: MarshalAs(UnmanagedType.VariantBool)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		bool FindString([MarshalAs(UnmanagedType.BStr)] string bstrSource, int ichFirst, out int ichMinFound, out int ichLimFound);

		/// <summary>
		/// Find a substring and indicate what should replace it, if the client decides to
		/// go ahead. Answers S_OK if found, S_FALSE if not found, possibly ERROR codes.
		/// (Inconsistent with FindString, but keeps it down to one OUT param for VB.)
		/// ENHANCE JohnT: should we change FindString to return S_OK/S_FALSE to conform?
		/// Should we have this method just return the replacement string (for the last
		/// thing found by FindString)?
		///</summary>
		/// <param name='bstrSource'> </param>
		/// <param name='ichFirst'> start searching here </param>
		/// <param name='ichMinFound'> </param>
		/// <param name='ichLimFound'> </param>
		/// <returns> (maybe deduced from pattern)</returns>
		[return: MarshalAs(UnmanagedType.BStr)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		string FindReplace([MarshalAs(UnmanagedType.BStr)] string bstrSource, int ichFirst, out int ichMinFound, out int ichLimFound);
	}

	/// <summary>
	/// Interface ILgStringConverter
	/// Knows how to convert strings from one writing system to another (or similar functions).
	/// Hungarian: strconv
	///
	/// ENHANCE JohnT: this class implements the main method of Ken's IStringConvert interface,
	/// but not its initialization approach; this engine must be initializable from a moniker.
	/// Is there a way we can capture the commonality?
	///
	/// Note also: NRSI is interested in implementing string converters, but have identified
	/// a need for a different interface based that is more stream like. This allows a client
	/// to "pull" as much output as needed, and the converter to process only as much text
	/// as needed. It also allows converters to be conveniently chained together for a more
	/// complex conversion. Thus, we may end up with a quite different interface.
	///
	/// A further complication is the need to apply conversions to only the CDATA parts of
	/// XML files, or even to apply different conversions to different elements. This area
	/// requires considerable further design work.
	///
	/// <h3>When to implement</h3>
	/// Implement this interface if you need to plug in a custom string converter for one of
	/// the components that use such converters. First check out the standard implementations.
	///
	/// <h3>When to use</h3>
	/// Use this interface to make systematic changes to strings.
	///
	/// <h3>How to obtain an instance</h3>
	/// Currently you can't. No implementations have been attempted.
	///
	/// Hungarian: <c>srcheng</c>
	///</summary>
	[ComImport()]
	[InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]
	[Guid("8BE2C911-6A81-48B5-A27F-B8CE63983082")]
	public interface ILgStringConverter
	{

		/// <summary>
		/// Convert a string.
		/// ENHANCE JohnT: how will we handle strings that can't be converted without user
		/// intervention? Does this method fail, and some other process picks up the unconverted
		/// strings? What if parts of the string can be converted but others can't?
		/// Is this method allowed to UI? Should there be explicit control of that? Should it
		/// instead have a callback to ask what to do about ambiguities?
		///</summary>
		/// <param name='bstrIn'> </param>
		/// <returns></returns>
		[return: MarshalAs(UnmanagedType.BStr)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		string ConvertString([MarshalAs(UnmanagedType.BStr)] string bstrIn);

		/// <summary>
		/// Convert a string.
		/// ENHANCE JohnT: another idea is that if the buffer is too small or NULL, it sets
		/// pcchOut to the required size and fills in as much as will fit. An error is not
		/// reported, so the client must be careful to check that pcchOut is &lt;= cchMax.
		/// There should be some way for the client to just find out how big a buffer is
		/// needed.
		/// ENHANCE JohnT: Ken's interface calls this method ConvertStrngCP, I think.
		///</summary>
		/// <param name='_rgch'> </param>
		/// <param name='cch'> </param>
		/// <param name='cchMax'> </param>
		/// <param name='_rgchOut'> </param>
		/// <param name='_cchOut'> </param>
		/// <exception cref="COMException">if the output buffer won't hold the output (E_BUFFER_TOO_SMALL)</exception>
		[TypeLibFunc(TypeLibFuncFlags.FRestricted)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void ConvertStringRgch([MarshalAs(UnmanagedType.LPWStr)] string _rgch, int cch, int cchMax, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef=typeof(ArrayPtrMarshaler))] ArrayPtr/*OLECHAR[]*/ _rgchOut, out int _cchOut);
	}

	/// <summary>
	/// Interface ILgTokenizer
	/// Knows how to find some kind of 'tokens' in the input string.
	///
	/// <h3>When to implement</h3>
	/// Implement this interface if you need to plug in a special tokenizer for your language.
	/// First check out the standard implementations to see if one can be customized.
	///
	/// <h3>When to use</h3>
	/// Use this interface to break strings up into smaller pieces. Particular implementations
	/// are optimized for certain kinds of tokens (and ways of specifying tokens).
	///
	/// <h3>How to obtain an instance</h3>
	/// Currently you can't. No implementations have been attempted.
	///
	/// Hungarian: <c>toker</c>
	///</summary>
	[ComImport()]
	[InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]
	[Guid("577C6DA1-CFC1-4AFB-82B2-AF818EC2FE9F")]
	public interface ILgTokenizer
	{

		/// <summary>
		/// Get the next token of whatever kind this tokenizer supports from the input string.
		/// Set pichMin to the offset of the first character of the token, and pichLim
		/// to the offset of the first character after the token.
		///</summary>
		/// <param name='_rgchInput'>points to the text to tokenize.
		/// If it has more than cch characters, the rest will be ignored.
		/// ENHANCE JohnT: should we pass an ichMin? </param>
		/// <param name='cch'>specifies the number of characters in the input string </param>
		/// <param name='_ichMin'> </param>
		/// <param name='_ichLim'> </param>
		/// <exception cref="COMException">if no more tokens available. Also set pichMin and pichLim to 1. (E_FAIL)</exception>
		[TypeLibFunc(TypeLibFuncFlags.FRestricted)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void GetToken([MarshalAs(UnmanagedType.LPWStr)] string _rgchInput, int cch, out int _ichMin, out int _ichLim);

		/// <summary>
		/// Get the start of the first token that begins at or after offset
		/// ichFirst in the input string bstrInput.
		/// Characters before ichFirst are not examined; the result is as if the string
		/// began at ichFirst.
		///</summary>
		/// <param name='bstrInput'> </param>
		/// <param name='ichFirst'> </param>
		/// <returns></returns>
		/// <exception cref="COMException">if no token found (E_FAIL)</exception>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		int get_TokenStart([MarshalAs(UnmanagedType.BStr)] string bstrInput, int ichFirst);

		/// <summary>
		/// Get the end of the first token that BEGINS at or after ichFirst.
		/// Note: ichFirst may be the result obtained from a previous call to TokenStart,
		/// rather than the value passed to TokenStart, but to obtain the limit of the same
		/// token it must not be larger than that. In other words, this method does NOT
		/// find the first endoftoken at or after ichFirst: it must find a complete token
		/// starting there.
		///</summary>
		/// <param name='bstrInput'> </param>
		/// <param name='ichFirst'> </param>
		/// <returns></returns>
		/// <exception cref="COMException">if no token found (E_FAIL)</exception>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		int get_TokenEnd([MarshalAs(UnmanagedType.BStr)] string bstrInput, int ichFirst);
	}

	/// <summary>
	/// Standard MS Word spell checker options
	/// Many implementations will ignore some of these
	/// ENHANCE JohnT: any others we need?
	///</summary>
	public enum LgSpellCheckOptions
	{

		/// <summary> </summary>
		fsplcNil = 0,

		/// <summary> </summary>
		fsplcSuggestFromUserDict = 1,

		/// <summary> </summary>
		fsplcIgnoreAllCaps = 2,

		/// <summary> </summary>
		fsplcIgnoreMixedDigits = 4,

		/// <summary> </summary>
		fsplcIgnoreRomanNumerals = 8,

		/// <summary> </summary>
		fsplcFindUncappedSentences = 16,

		/// <summary> </summary>
		fsplcFindMissingSpaces = 32,

		/// <summary> </summary>
		fsplcFindRepeatWord = 64,

		/// <summary> </summary>
		fsplcFindExtraSpaces = 128,

		/// <summary> </summary>
		fsplcFindSpacesBeforePunc = 256,

		/// <summary> </summary>
		fsplcFindSpacesAfterPunc = 512,

		/// <summary> </summary>
		fsplcFindInitialNumerals = 2048,

		/// <summary> </summary>
		fsplcQuickSuggest = 8192,

		/// <summary> </summary>
		fsplcUseAllOpenUdr = 16384,

		/// <summary> </summary>
		fsplcSglStepSugg = 65536,

		/// <summary> </summary>
		fsplcIgnoreSingleLetter = 131072,
	}

	/// <summary>
	/// Standard MS Word spell checker result codes. Most implementations
	/// will not generate all of these.
	///</summary>
	public enum LgSpellCheckResults
	{

		/// <summary>/ All buffer processed. </summary>
		scrsNoErrors = 0,

		/// <summary>/ Unknown word. </summary>
		scrsUnknownInputWord = 1,

		/// <summary>/ Returning a Change Always word. </summary>
		scrsReturningChangeAlways = 2,

		/// <summary>/ Returning a Change Once word. </summary>
		scrsReturningChangeOnce = 3,

		/// <summary>/ Error in hyphenation point. </summary>
		scrsInvalidHyphenation = 4,

		/// <summary>/ Cap pattern not valid. </summary>
		scrsErrorCapitalization = 5,

		/// <summary>/ Word is considered an abbreviation. </summary>
		scrsWordConsideredAbbreviation = 6,

		/// <summary>/ Word changes spelling when not hyphenated. </summary>
		scrsHyphChangesSpelling = 7,

		/// <summary>/ All methods used. </summary>
		scrsNoMoreSuggestions = 8,

		/// <summary>/ More return data than fit in buffer. </summary>
		scrsMoreInfoThanBufferCouldHold = 9,

		/// <summary>/ Start of sentence was not capitalized. </summary>
		scrsNoSentenceStartCap = 10,

		/// <summary>/ Repeat word found. </summary>
		scrsRepeatWord = 11,

		/// <summary>/ Too many spaces for context. </summary>
		scrsExtraSpaces = 12,

		/// <summary>/ Too few spaces between words or sentences. </summary>
		scrsMissingSpace = 13,

		/// <summary>/ Word starts with numeral &amp;
		///       fsplcFindInitialNumerals set. </summary>
		scrsInitialNumeral = 14,
	}

	/// <summary>
	/// Interface ILgSpellChecker
	/// Knows how to check spelling and related functions.
	/// Loosely based on the ISpellCheckerWideChar interface which Shon implemented in the
	/// Santa Fe prototype for access to MS Word spelling checkers. The intent is that this
	/// interface could be easily implemented using that; but this interface assumes that
	/// writing systemdependent initialization info is provided independent of the client.
	///
	/// ENHANCE JohnT: How should we handle customization? Should the possibility of a "user
	/// dictionary" be explicit in the interface, or is that just something that some
	/// implementations provide? Some of our spelling checkers will probably allow the
	/// user to add directly to the main dictionary (e.g., if it is their own WFI).
	///
	/// <h3>When to implement</h3>
	/// Usually you will use a standard implementation of this interface. If none of them can
	/// be customized to suit your language you could consider programming a new one (and
	/// perhaps adding it to the list of standard ones, if it is custimizable).
	///
	/// <h3>When to use</h3>
	/// Use this interface when you need to implement spelling checking.
	///
	/// <h3>How to obtain an instance</h3>
	/// Currently you can't. No implementations have been attempted. Eventually you will obtain
	/// one from <c>ILgSpellCheckFactory.get_Checker</c>
	///
	/// Hungarian: <c>spchk</c>
	///</summary>
	[ComImport()]
	[InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]
	[Guid("E3661AF5-26C6-4907-9243-610DAD84D9D4")]
	public interface ILgSpellChecker
	{

		/// <summary> Initialize the checker with a custom dictionary file path. </summary>
		/// <param name='_szwCustom'> </param>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void Init(string _szwCustom);

		/// <summary> Set a combination of the options in LgSpellCheckOptions </summary>
		/// <param name='grfsplc'> </param>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void SetOptions(int grfsplc);

		/// <summary>
		/// Check the specified input buffer. pscrs gets a member of the LgSpellCheckResults
		/// enumeration above. If a problem is found, pbstrBad contains the text to show to the
		/// user as the wrong word, and pichMinBad/pichLimBad indicate where it is. If the
		/// checker has previously been told to "change always" the problem word, pbstrSuggest
		/// contains the previously decided replacement.
		/// ENHANCE JohnT: clarify: can all LgSpellCheckResults values occur on this method? Do
		/// any others result in a pbstrSuggest? Do we expect our spell checkers to note the
		/// various grammatical errors such as sentence start capitalization? Surely "no more
		/// suggestions" and "more info than buffer can hold" don't apply here? When should
		/// "change once" be used? Should it give the first suggestion along with "unknown word"?
		///</summary>
		/// <param name='_rgchw'> </param>
		/// <param name='cchw'> </param>
		/// <param name='_ichMinBad'> </param>
		/// <param name='_ichLimBad'> </param>
		/// <param name='_bstrBad'> </param>
		/// <param name='_bstrSuggest'> </param>
		/// <param name='_scrs'> </param>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void Check([MarshalAs(UnmanagedType.LPWStr)] string _rgchw, int cchw, out int _ichMinBad, out int _ichLimBad, [MarshalAs(UnmanagedType.BStr)] out string _bstrBad, [MarshalAs(UnmanagedType.BStr)] out string _bstrSuggest, out int _scrs);

		/// <summary>
		/// Get a suggestion for the given word. Repeated calls obtain other suggestions;
		/// Call once with fFirst set true, then call with fFirst false until you want no more
		/// suggestions or until the method answers false.
		/// ENHANCE JohnT: is this in fact how the interface is supposed to be used? What if the
		/// most recent call was for a different word, but fFirst is not true?
		///</summary>
		/// <param name='_rgchw'> </param>
		/// <param name='cchw'> </param>
		/// <param name='fFirst'> </param>
		/// <param name='_bstrSuggest'> </param>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void Suggest([MarshalAs(UnmanagedType.LPWStr)] string _rgchw, int cchw, [MarshalAs(UnmanagedType.VariantBool)] bool fFirst, [MarshalAs(UnmanagedType.BStr)] out string _bstrSuggest);

		/// <summary>
		/// Ignore all subsequent occurrences of the argument word (for the lifetime of this
		/// spelling check object, or until FlushIgnoreList is called).
		///</summary>
		/// <param name='_szw'> </param>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void IgnoreAll(string _szw);

		/// <summary>
		/// Record that the user wants pszwDst to be the preferred replacement for pszwSrc.
		/// Henceforth, when pszwSrc is detected as a spelling error, pszwDst will be the
		/// suggestion, and the result code for Check will be scrsReturningChangeAlways.
		/// If fAll is true this happens for all subsequent occurrences of pszwSrc (for the
		/// lifetiem of this object, or until FlushChangeList is called); if false,
		/// it happens only for the next single occurrence (and the result code will be
		/// scrsReturningChangeOnce).
		/// ENHANCE JohnT: is fAll useful? I have never seen a spelling dialog with an option
		/// that corresponds to change once.
		///</summary>
		/// <param name='_szwSrc'> </param>
		/// <param name='_szwDst'> </param>
		/// <param name='fAll'> </param>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void Change(string _szwSrc, string _szwDst, [MarshalAs(UnmanagedType.VariantBool)] bool fAll);

		/// <summary>
		/// Add the specified string to the user dictionary. It should never again be
		/// reported as a spelling error, either by this checker, or any new one that is
		/// subsequently initialized from the same user dictionary.
		/// Fails if a user dictionary was not specified or that capability is not supported.
		/// Some engines may in fact add the word to a master dictionary (e.g, the WFI).
		/// ENHANCE JohnT: clarify: what is the behavior if another checker has previously been
		/// created using the same dictionary? Will it notice the change? Do we care?
		///</summary>
		/// <param name='_szw'> </param>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void AddToUser(string _szw);

		/// <summary> Discard any requests that have been made for words to be ignored. </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void FlushIgnoreList();

		/// <summary>
		/// Discard any requests that have been made for words to be automatically
		/// changed. (ENHANCE JohnT: clarify: what on earth does fAll mean here!!)
		///</summary>
		/// <param name='fAll'> </param>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void FlushChangeList([MarshalAs(UnmanagedType.VariantBool)] bool fAll);
	}

	/// <summary>
	/// Interface ILgSpellCheckFactory
	///
	/// Since ISpellCheckers are transient objects good for one spell check, this is the
	/// persistent object that gets stored in the writing system.
	///
	/// Hungarian: spchk
	///</summary>
	[ComImport()]
	[InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]
	[Guid("9F9298F5-FD41-44B0-83BA-BED9F56CF974")]
	public interface ILgSpellCheckFactory
	{

		/// <summary> Get a checker object ready to be used for one spellcheck session. </summary>
		/// <returns>A ILgSpellChecker </returns>
		ILgSpellChecker Checker
		{
			[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
			[return: MarshalAs(UnmanagedType.Interface)]
			get;
		}
	}

	/// <summary>
	/// Interface ILgNumericEngine
	/// Knows how to convert numbers to and from binary.
	///
	/// ENHANCE JohnT: do we need something analogous to Locales? For example, Australia, US
	/// and Great Britain all use English, but use different date and currency
	/// conventions. They don't actually do numbers differently, but other similar
	/// situations could require that.
	///
	/// ENHANCE JohnT: do we need similar routines for doubles? Do they have languagespecific
	/// formats?
	///
	/// ENHANCE JohnT: do we need a similar engine (or part of this?) for currencies and dates?
	///
	/// ENHANCE JohnT: do we need this at all? Or can we just record a locale in the writing
	/// system and use standard system number formatting?
	///
	/// <h3>When to implement</h3>
	/// Only if you need a number representation that can't be done with any of the standard
	/// approaches.
	///
	/// <h3>When to use</h3>
	/// Use this interface when you need to convert numbers to and from binary in a language dependent way.
	///
	/// <h3>How to obtain an instance</h3>
	/// If we decide to proceed with this notion, there will need to be a method on writing
	/// system to return one. For now the only way is to create one using CoCreateInstance,
	/// with CLSID_LgNumericEngine. This creates a very simple engine that does decimal
	/// numbers but can be customized as to which characters it uses for decimal separator,
	/// thousands separator, exponential notation, and minus. You must QueryInterface
	/// for ISimpleInit and pass an initialization string to set up the special characters.
	/// For example,
	///
	/// <code>
	/// IClassInitMonikerPtr acim;
	/// qcim.CreateInstance(CLSID_LgNumericEngine);
	/// CheckHr(qcim&gt;InitNew((BYTE)L".,E", 4 isizeof(wchar)));
	/// ILgNumericEnginePtr qnumeng;
	/// CheckHr(qcim&gt;QueryInterface(IID_ILgNumericEngine, (void )&amp;qnumeng));
	/// </code>
	///
	/// Hungarian: <c>numeng</c>
	///</summary>
	[ComImport()]
	[InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]
	[Guid("CBBF35E1-CE39-4EEC-AEBD-5B4AAAA52B6C")]
	public interface ILgNumericEngine
	{

		/// <summary> Get the default string version of an integer, e.g., 123456, 654321 </summary>
		/// <param name='n'> </param>
		/// <returns></returns>
		[return: MarshalAs(UnmanagedType.BStr)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		string get_IntToString(int n);

		/// <summary>
		/// Get a string representation of an integer using commas or the equivalent,
		/// e.g., 12,345,678
		///</summary>
		/// <param name='n'> </param>
		/// <returns></returns>
		[return: MarshalAs(UnmanagedType.BStr)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		string get_IntToPrettyString(int n);

		/// <summary>
		/// Get a binary integer corresponding to anything IntToString could output
		/// Can handle leading and trailing white space.
		/// ENHANCE JohnT: should it also handle output of IntToPrettyString?
		///</summary>
		/// <param name='bstr'> </param>
		/// <returns></returns>
		/// <exception cref="COMException">if result will not fit in 32 bit signed int, or if any
		/// characters are not used up in the string (except white space). (E_FAIL)</exception>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		int get_StringToInt([MarshalAs(UnmanagedType.BStr)] string bstr);

		/// <summary>
		/// Get a binary integer corresponding to anything IntToString could output
		/// Can handle leading white space; trailing is handled using pichUnused.
		/// ENHANCE JohnT: should it also handle output of IntToPrettyString?
		///</summary>
		/// <param name='_rgch'> </param>
		/// <param name='cch'> </param>
		/// <param name='_n'> </param>
		/// <param name='_ichUnused'>Set to the index of the first character not processed, that is,
		/// not recognized as part of a number. </param>
		/// <exception cref="COMException">if result will not fit in 32 bit signed int (E_FAIL)</exception>
		[TypeLibFunc(TypeLibFuncFlags.FRestricted)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void StringToIntRgch([MarshalAs(UnmanagedType.LPWStr)] string _rgch, int cch, out int _n, out int _ichUnused);

		/// <summary>
		/// ENHANCE JohnT: should we have hex or other base output?
		/// Get the default string representation of a double, e.g., 1234.56, 6543.21
		///</summary>
		/// <param name='dbl'> </param>
		/// <param name='cchFracDigits'> number of digits after decimal </param>
		/// <returns></returns>
		[return: MarshalAs(UnmanagedType.BStr)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		string get_DblToString(double dbl, int cchFracDigits);

		/// <summary>
		/// Get a string version of a double with commas or the equivalent, e.g., 12,345,678.9
		///</summary>
		/// <param name='dbl'> </param>
		/// <param name='cchFracDigits'> number of digits after decimal </param>
		/// <returns></returns>
		[return: MarshalAs(UnmanagedType.BStr)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		string get_DblToPrettyString(double dbl, int cchFracDigits);

		/// <summary> Get a string representation of a double in exp notation, e.g., 1.2345E3 </summary>
		/// <param name='dbl'> </param>
		/// <param name='cchFracDigits'> number of digits after decimal </param>
		/// <returns></returns>
		[return: MarshalAs(UnmanagedType.BStr)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		string get_DblToExpString(double dbl, int cchFracDigits);

		/// <summary>
		/// Get a double from a string (anything DblToString or DblToExpString could output)
		/// Can handle leading and trailing white space.
		/// ENHANCE JohnT: should it also handle output of IntToPrettyString?
		///</summary>
		/// <param name='bstr'> </param>
		/// <returns></returns>
		/// <exception cref="COMException">if any characters are not used up in the string (except white
		/// space). (E_FAIL)</exception>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		double get_StringToDbl([MarshalAs(UnmanagedType.BStr)] string bstr);

		/// <summary>
		/// Get a double from a string (anything DblToString or DblToExpString could output)
		/// Can handle leading white space; trailing is handled using pichUnused.
		///</summary>
		/// <param name='_rgch'> </param>
		/// <param name='cch'> </param>
		/// <param name='_dbl'> </param>
		/// <param name='_ichUnused'>Set to the index of the first character not processed, that is,
		/// not recognized as part of a number. </param>
		[TypeLibFunc(TypeLibFuncFlags.FRestricted)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void StringToDblRgch([MarshalAs(UnmanagedType.LPWStr)] string _rgch, int cch, out double _dbl, out int _ichUnused);
	}

	/// <summary>
	/// Interface ILgWritingSystemFactory
	/// Knows how to find an writing system engine from an writing system integer or an ICU
	/// Locale string.
	///
	/// <h3>When to implement</h3>
	/// Never implement this interface.
	///
	/// <h3>When to use</h3>
	/// Use this interface when you need to obtain writing systems and their engines.
	///
	/// <h3>How to obtain an instance</h3>
	///
	/// Hungarian: <c>wsf</c>
	///</summary>
	[ComImport()]
	[InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]
	[Guid("22376578-BFEB-4c46-8D72-C9154890DD16")]
	public interface ILgWritingSystemFactory
	{

		/// <summary>
		/// Get the actual writing system object for a given ICU Locale string.
		/// The current implementation returns any existing writing system for that ICU Locale,
		/// or creates one with default settings if one is not already known.
		/// (Use <c>get_EngineOrNull</c> to avoid automatic creation of a new engine.)
		///</summary>
		/// <param name='bstrIcuLocale'> </param>
		/// <returns></returns>
		[return: MarshalAs(UnmanagedType.Interface)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		ILgWritingSystem get_Engine([MarshalAs(UnmanagedType.BStr)] string bstrIcuLocale);

		/// <summary>
		/// Get the actual writing system object for a given code, or returns NULL if one does
		/// not already exist.
		/// (Use <c>get_Engine</c> if you prefer to have an writing system created automatically if
		/// one does not already exist.)
		///</summary>
		/// <param name='ws'> </param>
		/// <returns></returns>
		[return: MarshalAs(UnmanagedType.Interface)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		ILgWritingSystem get_EngineOrNull(int ws);

		/// <summary>
		/// Get an writing system ID from an ICULocale, or 0 if no such writing system exists.
		/// Return S_FALSE if the writing system does not exist.
		///</summary>
		/// <param name='bstr'> </param>
		/// <returns></returns>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		int GetWsFromStr([MarshalAs(UnmanagedType.BStr)] string bstr);

		/// <summary>
		/// Get the ICULocale for the writing system if it exists, or NULL if it doesn't.
		/// Return S_FALSE if the writing system does not exist.
		///</summary>
		/// <param name='wsId'> </param>
		/// <returns></returns>
		[return: MarshalAs(UnmanagedType.BStr)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		string GetStrFromWs(int wsId);

		/// <summary> Get the number of writing systems currently installed in the system </summary>
		/// <returns>A System.Int32 </returns>
		int NumberOfWs
		{
			[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
			get;
		}

		/// <summary> Get the list of writing systems currrently installed in the system. </summary>
		/// <param name='rgws'> </param>
		/// <param name='cws'> </param>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void GetWritingSystems([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef=typeof(ArrayPtrMarshaler))] ArrayPtr/*int[]*/ rgws, int cws);

		/// <summary> Get the char prop engine for a particular WS </summary>
		/// <param name='ws'> </param>
		/// <returns></returns>
		[return: MarshalAs(UnmanagedType.Interface)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		ILgCharacterPropertyEngine get_CharPropEngine(int ws);

		/// <summary> Get the renderer for a particular WS </summary>
		/// <param name='ws'> </param>
		/// <param name='_vg'> </param>
		/// <returns></returns>
		[return: MarshalAs(UnmanagedType.Interface)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		IRenderEngine get_Renderer(int ws, [MarshalAs(UnmanagedType.Interface)] IVwGraphics _vg);

		/// <summary> Get the renderer for a particular Chrp </summary>
		/// <param name='_chrp'> </param>
		/// <returns></returns>
		[return: MarshalAs(UnmanagedType.Interface)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		IRenderEngine get_RendererFromChrp(ref LgCharRenderProps _chrp);

		/// <summary>
		/// Get the default user interface writing system.
		/// Set the default user interface writing system. This should usually be done very early in
		/// the lifecycle of the WSF.
		///</summary>
		/// <returns>A System.Int32 </returns>
		int UserWs
		{
			[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
			get;
			[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
			set;
		}
	}

	/// <summary>
	/// Interface ILgKeymanHandler
	///
	/// An interface that manages Keyman, being able to invoke a keyboard, find out which
	/// one is active, find out which keyboards are available, return the windows message that
	/// Keyman sends when a keyboard is selected, and so forth.
	///
	/// <h3>When to implement</h3>
	/// The standard implementation should suffice.
	///
	/// <h3>When to use</h3>
	/// Whenever you want to manipulate or query Keyman
	///
	/// Hungarian: <c>lkh</c>
	///</summary>
	[ComImport()]
	[InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]
	[Guid("10958C2A-428B-4AB8-803F-E79B6FB453B3")]
	public interface ILgKeymanHandler
	{

		/// <summary>
		/// Initialize the Keyboard handler. Set fForce to reinitialize even if already
		/// initialized, for example, if a keyboard has been added or removed.
		/// All data is static, so it is only necessary to call this for one instance.
		/// Actually, it is not strictly necessary to call it at all, as other methods will
		/// do so if necessary.
		///</summary>
		/// <param name='fForce'> </param>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void Init([MarshalAs(UnmanagedType.VariantBool)] bool fForce);

		/// <summary> Obtain the number of keyboard layouts currently avaiable. </summary>
		/// <returns>A System.Int32 </returns>
		int NLayout
		{
			[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
			get;
		}

		/// <summary> Obtain the ith layout name. </summary>
		/// <param name='ilayout'> </param>
		/// <returns></returns>
		[return: MarshalAs(UnmanagedType.BStr)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		string get_Name(int ilayout);

		/// <summary> Get/Set the active keyboard. </summary>
		/// <returns>A System.String </returns>
		string ActiveKeyboardName
		{
			[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
			[return: MarshalAs(UnmanagedType.BStr)]
			get;
			[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
			[param: MarshalAs(UnmanagedType.BStr)]
			set;
		}

		/// <summary>
		/// Return the windows message (obtained from RegisterWindowsMessage("WM_KMSELECTLANG").
		///</summary>
		/// <returns>A System.Int32 </returns>
		int KeymanWindowsMessage
		{
			[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
			get;
		}
	}

	/// <summary>
	/// Interface ILgTextServices
	///
	/// Provide access to TSF functionality wrapped in easytocall methods.
	///
	/// <h3>When to implement</h3>
	/// Clients should not implement this interface. There is a standard implementation in
	/// Language.dll.
	///
	/// <h3>When to use</h3>
	/// When TSF related functionality is needed, especially from C
	///</summary>
	[ComImport()]
	[InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]
	[Guid("5B6303DE-E635-4DD7-A7FC-345BEEF352D8")]
	public interface ILgTextServices
	{

		/// <summary> Set the system keyboard and TSF language. </summary>
		/// <param name='nLcid'> </param>
		/// <param name='bstrKeymanKbd'> </param>
		/// <param name='_nActiveLangId'> </param>
		/// <param name='_bstrActiveKeymanKbd'> </param>
		/// <param name='_fSelectLangPending'> </param>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void SetKeyboard(int nLcid, [MarshalAs(UnmanagedType.BStr)] string bstrKeymanKbd, ref int _nActiveLangId, [MarshalAs(UnmanagedType.BStr)] ref string _bstrActiveKeymanKbd, [MarshalAs(UnmanagedType.VariantBool)] ref bool _fSelectLangPending);
	}

	/// <summary>
	/// Interface ILgCodePageEnumerator
	///
	/// An interface that allows retrieving a list of the code pages installed on the system,
	/// with names suitable for displaying in a combo box.
	///
	/// <h3>When to implement</h3>
	/// The standard implementation should suffice.
	///
	/// <h3>When to use</h3>
	/// Whenever you want to retrieve a list of available code pages.
	///
	/// Hungarian: <c>lcpe</c>
	///</summary>
	[ComImport()]
	[InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]
	[Guid("2CFCF4B7-2FFE-4CF8-91BE-FBB57CC7782A")]
	public interface ILgCodePageEnumerator
	{

		/// <summary>
		/// Initialize enumerator. This default initializer gives all known code pages.
		/// We may eventually have others that allow them to be limited.
		///</summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void Init();

		/// <summary>
		/// Get the next code page. When there are no more, sets pnId to 0 and pbstrName to null.
		///</summary>
		/// <param name='_nId'> </param>
		/// <param name='_bstrName'> </param>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void Next(out int _nId, [MarshalAs(UnmanagedType.BStr)] out string _bstrName);
	}

	/// <summary>
	/// Interface ILgLanguageEnumerator
	///
	/// An interface that allows retrieving a list of the languages installed on the system,
	/// with names suitable for displaying in a combo box.
	///
	/// <h3>When to implement</h3>
	/// The standard implementation should suffice.
	///
	/// <h3>When to use</h3>
	/// Whenever you want to retrieve a list of available languages.
	///
	/// Hungarian: <c>lcpe</c>
	///</summary>
	[ComImport()]
	[InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]
	[Guid("746A16E1-0C36-4268-A261-E8012B0D67C5")]
	public interface ILgLanguageEnumerator
	{

		/// <summary>
		/// Initialize enumerator. This default initializer gives all installed languages.
		/// We may eventually have others that allow them to be limited.
		///</summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void Init();

		/// <summary>
		/// Get the next language. When there are no more, sets pnId to 0 and pbstrName to null.
		/// For a language unsupported by the OS, it returns the id along with E_FAIL.
		///</summary>
		/// <param name='_nId'> </param>
		/// <param name='_bstrName'> </param>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void Next(out int _nId, [MarshalAs(UnmanagedType.BStr)] out string _bstrName);
	}

	/// <summary>
	/// Interface ILgIcuConverterEnumerator
	///
	/// An interface that allows retrieving a list of the converters that ICU supports.
	/// Eventually it may also support creating converters, though our preferred approach is
	/// to use the EncConverters interface.
	///
	/// <h3>When to implement</h3>
	/// The standard implementation should suffice.
	///
	/// <h3>When to use</h3>
	/// To retrieve a list of available converters.
	///
	/// Hungarian: <c>lcpe</c>
	///</summary>
	[ComImport()]
	[InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]
	[Guid("8E6D558E-8755-4EA1-9FF6-039D375312E9")]
	public interface ILgIcuConverterEnumerator
	{

		/// <summary> Get the count of available converters. </summary>
		/// <returns>A System.Int32 </returns>
		int Count
		{
			[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
			get;
		}

		/// <summary> Get the nth converter name. </summary>
		/// <param name='iconv'> </param>
		/// <returns></returns>
		[return: MarshalAs(UnmanagedType.BStr)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		string get_ConverterName(int iconv);

		/// <summary> Get the ID string that identifies the converter to ICU. </summary>
		/// <param name='iconv'> </param>
		/// <returns></returns>
		[return: MarshalAs(UnmanagedType.BStr)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		string get_ConverterId(int iconv);
	}

	/// <summary>
	/// Interface ILgIcuTransliteratorEnumerator
	///
	/// An interface that allows retrieving a list of the transliterators that ICU supports.
	/// Eventually it may also support creating transliterators, though our preferred approach is
	/// to use the EncConverters interface.
	///
	/// <h3>When to implement</h3>
	/// The standard implementation should suffice.
	///
	/// <h3>When to use</h3>
	/// To retrieve a list of available converters.
	///
	/// Hungarian: <c>lcpe</c>
	///</summary>
	[ComImport()]
	[InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]
	[Guid("50F2492C-6C46-48BA-8B7F-5F04153AB2CC")]
	public interface ILgIcuTransliteratorEnumerator
	{

		/// <summary> Get the count of available converters. </summary>
		/// <returns>A System.Int32 </returns>
		int Count
		{
			[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
			get;
		}

		/// <summary> Get the nth converter name. </summary>
		/// <param name='itrans'> </param>
		/// <returns></returns>
		[return: MarshalAs(UnmanagedType.BStr)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		string get_TransliteratorName(int itrans);

		/// <summary> Get the ID string that identifies the transliterator to ICU. </summary>
		/// <param name='iconv'> </param>
		/// <returns></returns>
		[return: MarshalAs(UnmanagedType.BStr)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		string get_TransliteratorId(int iconv);
	}

	/// <summary>
	/// Interface ILgLocaleEnumerator
	///
	/// An interface that allows retrieving a list of the available ICU locales on the system.
	///
	/// <h3>When to implement</h3>
	/// The standard implementation should suffice.
	///
	/// <h3>When to use</h3>
	/// To retrieve a list of available locales.
	///
	/// Hungarian: <c>lcpe</c>
	///</summary>
	[ComImport()]
	[InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]
	[Guid("08F649D0-D8AB-447B-AAB6-21F85CFA743C")]
	public interface ILgIcuLocaleEnumerator
	{

		/// <summary> Get the count of available converters. </summary>
		/// <returns>A System.Int32 </returns>
		int Count
		{
			[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
			get;
		}

		/// <summary> Get the nth locale name. (ICU getName.) </summary>
		/// <param name='iloc'> </param>
		/// <returns></returns>
		[return: MarshalAs(UnmanagedType.BStr)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		string get_Name(int iloc);

		/// <summary> Get the nth locale language identifier. (ICU getLanguage.) </summary>
		/// <param name='iloc'> </param>
		/// <returns></returns>
		[return: MarshalAs(UnmanagedType.BStr)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		string get_Language(int iloc);

		/// <summary> Get the nth locale country. (ICU getCountry.) </summary>
		/// <param name='iloc'> </param>
		/// <returns></returns>
		[return: MarshalAs(UnmanagedType.BStr)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		string get_Country(int iloc);

		/// <summary> Get the nth locale variant. (ICU getVariant.) </summary>
		/// <param name='iloc'> </param>
		/// <returns></returns>
		[return: MarshalAs(UnmanagedType.BStr)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		string get_Variant(int iloc);

		/// <summary>
		/// Get the display name of the locale represented by this enumerator.
		/// The display name will be in the selected locale if it is nonempty;
		/// pass null or an empty string to get the system default locale.
		///</summary>
		/// <param name='iloc'> </param>
		/// <param name='bstrLocaleName'> </param>
		/// <returns></returns>
		[return: MarshalAs(UnmanagedType.BStr)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		string get_DisplayName(int iloc, [MarshalAs(UnmanagedType.BStr)] string bstrLocaleName);
	}

	/// <summary>
	/// Interface ILgIcuResourceBundle
	///
	/// An interface that represents an instance of an ICU ResourceBundle object.
	///
	/// <h3>When to implement</h3>
	/// The standard implementation should suffice.
	///
	/// <h3>When to use</h3>
	/// To retrieve information from ICU resources; this is useful for things like enumerating
	/// the countries and locales known to the system.
	///
	/// Hungarian: <c>lcpe</c>
	///</summary>
	[ComImport()]
	[InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]
	[Guid("C243C72A-0D15-44D9-ABCB-A6E875A7659A")]
	public interface ILgIcuResourceBundle
	{

		/// <summary>
		/// Initialize the root resource bundle. The path may be null to use the standard
		/// FieldWorks ICU data directory.
		///</summary>
		/// <param name='bstrPath'> </param>
		/// <param name='locale'> </param>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void Init([MarshalAs(UnmanagedType.BStr)] string bstrPath, [MarshalAs(UnmanagedType.BStr)] string locale);

		/// <summary> Get the key of the bundle. (Icu getKey.) </summary>
		/// <returns>A System.String </returns>
		string Key
		{
			[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
			[return: MarshalAs(UnmanagedType.BStr)]
			get;
		}

		/// <summary> Get the 'string' of the bundle. (Icu getString.) </summary>
		/// <returns>A System.String </returns>
		string String
		{
			[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
			[return: MarshalAs(UnmanagedType.BStr)]
			get;
		}

		/// <summary>
		/// Get the name of the bundle. (Icu getName.) Note that the Key and String of the
		/// bundle are often more useful.
		///</summary>
		/// <returns>A System.String </returns>
		string Name
		{
			[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
			[return: MarshalAs(UnmanagedType.BStr)]
			get;
		}

		/// <summary>
		/// Get another resource bundle for a subsection of this one. (Icu get.)
		/// If the resource does not exist, this sets pprb to NULL.
		///</summary>
		/// <param name='bstrSectionName'> </param>
		/// <returns></returns>
		[return: MarshalAs(UnmanagedType.Interface)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		ILgIcuResourceBundle get_GetSubsection([MarshalAs(UnmanagedType.BStr)] string bstrSectionName);

		/// <summary>
		/// Determine whether the bundle has more subresources accessible through get_Next.
		/// (Icu hasNext.)
		///</summary>
		/// <returns>A System.Boolean </returns>
		bool HasNext
		{
			[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
			[return: MarshalAs(UnmanagedType.VariantBool)]
			get;
		}

		/// <summary>
		/// Get the 'next' subsection and advance. The first call to this retrieves the first
		/// item. Call only while HasNext returns true. (Icu getNext.)
		///</summary>
		/// <returns>A ILgIcuResourceBundle </returns>
		ILgIcuResourceBundle Next
		{
			[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
			[return: MarshalAs(UnmanagedType.Interface)]
			get;
		}

		/// <summary> Get the size of the bundle. (Icu getSize.) </summary>
		/// <returns>A System.Int32 </returns>
		int Size
		{
			[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
			get;
		}

		/// <summary> Get the ith string. (Icu getStringEx.) </summary>
		/// <param name='irb'> </param>
		/// <returns></returns>
		[return: MarshalAs(UnmanagedType.BStr)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		string get_StringEx(int irb);
	}

	/// <summary> Interface IRegexMatcher
	///
	/// An interface that allows C </summary>
	[ComImport()]
	[InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]
	[Guid("6C62CCF0-4EE1-493C-8092-319B6CFBEEBC")]
	public interface IRegexMatcher
	{

		/// <summary>
		/// Initialize the pattern to be searched. This must be done before calling other
		/// methods.
		///</summary>
		/// <param name='bstrPattern'> </param>
		/// <param name='fMatchCase'> </param>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void Init([MarshalAs(UnmanagedType.BStr)] string bstrPattern, [MarshalAs(UnmanagedType.VariantBool)] bool fMatchCase);

		/// <summary>
		/// This oddly named method is named for the one in the real RegexMatcher. It sets the
		/// input that will be searched.
		///</summary>
		/// <param name='bstrInput'> </param>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void Reset([MarshalAs(UnmanagedType.BStr)] string bstrInput);

		/// <summary>
		/// This finds the first occurrence of the pattern in the input (starting at ich),
		/// if any, and returns a boolean indicating whether it was found. The match may start
		/// exactly at ich.
		///</summary>
		/// <param name='ich'> </param>
		/// <returns></returns>
		[return: MarshalAs(UnmanagedType.VariantBool)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		bool Find(int ich);

		/// <summary>
		/// Obtain the start of the indexed group. 0 obtains the start of the entire match;
		/// 1 obtains the part matched by the first () group, and so forth. Using an outofrange
		/// index returns 1. (It does not produce a bad HRESULT.)
		///</summary>
		/// <param name='igroup'> </param>
		/// <returns></returns>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		int get_Start(int igroup);

		/// <summary>
		/// Returns the end of the indicated group. Following the ICU terminology here...
		/// in our jargon it would be the limit of the group, that is, the index of the character
		/// AFTER the last one matched.
		///</summary>
		/// <param name='igroup'> </param>
		/// <returns></returns>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		int get_End(int igroup);

		/// <summary> Get any error message from a prior operation. </summary>
		/// <returns>A System.String </returns>
		string ErrorMessage
		{
			[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
			[return: MarshalAs(UnmanagedType.BStr)]
			get;
		}
	}

	#region RegexMatcherWrapper CoClass definitions
	/// <summary>RegexMatcherWrapper </summary>
	[ComImport()]
	[CoClass(typeof(_RegexMatcherWrapperClass))]
	[Guid("6C62CCF0-4EE1-493C-8092-319B6CFBEEBC")]
	public interface RegexMatcherWrapper : IRegexMatcher
	{
	}

	#region Private _RegexMatcherWrapperClass class
	/// <summary>_RegexMatcherWrapperClass </summary>
	[ComImport()]
	[ClassInterface(ClassInterfaceType.None)]
	[TypeLibType(TypeLibTypeFlags.FCanCreate)]
	[Guid("13D5C6D3-39D9-4BDA-A3F8-A5CAF6A6940A")]
	internal class _RegexMatcherWrapperClass : IRegexMatcher, RegexMatcherWrapper
	{

		/// <summary>
		/// Initialize the pattern to be searched. This must be done before calling other
		/// methods.
		///</summary>
		/// <param name='bstrPattern'> </param>
		/// <param name='fMatchCase'> </param>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		public virtual extern void Init([MarshalAs(UnmanagedType.BStr)] string bstrPattern, [MarshalAs(UnmanagedType.VariantBool)] bool fMatchCase);

		/// <summary>
		/// This oddly named method is named for the one in the real RegexMatcher. It sets the
		/// input that will be searched.
		///</summary>
		/// <param name='bstrInput'> </param>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		public virtual extern void Reset([MarshalAs(UnmanagedType.BStr)] string bstrInput);

		/// <summary>
		/// This finds the first occurrence of the pattern in the input (starting at ich),
		/// if any, and returns a boolean indicating whether it was found. The match may start
		/// exactly at ich.
		///</summary>
		/// <param name='ich'> </param>
		/// <returns></returns>
		[return: MarshalAs(UnmanagedType.VariantBool)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		public virtual extern bool Find(int ich);

		/// <summary>
		/// Obtain the start of the indexed group. 0 obtains the start of the entire match;
		/// 1 obtains the part matched by the first () group, and so forth. Using an outofrange
		/// index returns 1. (It does not produce a bad HRESULT.)
		///</summary>
		/// <param name='igroup'> </param>
		/// <returns></returns>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		public virtual extern int get_Start(int igroup);

		/// <summary>
		/// Returns the end of the indicated group. Following the ICU terminology here...
		/// in our jargon it would be the limit of the group, that is, the index of the character
		/// AFTER the last one matched.
		///</summary>
		/// <param name='igroup'> </param>
		/// <returns></returns>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		public virtual extern int get_End(int igroup);

		/// <summary> Get any error message from a prior operation. </summary>
		/// <returns>A System.String </returns>
		public virtual extern string ErrorMessage
		{
			[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
			[return: MarshalAs(UnmanagedType.BStr)]
			get;
		}
	}
	#endregion

	/// <summary>RegexMatcherWrapperClass </summary>
	public static class RegexMatcherWrapperClass
	{

		/// <summary>Member Create </summary>
		/// <returns>A RegexMatcherWrapper</returns>
		public static RegexMatcherWrapper Create()
		{
			return new _RegexMatcherWrapperClass();
		}
	}
	#endregion

	#region LgSystemCollater CoClass definitions
	/// <summary>LgSystemCollater </summary>
	[ComImport()]
	[CoClass(typeof(_LgSystemCollaterClass))]
	[Guid("D27A3D8C-D3FE-4E25-9097-8F4A1FB30361")]
	public interface LgSystemCollater : ILgCollatingEngine
	{
	}

	#region Private _LgSystemCollaterClass class
	/// <summary>_LgSystemCollaterClass </summary>
	[ComImport()]
	[ClassInterface(ClassInterfaceType.None)]
	[TypeLibType(TypeLibTypeFlags.FCanCreate)]
	[Guid("E361F805-C902-4306-A5D8-F7802B0E7365")]
	internal class _LgSystemCollaterClass : ILgCollatingEngine, LgSystemCollater
	{

		/// <summary>
		/// Get a sort key which may be compared to any other sort key produced by this
		/// object via a simple BSTR comparison. This is especially useful in largescale
		/// sorting, where the work to generate the key only needs to be done once per key
		///</summary>
		/// <param name='bstrValue'> </param>
		/// <param name='colopt'> </param>
		/// <returns></returns>
		[return: MarshalAs(UnmanagedType.BStr)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		public virtual extern string get_SortKey([MarshalAs(UnmanagedType.BStr)] string bstrValue, LgCollatingOptions colopt);

		/// <summary>
		/// Get a sort key which may be compared to any other sort key produced by this
		/// object via a simple wcscmp comparison. This is especially useful in largescale
		/// sorting, where the work to generate the key only needs to be done once per key
		///</summary>
		/// <param name='_ch'> </param>
		/// <param name='cchIn'> </param>
		/// <param name='colopt'> </param>
		/// <param name='cchMaxOut'>Available space in output buffer. If 0, the method just sets
		/// pchKey to the number required. </param>
		/// <param name='_chKey'> </param>
		/// <param name='_cchOut'> </param>
		/// <exception cref="COMException">if not enough space in output buffer (gives
		/// needed amount in pcchOut). (ERROR_INSUFFICIENT_BUFFER)</exception>
		[TypeLibFunc(TypeLibFuncFlags.FRestricted)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		public virtual extern void SortKeyRgch([MarshalAs(UnmanagedType.LPWStr)] string _ch, int cchIn, LgCollatingOptions colopt, int cchMaxOut, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef=typeof(ArrayPtrMarshaler))] ArrayPtr/*OLECHAR[]*/ _chKey, out int _cchOut);

		/// <summary>
		/// Return in pnVal (&lt;0, 0, or &gt;0) depending on whether the first string is
		/// (less than, equal, or greater than) the second string passed. This in principle
		/// creates a SortKey for each string using the SortKey method, then compares them.
		/// Any actual implementation promises to give the same results as doing that.
		/// However, the actual implementation may be more efficient than that, saving time
		/// when only a single comparison is to be made involving each string.
		///</summary>
		/// <param name='bstrValue1'> </param>
		/// <param name='bstrValue2'> </param>
		/// <param name='colopt'> </param>
		/// <returns></returns>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		public virtual extern int Compare([MarshalAs(UnmanagedType.BStr)] string bstrValue1, [MarshalAs(UnmanagedType.BStr)] string bstrValue2, LgCollatingOptions colopt);

		/// <summary>
		/// Get the language writing system factory used with this collating engine object.
		/// Set the language writing system factory to use with this collating engine object.
		///</summary>
		/// <returns>A ILgWritingSystemFactory </returns>
		public virtual extern ILgWritingSystemFactory WritingSystemFactory
		{
			[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
			[return: MarshalAs(UnmanagedType.Interface)]
			get;
			[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
			[param: MarshalAs(UnmanagedType.Interface)]
			set;
		}

		/// <summary> The next two methods are required by C </summary>
		/// <param name='bstrValue'> </param>
		/// <param name='colopt'> </param>
		/// <returns> will be a "safearray".</returns>
		[return: MarshalAs(UnmanagedType.Struct)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		public virtual extern object get_SortKeyVariant([MarshalAs(UnmanagedType.BStr)] string bstrValue, LgCollatingOptions colopt);

		/// <summary>
		/// Return in pnVal (&lt;0, 0, or &gt;0) depending on whether the first string is
		/// (less than, equal, or greater than) the second string passed. This in principle
		/// creates a SortKey for each string using the SortKey method, then compares them.
		/// Any actual implementation promises to give the same results as doing that.
		/// However, the actual implementation may be more efficient than that, saving time
		/// when only a single comparison is to be made involving each string.
		///</summary>
		/// <param name='saValue1'> "safearray" </param>
		/// <param name='saValue2'> "safearray" </param>
		/// <param name='colopt'> </param>
		/// <returns></returns>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		public virtual extern int CompareVariant([MarshalAs(UnmanagedType.Struct)] object saValue1, [MarshalAs(UnmanagedType.Struct)] object saValue2, LgCollatingOptions colopt);

		/// <summary> Initialize the collating engine to the given locale. </summary>
		/// <param name='bstrLocale'> </param>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		public virtual extern void Open([MarshalAs(UnmanagedType.BStr)] string bstrLocale);

		/// <summary> Close and free the currently open collating engine, if any. </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		public virtual extern void Close();
	}
	#endregion

	/// <summary>LgSystemCollaterClass </summary>
	public static class LgSystemCollaterClass
	{

		/// <summary>Member Create </summary>
		/// <returns>A LgSystemCollater</returns>
		public static LgSystemCollater Create()
		{
			return new _LgSystemCollaterClass();
		}
	}
	#endregion

	#region LgUnicodeCollater CoClass definitions
	/// <summary>LgUnicodeCollater </summary>
	[ComImport()]
	[CoClass(typeof(_LgUnicodeCollaterClass))]
	[Guid("D27A3D8C-D3FE-4E25-9097-8F4A1FB30361")]
	public interface LgUnicodeCollater : ILgCollatingEngine
	{
	}

	#region Private _LgUnicodeCollaterClass class
	/// <summary>_LgUnicodeCollaterClass </summary>
	[ComImport()]
	[ClassInterface(ClassInterfaceType.None)]
	[TypeLibType(TypeLibTypeFlags.FCanCreate)]
	[Guid("0D9900D2-1693-481F-AA70-7EA64F264EC4")]
	internal class _LgUnicodeCollaterClass : ILgCollatingEngine, LgUnicodeCollater
	{

		/// <summary>
		/// Get a sort key which may be compared to any other sort key produced by this
		/// object via a simple BSTR comparison. This is especially useful in largescale
		/// sorting, where the work to generate the key only needs to be done once per key
		///</summary>
		/// <param name='bstrValue'> </param>
		/// <param name='colopt'> </param>
		/// <returns></returns>
		[return: MarshalAs(UnmanagedType.BStr)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		public virtual extern string get_SortKey([MarshalAs(UnmanagedType.BStr)] string bstrValue, LgCollatingOptions colopt);

		/// <summary>
		/// Get a sort key which may be compared to any other sort key produced by this
		/// object via a simple wcscmp comparison. This is especially useful in largescale
		/// sorting, where the work to generate the key only needs to be done once per key
		///</summary>
		/// <param name='_ch'> </param>
		/// <param name='cchIn'> </param>
		/// <param name='colopt'> </param>
		/// <param name='cchMaxOut'>Available space in output buffer. If 0, the method just sets
		/// pchKey to the number required. </param>
		/// <param name='_chKey'> </param>
		/// <param name='_cchOut'> </param>
		/// <exception cref="COMException">if not enough space in output buffer (gives
		/// needed amount in pcchOut). (ERROR_INSUFFICIENT_BUFFER)</exception>
		[TypeLibFunc(TypeLibFuncFlags.FRestricted)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		public virtual extern void SortKeyRgch([MarshalAs(UnmanagedType.LPWStr)] string _ch, int cchIn, LgCollatingOptions colopt, int cchMaxOut, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef=typeof(ArrayPtrMarshaler))] ArrayPtr/*OLECHAR[]*/ _chKey, out int _cchOut);

		/// <summary>
		/// Return in pnVal (&lt;0, 0, or &gt;0) depending on whether the first string is
		/// (less than, equal, or greater than) the second string passed. This in principle
		/// creates a SortKey for each string using the SortKey method, then compares them.
		/// Any actual implementation promises to give the same results as doing that.
		/// However, the actual implementation may be more efficient than that, saving time
		/// when only a single comparison is to be made involving each string.
		///</summary>
		/// <param name='bstrValue1'> </param>
		/// <param name='bstrValue2'> </param>
		/// <param name='colopt'> </param>
		/// <returns></returns>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		public virtual extern int Compare([MarshalAs(UnmanagedType.BStr)] string bstrValue1, [MarshalAs(UnmanagedType.BStr)] string bstrValue2, LgCollatingOptions colopt);

		/// <summary>
		/// Get the language writing system factory used with this collating engine object.
		/// Set the language writing system factory to use with this collating engine object.
		///</summary>
		/// <returns>A ILgWritingSystemFactory </returns>
		public virtual extern ILgWritingSystemFactory WritingSystemFactory
		{
			[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
			[return: MarshalAs(UnmanagedType.Interface)]
			get;
			[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
			[param: MarshalAs(UnmanagedType.Interface)]
			set;
		}

		/// <summary> The next two methods are required by C </summary>
		/// <param name='bstrValue'> </param>
		/// <param name='colopt'> </param>
		/// <returns> will be a "safearray".</returns>
		[return: MarshalAs(UnmanagedType.Struct)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		public virtual extern object get_SortKeyVariant([MarshalAs(UnmanagedType.BStr)] string bstrValue, LgCollatingOptions colopt);

		/// <summary>
		/// Return in pnVal (&lt;0, 0, or &gt;0) depending on whether the first string is
		/// (less than, equal, or greater than) the second string passed. This in principle
		/// creates a SortKey for each string using the SortKey method, then compares them.
		/// Any actual implementation promises to give the same results as doing that.
		/// However, the actual implementation may be more efficient than that, saving time
		/// when only a single comparison is to be made involving each string.
		///</summary>
		/// <param name='saValue1'> "safearray" </param>
		/// <param name='saValue2'> "safearray" </param>
		/// <param name='colopt'> </param>
		/// <returns></returns>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		public virtual extern int CompareVariant([MarshalAs(UnmanagedType.Struct)] object saValue1, [MarshalAs(UnmanagedType.Struct)] object saValue2, LgCollatingOptions colopt);

		/// <summary> Initialize the collating engine to the given locale. </summary>
		/// <param name='bstrLocale'> </param>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		public virtual extern void Open([MarshalAs(UnmanagedType.BStr)] string bstrLocale);

		/// <summary> Close and free the currently open collating engine, if any. </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		public virtual extern void Close();
	}
	#endregion

	/// <summary>LgUnicodeCollaterClass </summary>
	public static class LgUnicodeCollaterClass
	{

		/// <summary>Member Create </summary>
		/// <returns>A LgUnicodeCollater</returns>
		public static LgUnicodeCollater Create()
		{
			return new _LgUnicodeCollaterClass();
		}
	}
	#endregion

	#region LgIcuCharPropEngine CoClass definitions
	/// <summary>
	/// Interface ILgIcuCharPropEngine
	/// This interface provides initialization functions for an ICU character property engine.
	///
	/// <h3>When to implement</h3>
	/// Clients should not normally implement this interface. There are standard implementations
	/// in Language.dll.
	///
	/// <h3>When to use</h3>
	/// Use this interface when you need to initialize an ICU character property engine.
	///
	/// <h3>How to obtain an instance</h3>
	/// For now the only way is to create one using CoCreateInstance, with
	/// CLSID_LgIcuCharPropEngine.
	///
	/// Hungarian: <c>ipropeng</c>
	///</summary>
	[ComImport()]
	[CoClass(typeof(_LgIcuCharPropEngineClass))]
	[Guid("E8689492-7622-427b-8518-6339294FD227")]
	public interface LgIcuCharPropEngine : ILgIcuCharPropEngine
	{
	}

	#region Private _LgIcuCharPropEngineClass class
	/// <summary>_LgIcuCharPropEngineClass </summary>
	[ComImport()]
	[ClassInterface(ClassInterfaceType.None)]
	[TypeLibType(TypeLibTypeFlags.FCanCreate)]
	[Guid("30D75676-A10F-48FE-9627-EBF4061EA49D")]
	internal class _LgIcuCharPropEngineClass : ILgIcuCharPropEngine, LgIcuCharPropEngine
	{

		/// <summary>Member get_GeneralCategory </summary>
		/// <param name='ch'> </param>
		/// <returns>A LgGeneralCharCategory</returns>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		public virtual extern LgGeneralCharCategory get_GeneralCategory(int ch);

		/// <summary>Member get_BidiCategory </summary>
		/// <param name='ch'> </param>
		/// <returns>A LgBidiCategory</returns>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		public virtual extern LgBidiCategory get_BidiCategory(int ch);

		/// <summary>Member get_IsLetter </summary>
		/// <param name='ch'> </param>
		/// <returns>A System.Boolean</returns>
		[return: MarshalAs(UnmanagedType.VariantBool)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		public virtual extern bool get_IsLetter(int ch);

		/// <summary>Member get_IsWordForming </summary>
		/// <param name='ch'> </param>
		/// <returns>A System.Boolean</returns>
		[return: MarshalAs(UnmanagedType.VariantBool)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		public virtual extern bool get_IsWordForming(int ch);

		/// <summary>Member get_IsPunctuation </summary>
		/// <param name='ch'> </param>
		/// <returns>A System.Boolean</returns>
		[return: MarshalAs(UnmanagedType.VariantBool)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		public virtual extern bool get_IsPunctuation(int ch);

		/// <summary>Member get_IsNumber </summary>
		/// <param name='ch'> </param>
		/// <returns>A System.Boolean</returns>
		[return: MarshalAs(UnmanagedType.VariantBool)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		public virtual extern bool get_IsNumber(int ch);

		/// <summary>Member get_IsSeparator </summary>
		/// <param name='ch'> </param>
		/// <returns>A System.Boolean</returns>
		[return: MarshalAs(UnmanagedType.VariantBool)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		public virtual extern bool get_IsSeparator(int ch);

		/// <summary>Member get_IsSymbol </summary>
		/// <param name='ch'> </param>
		/// <returns>A System.Boolean</returns>
		[return: MarshalAs(UnmanagedType.VariantBool)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		public virtual extern bool get_IsSymbol(int ch);

		/// <summary>Member get_IsMark </summary>
		/// <param name='ch'> </param>
		/// <returns>A System.Boolean</returns>
		[return: MarshalAs(UnmanagedType.VariantBool)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		public virtual extern bool get_IsMark(int ch);

		/// <summary>Member get_IsOther </summary>
		/// <param name='ch'> </param>
		/// <returns>A System.Boolean</returns>
		[return: MarshalAs(UnmanagedType.VariantBool)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		public virtual extern bool get_IsOther(int ch);

		/// <summary>Member get_IsUpper </summary>
		/// <param name='ch'> </param>
		/// <returns>A System.Boolean</returns>
		[return: MarshalAs(UnmanagedType.VariantBool)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		public virtual extern bool get_IsUpper(int ch);

		/// <summary>Member get_IsLower </summary>
		/// <param name='ch'> </param>
		/// <returns>A System.Boolean</returns>
		[return: MarshalAs(UnmanagedType.VariantBool)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		public virtual extern bool get_IsLower(int ch);

		/// <summary>Member get_IsTitle </summary>
		/// <param name='ch'> </param>
		/// <returns>A System.Boolean</returns>
		[return: MarshalAs(UnmanagedType.VariantBool)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		public virtual extern bool get_IsTitle(int ch);

		/// <summary>Member get_IsModifier </summary>
		/// <param name='ch'> </param>
		/// <returns>A System.Boolean</returns>
		[return: MarshalAs(UnmanagedType.VariantBool)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		public virtual extern bool get_IsModifier(int ch);

		/// <summary>Member get_IsOtherLetter </summary>
		/// <param name='ch'> </param>
		/// <returns>A System.Boolean</returns>
		[return: MarshalAs(UnmanagedType.VariantBool)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		public virtual extern bool get_IsOtherLetter(int ch);

		/// <summary>Member get_IsOpen </summary>
		/// <param name='ch'> </param>
		/// <returns>A System.Boolean</returns>
		[return: MarshalAs(UnmanagedType.VariantBool)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		public virtual extern bool get_IsOpen(int ch);

		/// <summary>Member get_IsClose </summary>
		/// <param name='ch'> </param>
		/// <returns>A System.Boolean</returns>
		[return: MarshalAs(UnmanagedType.VariantBool)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		public virtual extern bool get_IsClose(int ch);

		/// <summary>Member get_IsWordMedial </summary>
		/// <param name='ch'> </param>
		/// <returns>A System.Boolean</returns>
		[return: MarshalAs(UnmanagedType.VariantBool)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		public virtual extern bool get_IsWordMedial(int ch);

		/// <summary>Member get_IsControl </summary>
		/// <param name='ch'> </param>
		/// <returns>A System.Boolean</returns>
		[return: MarshalAs(UnmanagedType.VariantBool)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		public virtual extern bool get_IsControl(int ch);

		/// <summary>Member get_ToLowerCh </summary>
		/// <param name='ch'> </param>
		/// <returns>A System.Int32</returns>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		public virtual extern int get_ToLowerCh(int ch);

		/// <summary>Member get_ToUpperCh </summary>
		/// <param name='ch'> </param>
		/// <returns>A System.Int32</returns>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		public virtual extern int get_ToUpperCh(int ch);

		/// <summary>Member get_ToTitleCh </summary>
		/// <param name='ch'> </param>
		/// <returns>A System.Int32</returns>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		public virtual extern int get_ToTitleCh(int ch);

		/// <summary>Member ToLower </summary>
		/// <param name='bstr'> </param>
		/// <returns>A System.String</returns>
		[return: MarshalAs(UnmanagedType.BStr)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		public virtual extern string ToLower([MarshalAs(UnmanagedType.BStr)] string bstr);

		/// <summary>Member ToUpper </summary>
		/// <param name='bstr'> </param>
		/// <returns>A System.String</returns>
		[return: MarshalAs(UnmanagedType.BStr)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		public virtual extern string ToUpper([MarshalAs(UnmanagedType.BStr)] string bstr);

		/// <summary>Member ToTitle </summary>
		/// <param name='bstr'> </param>
		/// <returns>A System.String</returns>
		[return: MarshalAs(UnmanagedType.BStr)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		public virtual extern string ToTitle([MarshalAs(UnmanagedType.BStr)] string bstr);

		/// <summary>Member ToLowerRgch </summary>
		/// <param name='_rgchIn'> </param>
		/// <param name='cchIn'> </param>
		/// <param name='_rgchOut'> </param>
		/// <param name='cchOut'> </param>
		/// <param name='_cchRet'> </param>
		[TypeLibFunc(TypeLibFuncFlags.FRestricted)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		public virtual extern void ToLowerRgch([MarshalAs(UnmanagedType.LPWStr)] string _rgchIn, int cchIn, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef=typeof(ArrayPtrMarshaler))] ArrayPtr/*OLECHAR[]*/ _rgchOut, int cchOut, out int _cchRet);

		/// <summary>Member ToUpperRgch </summary>
		/// <param name='_rgchIn'> </param>
		/// <param name='cchIn'> </param>
		/// <param name='_rgchOut'> </param>
		/// <param name='cchOut'> </param>
		/// <param name='_cchRet'> </param>
		[TypeLibFunc(TypeLibFuncFlags.FRestricted)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		public virtual extern void ToUpperRgch([MarshalAs(UnmanagedType.LPWStr)] string _rgchIn, int cchIn, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef=typeof(ArrayPtrMarshaler))] ArrayPtr/*OLECHAR[]*/ _rgchOut, int cchOut, out int _cchRet);

		/// <summary>Member ToTitleRgch </summary>
		/// <param name='_rgchIn'> </param>
		/// <param name='cchIn'> </param>
		/// <param name='_rgchOut'> </param>
		/// <param name='cchOut'> </param>
		/// <param name='_cchRet'> </param>
		[TypeLibFunc(TypeLibFuncFlags.FRestricted)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		public virtual extern void ToTitleRgch([MarshalAs(UnmanagedType.LPWStr)] string _rgchIn, int cchIn, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef=typeof(ArrayPtrMarshaler))] ArrayPtr/*OLECHAR[]*/ _rgchOut, int cchOut, out int _cchRet);

		/// <summary>Member get_IsUserDefinedClass </summary>
		/// <param name='ch'> </param>
		/// <param name='chClass'> </param>
		/// <returns>A System.Boolean</returns>
		[return: MarshalAs(UnmanagedType.VariantBool)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		public virtual extern bool get_IsUserDefinedClass(int ch, int chClass);

		/// <summary>Member get_SoundAlikeKey </summary>
		/// <param name='bstrValue'> </param>
		/// <returns>A System.String</returns>
		[return: MarshalAs(UnmanagedType.BStr)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		public virtual extern string get_SoundAlikeKey([MarshalAs(UnmanagedType.BStr)] string bstrValue);

		/// <summary>Member get_CharacterName </summary>
		/// <param name='ch'> </param>
		/// <returns>A System.String</returns>
		[return: MarshalAs(UnmanagedType.BStr)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		public virtual extern string get_CharacterName(int ch);

		/// <summary>Member get_Decomposition </summary>
		/// <param name='ch'> </param>
		/// <returns>A System.String</returns>
		[return: MarshalAs(UnmanagedType.BStr)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		public virtual extern string get_Decomposition(int ch);

		/// <summary>Member DecompositionRgch </summary>
		/// <param name='ch'> </param>
		/// <param name='cchMax'> </param>
		/// <param name='_rgch'> </param>
		/// <param name='_cch'> </param>
		/// <param name='_fHasDecomp'> </param>
		[TypeLibFunc(TypeLibFuncFlags.FRestricted)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		public virtual extern void DecompositionRgch(int ch, int cchMax, out ushort _rgch, out int _cch, [MarshalAs(UnmanagedType.VariantBool)] out bool _fHasDecomp);

		/// <summary>Member get_FullDecomp </summary>
		/// <param name='ch'> </param>
		/// <returns>A System.String</returns>
		[return: MarshalAs(UnmanagedType.BStr)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		public virtual extern string get_FullDecomp(int ch);

		/// <summary>Member FullDecompRgch </summary>
		/// <param name='ch'> </param>
		/// <param name='cchMax'> </param>
		/// <param name='_rgch'> </param>
		/// <param name='_cch'> </param>
		/// <param name='_fHasDecomp'> </param>
		[TypeLibFunc(TypeLibFuncFlags.FRestricted)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		public virtual extern void FullDecompRgch(int ch, int cchMax, out ushort _rgch, out int _cch, [MarshalAs(UnmanagedType.VariantBool)] out bool _fHasDecomp);

		/// <summary>Member get_NumericValue </summary>
		/// <param name='ch'> </param>
		/// <returns>A System.Int32</returns>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		public virtual extern int get_NumericValue(int ch);

		/// <summary>Member get_CombiningClass </summary>
		/// <param name='ch'> </param>
		/// <returns>A System.Int32</returns>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		public virtual extern int get_CombiningClass(int ch);

		/// <summary>Member get_Comment </summary>
		/// <param name='ch'> </param>
		/// <returns>A System.String</returns>
		[return: MarshalAs(UnmanagedType.BStr)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		public virtual extern string get_Comment(int ch);

		/// <summary>Member GetLineBreakProps </summary>
		/// <param name='_rgchIn'> </param>
		/// <param name='cchIn'> </param>
		/// <param name='_rglbOut'> </param>
		[TypeLibFunc(TypeLibFuncFlags.FRestricted)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		public virtual extern void GetLineBreakProps([MarshalAs(UnmanagedType.LPWStr)] string _rgchIn, int cchIn, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef=typeof(ArrayPtrMarshaler))] ArrayPtr/*byte[]*/ _rglbOut);

		/// <summary>Member GetLineBreakStatus </summary>
		/// <param name='_rglbpIn'> </param>
		/// <param name='cb'> </param>
		/// <param name='_rglbsOut'> </param>
		[TypeLibFunc(TypeLibFuncFlags.FRestricted)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		public virtual extern void GetLineBreakStatus([MarshalAs(UnmanagedType.LPArray, SizeParamIndex=1)] byte[] _rglbpIn, int cb, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef=typeof(ArrayPtrMarshaler))] ArrayPtr/*byte[]*/ _rglbsOut);

		/// <summary>Member GetLineBreakInfo </summary>
		/// <param name='_rgchIn'> </param>
		/// <param name='cchIn'> </param>
		/// <param name='ichMin'> </param>
		/// <param name='ichLim'> </param>
		/// <param name='_rglbsOut'> </param>
		/// <param name='_ichBreak'> </param>
		[TypeLibFunc(TypeLibFuncFlags.FRestricted)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		public virtual extern void GetLineBreakInfo([MarshalAs(UnmanagedType.LPWStr)] string _rgchIn, int cchIn, int ichMin, int ichLim, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef=typeof(ArrayPtrMarshaler))] ArrayPtr/*byte[]*/ _rglbsOut, out int _ichBreak);

		/// <summary>Member StripDiacritics </summary>
		/// <param name='bstr'> </param>
		/// <returns>A System.String</returns>
		[return: MarshalAs(UnmanagedType.BStr)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		public virtual extern string StripDiacritics([MarshalAs(UnmanagedType.BStr)] string bstr);

		/// <summary>Member StripDiacriticsRgch </summary>
		/// <param name='_rgchIn'> </param>
		/// <param name='cchIn'> </param>
		/// <param name='_rgchOut'> </param>
		/// <param name='cchMaxOut'> </param>
		/// <param name='_cchOut'> </param>
		[TypeLibFunc(TypeLibFuncFlags.FRestricted)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		public virtual extern void StripDiacriticsRgch([MarshalAs(UnmanagedType.LPWStr)] string _rgchIn, int cchIn, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef=typeof(ArrayPtrMarshaler))] ArrayPtr/*OLECHAR[]*/ _rgchOut, int cchMaxOut, out int _cchOut);

		/// <summary>Member NormalizeKdRgch </summary>
		/// <param name='_rgchIn'> </param>
		/// <param name='cchIn'> </param>
		/// <param name='_rgchOut'> </param>
		/// <param name='cchMaxOut'> </param>
		/// <param name='_cchOut'> </param>
		[TypeLibFunc(TypeLibFuncFlags.FRestricted)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		public virtual extern void NormalizeKdRgch([MarshalAs(UnmanagedType.LPWStr)] string _rgchIn, int cchIn, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef=typeof(ArrayPtrMarshaler))] ArrayPtr/*OLECHAR[]*/ _rgchOut, int cchMaxOut, out int _cchOut);

		/// <summary>Member NormalizeD </summary>
		/// <param name='bstr'> </param>
		/// <returns>A System.String</returns>
		[return: MarshalAs(UnmanagedType.BStr)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		public virtual extern string NormalizeD([MarshalAs(UnmanagedType.BStr)] string bstr);

		/// <summary>Member NormalizeDRgch </summary>
		/// <param name='_rgchIn'> </param>
		/// <param name='cchIn'> </param>
		/// <param name='_rgchOut'> </param>
		/// <param name='cchMaxOut'> </param>
		/// <param name='_cchOut'> </param>
		[TypeLibFunc(TypeLibFuncFlags.FRestricted)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		public virtual extern void NormalizeDRgch([MarshalAs(UnmanagedType.LPWStr)] string _rgchIn, int cchIn, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef=typeof(ArrayPtrMarshaler))] ArrayPtr/*OLECHAR[]*/ _rgchOut, int cchMaxOut, out int _cchOut);

		/// <summary>Gets/Sets a Locale </summary>
		/// <returns>A System.Int32 </returns>
		public virtual extern int Locale
		{
			[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
			get;
			[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
			set;
		}

		/// <summary>Member GetLineBreakText </summary>
		/// <param name='cchMax'> </param>
		/// <param name='_rgchOut'> </param>
		/// <param name='_cchOut'> </param>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		public virtual extern void GetLineBreakText(int cchMax, out ushort _rgchOut, out int _cchOut);

		/// <summary>Member set_LineBreakText </summary>
		/// <param name='_rgchIn'> </param>
		/// <param name='cchMax'> </param>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		public virtual extern void set_LineBreakText([MarshalAs(UnmanagedType.LPWStr)] string _rgchIn, int cchMax);

		/// <summary>Member LineBreakBefore </summary>
		/// <param name='ichIn'> </param>
		/// <param name='_ichOut'> </param>
		/// <param name='_lbWeight'> </param>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		public virtual extern void LineBreakBefore(int ichIn, out int _ichOut, out LgLineBreak _lbWeight);

		/// <summary>Member LineBreakAfter </summary>
		/// <param name='ichIn'> </param>
		/// <param name='_ichOut'> </param>
		/// <param name='_lbWeight'> </param>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		public virtual extern void LineBreakAfter(int ichIn, out int _ichOut, out LgLineBreak _lbWeight);

		/// <summary> </summary>
		/// <param name='bstrLanguage'> </param>
		/// <param name='bstrScript'> </param>
		/// <param name='bstrCountry'> </param>
		/// <param name='bstrVariant'> </param>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		public virtual extern void Initialize([MarshalAs(UnmanagedType.BStr)] string bstrLanguage, [MarshalAs(UnmanagedType.BStr)] string bstrScript, [MarshalAs(UnmanagedType.BStr)] string bstrCountry, [MarshalAs(UnmanagedType.BStr)] string bstrVariant);

		/// <summary> </summary>
		/// <param name='bstrWsCharsList'> </param>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		public virtual extern void InitCharOverrides([MarshalAs(UnmanagedType.BStr)] string bstrWsCharsList);
	}
	#endregion

	/// <summary>LgIcuCharPropEngineClass </summary>
	public static class LgIcuCharPropEngineClass
	{

		/// <summary>Member Create </summary>
		/// <returns>A LgIcuCharPropEngine</returns>
		public static LgIcuCharPropEngine Create()
		{
			return new _LgIcuCharPropEngineClass();
		}
	}
	#endregion

	#region LgCPWordTokenizer CoClass definitions
	/// <summary>LgCPWordTokenizer </summary>
	[ComImport()]
	[CoClass(typeof(_LgCPWordTokenizerClass))]
	[Guid("577C6DA1-CFC1-4AFB-82B2-AF818EC2FE9F")]
	public interface LgCPWordTokenizer : ILgTokenizer
	{
	}

	#region Private _LgCPWordTokenizerClass class
	/// <summary>_LgCPWordTokenizerClass </summary>
	[ComImport()]
	[ClassInterface(ClassInterfaceType.None)]
	[TypeLibType(TypeLibTypeFlags.FCanCreate)]
	[Guid("7CE7CE94-AC47-42A5-823F-2F8EF51A9007")]
	internal class _LgCPWordTokenizerClass : ILgTokenizer, LgCPWordTokenizer
	{

		/// <summary>
		/// Get the next token of whatever kind this tokenizer supports from the input string.
		/// Set pichMin to the offset of the first character of the token, and pichLim
		/// to the offset of the first character after the token.
		///</summary>
		/// <param name='_rgchInput'>points to the text to tokenize.
		/// If it has more than cch characters, the rest will be ignored.
		/// ENHANCE JohnT: should we pass an ichMin? </param>
		/// <param name='cch'>specifies the number of characters in the input string </param>
		/// <param name='_ichMin'> </param>
		/// <param name='_ichLim'> </param>
		/// <exception cref="COMException">if no more tokens available. Also set pichMin and pichLim to 1. (E_FAIL)</exception>
		[TypeLibFunc(TypeLibFuncFlags.FRestricted)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		public virtual extern void GetToken([MarshalAs(UnmanagedType.LPWStr)] string _rgchInput, int cch, out int _ichMin, out int _ichLim);

		/// <summary>
		/// Get the start of the first token that begins at or after offset
		/// ichFirst in the input string bstrInput.
		/// Characters before ichFirst are not examined; the result is as if the string
		/// began at ichFirst.
		///</summary>
		/// <param name='bstrInput'> </param>
		/// <param name='ichFirst'> </param>
		/// <returns></returns>
		/// <exception cref="COMException">if no token found (E_FAIL)</exception>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		public virtual extern int get_TokenStart([MarshalAs(UnmanagedType.BStr)] string bstrInput, int ichFirst);

		/// <summary>
		/// Get the end of the first token that BEGINS at or after ichFirst.
		/// Note: ichFirst may be the result obtained from a previous call to TokenStart,
		/// rather than the value passed to TokenStart, but to obtain the limit of the same
		/// token it must not be larger than that. In other words, this method does NOT
		/// find the first endoftoken at or after ichFirst: it must find a complete token
		/// starting there.
		///</summary>
		/// <param name='bstrInput'> </param>
		/// <param name='ichFirst'> </param>
		/// <returns></returns>
		/// <exception cref="COMException">if no token found (E_FAIL)</exception>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		public virtual extern int get_TokenEnd([MarshalAs(UnmanagedType.BStr)] string bstrInput, int ichFirst);
	}
	#endregion

	/// <summary>LgCPWordTokenizerClass </summary>
	public static class LgCPWordTokenizerClass
	{

		/// <summary>Member Create </summary>
		/// <returns>A LgCPWordTokenizer</returns>
		public static LgCPWordTokenizer Create()
		{
			return new _LgCPWordTokenizerClass();
		}
	}
	#endregion

	#region LgWfiSpellChecker CoClass definitions
	/// <summary>LgWfiSpellChecker </summary>
	[ComImport()]
	[CoClass(typeof(_LgWfiSpellCheckerClass))]
	[Guid("9F9298F5-FD41-44B0-83BA-BED9F56CF974")]
	public interface LgWfiSpellChecker : ILgSpellCheckFactory
	{
	}

	#region Private _LgWfiSpellCheckerClass class
	/// <summary>_LgWfiSpellCheckerClass </summary>
	[ComImport()]
	[ClassInterface(ClassInterfaceType.None)]
	[TypeLibType(TypeLibTypeFlags.FCanCreate)]
	[Guid("818445E2-0282-4688-8BB7-147FAACFF73A")]
	internal class _LgWfiSpellCheckerClass : ILgSpellCheckFactory, LgWfiSpellChecker
	{

		/// <summary> Get a checker object ready to be used for one spellcheck session. </summary>
		/// <returns>A ILgSpellChecker </returns>
		public virtual extern ILgSpellChecker Checker
		{
			[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
			[return: MarshalAs(UnmanagedType.Interface)]
			get;
		}
	}
	#endregion

	/// <summary>LgWfiSpellCheckerClass </summary>
	public static class LgWfiSpellCheckerClass
	{

		/// <summary>Member Create </summary>
		/// <returns>A LgWfiSpellChecker</returns>
		public static LgWfiSpellChecker Create()
		{
			return new _LgWfiSpellCheckerClass();
		}
	}
	#endregion

	#region LgMSWordSpellChecker CoClass definitions
	/// <summary>LgMSWordSpellChecker </summary>
	[ComImport()]
	[CoClass(typeof(_LgMSWordSpellCheckerClass))]
	[Guid("9F9298F5-FD41-44B0-83BA-BED9F56CF974")]
	public interface LgMSWordSpellChecker : ILgSpellCheckFactory
	{
	}

	#region Private _LgMSWordSpellCheckerClass class
	/// <summary>_LgMSWordSpellCheckerClass </summary>
	[ComImport()]
	[ClassInterface(ClassInterfaceType.None)]
	[TypeLibType(TypeLibTypeFlags.FCanCreate)]
	[Guid("5CF96DA5-299E-4FC5-A990-2D2FCEE7834D")]
	internal class _LgMSWordSpellCheckerClass : ILgSpellCheckFactory, LgMSWordSpellChecker
	{

		/// <summary> Get a checker object ready to be used for one spellcheck session. </summary>
		/// <returns>A ILgSpellChecker </returns>
		public virtual extern ILgSpellChecker Checker
		{
			[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
			[return: MarshalAs(UnmanagedType.Interface)]
			get;
		}
	}
	#endregion

	/// <summary>LgMSWordSpellCheckerClass </summary>
	public static class LgMSWordSpellCheckerClass
	{

		/// <summary>Member Create </summary>
		/// <returns>A LgMSWordSpellChecker</returns>
		public static LgMSWordSpellChecker Create()
		{
			return new _LgMSWordSpellCheckerClass();
		}
	}
	#endregion

	#region LgNumericEngine CoClass definitions
	/// <summary>
	/// Interface ILgNumericEngine
	/// Knows how to convert numbers to and from binary.
	///
	/// ENHANCE JohnT: do we need something analogous to Locales? For example, Australia, US
	/// and Great Britain all use English, but use different date and currency
	/// conventions. They don't actually do numbers differently, but other similar
	/// situations could require that.
	///
	/// ENHANCE JohnT: do we need similar routines for doubles? Do they have languagespecific
	/// formats?
	///
	/// ENHANCE JohnT: do we need a similar engine (or part of this?) for currencies and dates?
	///
	/// ENHANCE JohnT: do we need this at all? Or can we just record a locale in the writing
	/// system and use standard system number formatting?
	///
	/// <h3>When to implement</h3>
	/// Only if you need a number representation that can't be done with any of the standard
	/// approaches.
	///
	/// <h3>When to use</h3>
	/// Use this interface when you need to convert numbers to and from binary in a language dependent way.
	///
	/// <h3>How to obtain an instance</h3>
	/// If we decide to proceed with this notion, there will need to be a method on writing
	/// system to return one. For now the only way is to create one using CoCreateInstance,
	/// with CLSID_LgNumericEngine. This creates a very simple engine that does decimal
	/// numbers but can be customized as to which characters it uses for decimal separator,
	/// thousands separator, exponential notation, and minus. You must QueryInterface
	/// for ISimpleInit and pass an initialization string to set up the special characters.
	/// For example,
	///
	/// <code>
	/// IClassInitMonikerPtr acim;
	/// qcim.CreateInstance(CLSID_LgNumericEngine);
	/// CheckHr(qcim&gt;InitNew((BYTE)L".,E", 4 isizeof(wchar)));
	/// ILgNumericEnginePtr qnumeng;
	/// CheckHr(qcim&gt;QueryInterface(IID_ILgNumericEngine, (void )&amp;qnumeng));
	/// </code>
	///
	/// Hungarian: <c>numeng</c>
	///</summary>
	[ComImport()]
	[CoClass(typeof(_LgNumericEngineClass))]
	[Guid("CBBF35E1-CE39-4EEC-AEBD-5B4AAAA52B6C")]
	public interface LgNumericEngine : ILgNumericEngine
	{
	}

	#region Private _LgNumericEngineClass class
	/// <summary>_LgNumericEngineClass </summary>
	[ComImport()]
	[ClassInterface(ClassInterfaceType.None)]
	[TypeLibType(TypeLibTypeFlags.FCanCreate)]
	[Guid("FF22A7AB-223E-4D04-B648-0AE40588261D")]
	internal class _LgNumericEngineClass : ILgNumericEngine, LgNumericEngine
	{

		/// <summary> Get the default string version of an integer, e.g., 123456, 654321 </summary>
		/// <param name='n'> </param>
		/// <returns></returns>
		[return: MarshalAs(UnmanagedType.BStr)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		public virtual extern string get_IntToString(int n);

		/// <summary>
		/// Get a string representation of an integer using commas or the equivalent,
		/// e.g., 12,345,678
		///</summary>
		/// <param name='n'> </param>
		/// <returns></returns>
		[return: MarshalAs(UnmanagedType.BStr)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		public virtual extern string get_IntToPrettyString(int n);

		/// <summary>
		/// Get a binary integer corresponding to anything IntToString could output
		/// Can handle leading and trailing white space.
		/// ENHANCE JohnT: should it also handle output of IntToPrettyString?
		///</summary>
		/// <param name='bstr'> </param>
		/// <returns></returns>
		/// <exception cref="COMException">if result will not fit in 32 bit signed int, or if any
		/// characters are not used up in the string (except white space). (E_FAIL)</exception>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		public virtual extern int get_StringToInt([MarshalAs(UnmanagedType.BStr)] string bstr);

		/// <summary>
		/// Get a binary integer corresponding to anything IntToString could output
		/// Can handle leading white space; trailing is handled using pichUnused.
		/// ENHANCE JohnT: should it also handle output of IntToPrettyString?
		///</summary>
		/// <param name='_rgch'> </param>
		/// <param name='cch'> </param>
		/// <param name='_n'> </param>
		/// <param name='_ichUnused'>Set to the index of the first character not processed, that is,
		/// not recognized as part of a number. </param>
		/// <exception cref="COMException">if result will not fit in 32 bit signed int (E_FAIL)</exception>
		[TypeLibFunc(TypeLibFuncFlags.FRestricted)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		public virtual extern void StringToIntRgch([MarshalAs(UnmanagedType.LPWStr)] string _rgch, int cch, out int _n, out int _ichUnused);

		/// <summary>
		/// ENHANCE JohnT: should we have hex or other base output?
		/// Get the default string representation of a double, e.g., 1234.56, 6543.21
		///</summary>
		/// <param name='dbl'> </param>
		/// <param name='cchFracDigits'> number of digits after decimal </param>
		/// <returns></returns>
		[return: MarshalAs(UnmanagedType.BStr)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		public virtual extern string get_DblToString(double dbl, int cchFracDigits);

		/// <summary>
		/// Get a string version of a double with commas or the equivalent, e.g., 12,345,678.9
		///</summary>
		/// <param name='dbl'> </param>
		/// <param name='cchFracDigits'> number of digits after decimal </param>
		/// <returns></returns>
		[return: MarshalAs(UnmanagedType.BStr)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		public virtual extern string get_DblToPrettyString(double dbl, int cchFracDigits);

		/// <summary> Get a string representation of a double in exp notation, e.g., 1.2345E3 </summary>
		/// <param name='dbl'> </param>
		/// <param name='cchFracDigits'> number of digits after decimal </param>
		/// <returns></returns>
		[return: MarshalAs(UnmanagedType.BStr)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		public virtual extern string get_DblToExpString(double dbl, int cchFracDigits);

		/// <summary>
		/// Get a double from a string (anything DblToString or DblToExpString could output)
		/// Can handle leading and trailing white space.
		/// ENHANCE JohnT: should it also handle output of IntToPrettyString?
		///</summary>
		/// <param name='bstr'> </param>
		/// <returns></returns>
		/// <exception cref="COMException">if any characters are not used up in the string (except white
		/// space). (E_FAIL)</exception>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		public virtual extern double get_StringToDbl([MarshalAs(UnmanagedType.BStr)] string bstr);

		/// <summary>
		/// Get a double from a string (anything DblToString or DblToExpString could output)
		/// Can handle leading white space; trailing is handled using pichUnused.
		///</summary>
		/// <param name='_rgch'> </param>
		/// <param name='cch'> </param>
		/// <param name='_dbl'> </param>
		/// <param name='_ichUnused'>Set to the index of the first character not processed, that is,
		/// not recognized as part of a number. </param>
		[TypeLibFunc(TypeLibFuncFlags.FRestricted)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		public virtual extern void StringToDblRgch([MarshalAs(UnmanagedType.LPWStr)] string _rgch, int cch, out double _dbl, out int _ichUnused);
	}
	#endregion

	/// <summary>LgNumericEngineClass </summary>
	public static class LgNumericEngineClass
	{

		/// <summary>Member Create </summary>
		/// <returns>A LgNumericEngine</returns>
		public static LgNumericEngine Create()
		{
			return new _LgNumericEngineClass();
		}
	}
	#endregion

	#region LgKeymanHandler CoClass definitions
	/// <summary>
	/// Interface ILgKeymanHandler
	///
	/// An interface that manages Keyman, being able to invoke a keyboard, find out which
	/// one is active, find out which keyboards are available, return the windows message that
	/// Keyman sends when a keyboard is selected, and so forth.
	///
	/// <h3>When to implement</h3>
	/// The standard implementation should suffice.
	///
	/// <h3>When to use</h3>
	/// Whenever you want to manipulate or query Keyman
	///
	/// Hungarian: <c>lkh</c>
	///</summary>
	[ComImport()]
	[CoClass(typeof(_LgKeymanHandlerClass))]
	[Guid("10958C2A-428B-4AB8-803F-E79B6FB453B3")]
	public interface LgKeymanHandler : ILgKeymanHandler
	{
	}

	#region Private _LgKeymanHandlerClass class
	/// <summary>_LgKeymanHandlerClass </summary>
	[ComImport()]
	[ClassInterface(ClassInterfaceType.None)]
	[TypeLibType(TypeLibTypeFlags.FCanCreate)]
	[Guid("69ACA99C-F852-4C2C-9B5F-FF83238A17A5")]
	internal class _LgKeymanHandlerClass : ILgKeymanHandler, LgKeymanHandler
	{

		/// <summary>
		/// Initialize the Keyboard handler. Set fForce to reinitialize even if already
		/// initialized, for example, if a keyboard has been added or removed.
		/// All data is static, so it is only necessary to call this for one instance.
		/// Actually, it is not strictly necessary to call it at all, as other methods will
		/// do so if necessary.
		///</summary>
		/// <param name='fForce'> </param>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		public virtual extern void Init([MarshalAs(UnmanagedType.VariantBool)] bool fForce);

		/// <summary> Obtain the number of keyboard layouts currently avaiable. </summary>
		/// <returns>A System.Int32 </returns>
		public virtual extern int NLayout
		{
			[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
			get;
		}

		/// <summary> Obtain the ith layout name. </summary>
		/// <param name='ilayout'> </param>
		/// <returns></returns>
		[return: MarshalAs(UnmanagedType.BStr)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		public virtual extern string get_Name(int ilayout);

		/// <summary> Get/Set the active keyboard. </summary>
		/// <returns>A System.String </returns>
		public virtual extern string ActiveKeyboardName
		{
			[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
			[return: MarshalAs(UnmanagedType.BStr)]
			get;
			[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
			[param: MarshalAs(UnmanagedType.BStr)]
			set;
		}

		/// <summary>
		/// Return the windows message (obtained from RegisterWindowsMessage("WM_KMSELECTLANG").
		///</summary>
		/// <returns>A System.Int32 </returns>
		public virtual extern int KeymanWindowsMessage
		{
			[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
			get;
		}
	}
	#endregion

	/// <summary>LgKeymanHandlerClass </summary>
	public static class LgKeymanHandlerClass
	{

		/// <summary>Member Create </summary>
		/// <returns>A LgKeymanHandler</returns>
		public static LgKeymanHandler Create()
		{
			return new _LgKeymanHandlerClass();
		}
	}
	#endregion

	#region LgTextServices CoClass definitions
	/// <summary>
	/// Interface ILgTextServices
	///
	/// Provide access to TSF functionality wrapped in easytocall methods.
	///
	/// <h3>When to implement</h3>
	/// Clients should not implement this interface. There is a standard implementation in
	/// Language.dll.
	///
	/// <h3>When to use</h3>
	/// When TSF related functionality is needed, especially from C
	///</summary>
	[ComImport()]
	[CoClass(typeof(_LgTextServicesClass))]
	[Guid("5B6303DE-E635-4DD7-A7FC-345BEEF352D8")]
	public interface LgTextServices : ILgTextServices
	{
	}

	#region Private _LgTextServicesClass class
	/// <summary>_LgTextServicesClass </summary>
	[ComImport()]
	[ClassInterface(ClassInterfaceType.None)]
	[TypeLibType(TypeLibTypeFlags.FCanCreate)]
	[Guid("720485C5-E8D5-4761-92F0-F70D2B3CF980")]
	internal class _LgTextServicesClass : ILgTextServices, LgTextServices
	{

		/// <summary> Set the system keyboard and TSF language. </summary>
		/// <param name='nLcid'> </param>
		/// <param name='bstrKeymanKbd'> </param>
		/// <param name='_nActiveLangId'> </param>
		/// <param name='_bstrActiveKeymanKbd'> </param>
		/// <param name='_fSelectLangPending'> </param>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		public virtual extern void SetKeyboard(int nLcid, [MarshalAs(UnmanagedType.BStr)] string bstrKeymanKbd, ref int _nActiveLangId, [MarshalAs(UnmanagedType.BStr)] ref string _bstrActiveKeymanKbd, [MarshalAs(UnmanagedType.VariantBool)] ref bool _fSelectLangPending);
	}
	#endregion

	/// <summary>LgTextServicesClass </summary>
	public static class LgTextServicesClass
	{

		/// <summary>Member Create </summary>
		/// <returns>A LgTextServices</returns>
		public static LgTextServices Create()
		{
			return new _LgTextServicesClass();
		}
	}
	#endregion

	#region LgCodePageEnumerator CoClass definitions
	/// <summary>
	/// Interface ILgCodePageEnumerator
	///
	/// An interface that allows retrieving a list of the code pages installed on the system,
	/// with names suitable for displaying in a combo box.
	///
	/// <h3>When to implement</h3>
	/// The standard implementation should suffice.
	///
	/// <h3>When to use</h3>
	/// Whenever you want to retrieve a list of available code pages.
	///
	/// Hungarian: <c>lcpe</c>
	///</summary>
	[ComImport()]
	[CoClass(typeof(_LgCodePageEnumeratorClass))]
	[Guid("2CFCF4B7-2FFE-4CF8-91BE-FBB57CC7782A")]
	public interface LgCodePageEnumerator : ILgCodePageEnumerator
	{
	}

	#region Private _LgCodePageEnumeratorClass class
	/// <summary>_LgCodePageEnumeratorClass </summary>
	[ComImport()]
	[ClassInterface(ClassInterfaceType.None)]
	[TypeLibType(TypeLibTypeFlags.FCanCreate)]
	[Guid("9045F113-8626-41C0-A61E-A73FBE5920D1")]
	internal class _LgCodePageEnumeratorClass : ILgCodePageEnumerator, LgCodePageEnumerator
	{

		/// <summary>
		/// Initialize enumerator. This default initializer gives all known code pages.
		/// We may eventually have others that allow them to be limited.
		///</summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		public virtual extern void Init();

		/// <summary>
		/// Get the next code page. When there are no more, sets pnId to 0 and pbstrName to null.
		///</summary>
		/// <param name='_nId'> </param>
		/// <param name='_bstrName'> </param>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		public virtual extern void Next(out int _nId, [MarshalAs(UnmanagedType.BStr)] out string _bstrName);
	}
	#endregion

	/// <summary>LgCodePageEnumeratorClass </summary>
	public static class LgCodePageEnumeratorClass
	{

		/// <summary>Member Create </summary>
		/// <returns>A LgCodePageEnumerator</returns>
		public static LgCodePageEnumerator Create()
		{
			return new _LgCodePageEnumeratorClass();
		}
	}
	#endregion

	#region LgLanguageEnumerator CoClass definitions
	/// <summary>
	/// Interface ILgLanguageEnumerator
	///
	/// An interface that allows retrieving a list of the languages installed on the system,
	/// with names suitable for displaying in a combo box.
	///
	/// <h3>When to implement</h3>
	/// The standard implementation should suffice.
	///
	/// <h3>When to use</h3>
	/// Whenever you want to retrieve a list of available languages.
	///
	/// Hungarian: <c>lcpe</c>
	///</summary>
	[ComImport()]
	[CoClass(typeof(_LgLanguageEnumeratorClass))]
	[Guid("746A16E1-0C36-4268-A261-E8012B0D67C5")]
	public interface LgLanguageEnumerator : ILgLanguageEnumerator
	{
	}

	#region Private _LgLanguageEnumeratorClass class
	/// <summary>_LgLanguageEnumeratorClass </summary>
	[ComImport()]
	[ClassInterface(ClassInterfaceType.None)]
	[TypeLibType(TypeLibTypeFlags.FCanCreate)]
	[Guid("B887505B-74DE-4ADC-A1D9-5553428C8D02")]
	internal class _LgLanguageEnumeratorClass : ILgLanguageEnumerator, LgLanguageEnumerator
	{

		/// <summary>
		/// Initialize enumerator. This default initializer gives all installed languages.
		/// We may eventually have others that allow them to be limited.
		///</summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		public virtual extern void Init();

		/// <summary>
		/// Get the next language. When there are no more, sets pnId to 0 and pbstrName to null.
		/// For a language unsupported by the OS, it returns the id along with E_FAIL.
		///</summary>
		/// <param name='_nId'> </param>
		/// <param name='_bstrName'> </param>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		public virtual extern void Next(out int _nId, [MarshalAs(UnmanagedType.BStr)] out string _bstrName);
	}
	#endregion

	/// <summary>LgLanguageEnumeratorClass </summary>
	public static class LgLanguageEnumeratorClass
	{

		/// <summary>Member Create </summary>
		/// <returns>A LgLanguageEnumerator</returns>
		public static LgLanguageEnumerator Create()
		{
			return new _LgLanguageEnumeratorClass();
		}
	}
	#endregion

	#region LgIcuConverterEnumerator CoClass definitions
	/// <summary>
	/// Interface ILgIcuConverterEnumerator
	///
	/// An interface that allows retrieving a list of the converters that ICU supports.
	/// Eventually it may also support creating converters, though our preferred approach is
	/// to use the EncConverters interface.
	///
	/// <h3>When to implement</h3>
	/// The standard implementation should suffice.
	///
	/// <h3>When to use</h3>
	/// To retrieve a list of available converters.
	///
	/// Hungarian: <c>lcpe</c>
	///</summary>
	[ComImport()]
	[CoClass(typeof(_LgIcuConverterEnumeratorClass))]
	[Guid("8E6D558E-8755-4EA1-9FF6-039D375312E9")]
	public interface LgIcuConverterEnumerator : ILgIcuConverterEnumerator
	{
	}

	#region Private _LgIcuConverterEnumeratorClass class
	/// <summary>_LgIcuConverterEnumeratorClass </summary>
	[ComImport()]
	[ClassInterface(ClassInterfaceType.None)]
	[TypeLibType(TypeLibTypeFlags.FCanCreate)]
	[Guid("9E729461-F80D-4796-BA17-086BC61907F1")]
	internal class _LgIcuConverterEnumeratorClass : ILgIcuConverterEnumerator, LgIcuConverterEnumerator
	{

		/// <summary> Get the count of available converters. </summary>
		/// <returns>A System.Int32 </returns>
		public virtual extern int Count
		{
			[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
			get;
		}

		/// <summary> Get the nth converter name. </summary>
		/// <param name='iconv'> </param>
		/// <returns></returns>
		[return: MarshalAs(UnmanagedType.BStr)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		public virtual extern string get_ConverterName(int iconv);

		/// <summary> Get the ID string that identifies the converter to ICU. </summary>
		/// <param name='iconv'> </param>
		/// <returns></returns>
		[return: MarshalAs(UnmanagedType.BStr)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		public virtual extern string get_ConverterId(int iconv);
	}
	#endregion

	/// <summary>LgIcuConverterEnumeratorClass </summary>
	public static class LgIcuConverterEnumeratorClass
	{

		/// <summary>Member Create </summary>
		/// <returns>A LgIcuConverterEnumerator</returns>
		public static LgIcuConverterEnumerator Create()
		{
			return new _LgIcuConverterEnumeratorClass();
		}
	}
	#endregion

	#region LgIcuTransliteratorEnumerator CoClass definitions
	/// <summary>
	/// Interface ILgIcuTransliteratorEnumerator
	///
	/// An interface that allows retrieving a list of the transliterators that ICU supports.
	/// Eventually it may also support creating transliterators, though our preferred approach is
	/// to use the EncConverters interface.
	///
	/// <h3>When to implement</h3>
	/// The standard implementation should suffice.
	///
	/// <h3>When to use</h3>
	/// To retrieve a list of available converters.
	///
	/// Hungarian: <c>lcpe</c>
	///</summary>
	[ComImport()]
	[CoClass(typeof(_LgIcuTransliteratorEnumeratorClass))]
	[Guid("50F2492C-6C46-48BA-8B7F-5F04153AB2CC")]
	public interface LgIcuTransliteratorEnumerator : ILgIcuTransliteratorEnumerator
	{
	}

	#region Private _LgIcuTransliteratorEnumeratorClass class
	/// <summary>_LgIcuTransliteratorEnumeratorClass </summary>
	[ComImport()]
	[ClassInterface(ClassInterfaceType.None)]
	[TypeLibType(TypeLibTypeFlags.FCanCreate)]
	[Guid("3F1FD0A4-B2B1-4589-BC82-9CEF5BA84F4E")]
	internal class _LgIcuTransliteratorEnumeratorClass : ILgIcuTransliteratorEnumerator, LgIcuTransliteratorEnumerator
	{

		/// <summary> Get the count of available converters. </summary>
		/// <returns>A System.Int32 </returns>
		public virtual extern int Count
		{
			[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
			get;
		}

		/// <summary> Get the nth converter name. </summary>
		/// <param name='itrans'> </param>
		/// <returns></returns>
		[return: MarshalAs(UnmanagedType.BStr)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		public virtual extern string get_TransliteratorName(int itrans);

		/// <summary> Get the ID string that identifies the transliterator to ICU. </summary>
		/// <param name='iconv'> </param>
		/// <returns></returns>
		[return: MarshalAs(UnmanagedType.BStr)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		public virtual extern string get_TransliteratorId(int iconv);
	}
	#endregion

	/// <summary>LgIcuTransliteratorEnumeratorClass </summary>
	public static class LgIcuTransliteratorEnumeratorClass
	{

		/// <summary>Member Create </summary>
		/// <returns>A LgIcuTransliteratorEnumerator</returns>
		public static LgIcuTransliteratorEnumerator Create()
		{
			return new _LgIcuTransliteratorEnumeratorClass();
		}
	}
	#endregion

	#region LgIcuResourceBundle CoClass definitions
	/// <summary>
	/// Interface ILgIcuResourceBundle
	///
	/// An interface that represents an instance of an ICU ResourceBundle object.
	///
	/// <h3>When to implement</h3>
	/// The standard implementation should suffice.
	///
	/// <h3>When to use</h3>
	/// To retrieve information from ICU resources; this is useful for things like enumerating
	/// the countries and locales known to the system.
	///
	/// Hungarian: <c>lcpe</c>
	///</summary>
	[ComImport()]
	[CoClass(typeof(_LgIcuResourceBundleClass))]
	[Guid("C243C72A-0D15-44D9-ABCB-A6E875A7659A")]
	public interface LgIcuResourceBundle : ILgIcuResourceBundle
	{
	}

	#region Private _LgIcuResourceBundleClass class
	/// <summary>_LgIcuResourceBundleClass </summary>
	[ComImport()]
	[ClassInterface(ClassInterfaceType.None)]
	[TypeLibType(TypeLibTypeFlags.FCanCreate)]
	[Guid("0DD7FC1A-AB97-4A39-882C-269760D86619")]
	internal class _LgIcuResourceBundleClass : ILgIcuResourceBundle, LgIcuResourceBundle
	{

		/// <summary>
		/// Initialize the root resource bundle. The path may be null to use the standard
		/// FieldWorks ICU data directory.
		///</summary>
		/// <param name='bstrPath'> </param>
		/// <param name='locale'> </param>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		public virtual extern void Init([MarshalAs(UnmanagedType.BStr)] string bstrPath, [MarshalAs(UnmanagedType.BStr)] string locale);

		/// <summary> Get the key of the bundle. (Icu getKey.) </summary>
		/// <returns>A System.String </returns>
		public virtual extern string Key
		{
			[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
			[return: MarshalAs(UnmanagedType.BStr)]
			get;
		}

		/// <summary> Get the 'string' of the bundle. (Icu getString.) </summary>
		/// <returns>A System.String </returns>
		public virtual extern string String
		{
			[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
			[return: MarshalAs(UnmanagedType.BStr)]
			get;
		}

		/// <summary>
		/// Get the name of the bundle. (Icu getName.) Note that the Key and String of the
		/// bundle are often more useful.
		///</summary>
		/// <returns>A System.String </returns>
		public virtual extern string Name
		{
			[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
			[return: MarshalAs(UnmanagedType.BStr)]
			get;
		}

		/// <summary>
		/// Get another resource bundle for a subsection of this one. (Icu get.)
		/// If the resource does not exist, this sets pprb to NULL.
		///</summary>
		/// <param name='bstrSectionName'> </param>
		/// <returns></returns>
		[return: MarshalAs(UnmanagedType.Interface)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		public virtual extern ILgIcuResourceBundle get_GetSubsection([MarshalAs(UnmanagedType.BStr)] string bstrSectionName);

		/// <summary>
		/// Determine whether the bundle has more subresources accessible through get_Next.
		/// (Icu hasNext.)
		///</summary>
		/// <returns>A System.Boolean </returns>
		public virtual extern bool HasNext
		{
			[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
			[return: MarshalAs(UnmanagedType.VariantBool)]
			get;
		}

		/// <summary>
		/// Get the 'next' subsection and advance. The first call to this retrieves the first
		/// item. Call only while HasNext returns true. (Icu getNext.)
		///</summary>
		/// <returns>A ILgIcuResourceBundle </returns>
		public virtual extern ILgIcuResourceBundle Next
		{
			[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
			[return: MarshalAs(UnmanagedType.Interface)]
			get;
		}

		/// <summary> Get the size of the bundle. (Icu getSize.) </summary>
		/// <returns>A System.Int32 </returns>
		public virtual extern int Size
		{
			[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
			get;
		}

		/// <summary> Get the ith string. (Icu getStringEx.) </summary>
		/// <param name='irb'> </param>
		/// <returns></returns>
		[return: MarshalAs(UnmanagedType.BStr)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		public virtual extern string get_StringEx(int irb);
	}
	#endregion

	/// <summary>LgIcuResourceBundleClass </summary>
	public static class LgIcuResourceBundleClass
	{

		/// <summary>Member Create </summary>
		/// <returns>A LgIcuResourceBundle</returns>
		public static LgIcuResourceBundle Create()
		{
			return new _LgIcuResourceBundleClass();
		}
	}
	#endregion

	#region LgIcuLocaleEnumerator CoClass definitions
	/// <summary>
	/// Interface ILgLocaleEnumerator
	///
	/// An interface that allows retrieving a list of the available ICU locales on the system.
	///
	/// <h3>When to implement</h3>
	/// The standard implementation should suffice.
	///
	/// <h3>When to use</h3>
	/// To retrieve a list of available locales.
	///
	/// Hungarian: <c>lcpe</c>
	///</summary>
	[ComImport()]
	[CoClass(typeof(_LgIcuLocaleEnumeratorClass))]
	[Guid("08F649D0-D8AB-447B-AAB6-21F85CFA743C")]
	public interface LgIcuLocaleEnumerator : ILgIcuLocaleEnumerator
	{
	}

	#region Private _LgIcuLocaleEnumeratorClass class
	/// <summary>_LgIcuLocaleEnumeratorClass </summary>
	[ComImport()]
	[ClassInterface(ClassInterfaceType.None)]
	[TypeLibType(TypeLibTypeFlags.FCanCreate)]
	[Guid("E426656C-64F7-480E-92F4-D41A7BFFD066")]
	internal class _LgIcuLocaleEnumeratorClass : ILgIcuLocaleEnumerator, LgIcuLocaleEnumerator
	{

		/// <summary> Get the count of available converters. </summary>
		/// <returns>A System.Int32 </returns>
		public virtual extern int Count
		{
			[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
			get;
		}

		/// <summary> Get the nth locale name. (ICU getName.) </summary>
		/// <param name='iloc'> </param>
		/// <returns></returns>
		[return: MarshalAs(UnmanagedType.BStr)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		public virtual extern string get_Name(int iloc);

		/// <summary> Get the nth locale language identifier. (ICU getLanguage.) </summary>
		/// <param name='iloc'> </param>
		/// <returns></returns>
		[return: MarshalAs(UnmanagedType.BStr)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		public virtual extern string get_Language(int iloc);

		/// <summary> Get the nth locale country. (ICU getCountry.) </summary>
		/// <param name='iloc'> </param>
		/// <returns></returns>
		[return: MarshalAs(UnmanagedType.BStr)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		public virtual extern string get_Country(int iloc);

		/// <summary> Get the nth locale variant. (ICU getVariant.) </summary>
		/// <param name='iloc'> </param>
		/// <returns></returns>
		[return: MarshalAs(UnmanagedType.BStr)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		public virtual extern string get_Variant(int iloc);

		/// <summary>
		/// Get the display name of the locale represented by this enumerator.
		/// The display name will be in the selected locale if it is nonempty;
		/// pass null or an empty string to get the system default locale.
		///</summary>
		/// <param name='iloc'> </param>
		/// <param name='bstrLocaleName'> </param>
		/// <returns></returns>
		[return: MarshalAs(UnmanagedType.BStr)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		public virtual extern string get_DisplayName(int iloc, [MarshalAs(UnmanagedType.BStr)] string bstrLocaleName);
	}
	#endregion

	/// <summary>LgIcuLocaleEnumeratorClass </summary>
	public static class LgIcuLocaleEnumeratorClass
	{

		/// <summary>Member Create </summary>
		/// <returns>A LgIcuLocaleEnumerator</returns>
		public static LgIcuLocaleEnumerator Create()
		{
			return new _LgIcuLocaleEnumeratorClass();
		}
	}
	#endregion
}
