--========================================================================
--== GetLinkedObjs
--==
--== GetLinkedObjs$ is like a Swiss Army knife. It can do just
--== about anything. Unfortunately, it does what it does excruciatingly
--== slow. fnGetObjsToRef was created to handle incoming refences. Other
--== stored functions/procedures are probably going to come as well.
--========================================================================

IF OBJECT_ID('ut_GetLinkedObjs_GetObjsToRef') IS NOT NULL BEGIN
	DROP PROCEDURE ut_GetLinkedObjs_GetObjsToRef
END
GO
CREATE PROCEDURE ut_GetLinkedObjs_GetObjsToRef AS
BEGIN

	--( fnGetObjsToRef is generated by CreateGetObjsToRef. See notes in the
	--( latter about this function and procedure.

	DECLARE
		@nObjId INT,
		@nClassId INT,
		@nRefId INT,
		@nWhatever INT

	DECLARE @tblOwnedObjs TABLE (
		ObjId INT,
		ClassId INT)

	DECLARE @tblRefs TABLE (
		ClassName NVARCHAR(100),
		FieldName NVARCHAR(100),
		ObjId INT,
		ObjClass INT,
		ObjLevel INT,
		RefObjId INT,
		RefObjClass INT,
		RefObjField INT,
		RefObjFieldOrder INT,
		RefObjFieldType INT)

	SELECT @nObjId = Obj FROM CmPossibility_Name WHERE Txt = 'noun'
	IF @@ROWCOUNT != 1
		EXEC tsu_failure 'Can''t find "noun" The database has changed.'

	SELECT TOP 1 @nRefId = ID FROM MoStemMsa WHERE PartOfSpeech = @nObjId
	IF @@ROWCOUNT != 1
		EXEC tsu_Failure 'MoStemMsa.PartOfSpeech doesn''t refer to any nouns. The database has changed.'

	INSERT INTO @tblOwnedObjs
	SELECT Id, Class$
	FROM CmObject
	WHERE Owner$ = @nObjId

	IF @@ROWCOUNT < 1
		EXEC tsu_Failure 'Noun doesn''t own any objects The database has changed.'

	INSERT INTO @tblRefs
	SELECT c.Name, f.Name,
		fn.ObjId, fn.ObjClass, fn.ObjLevel,
		fn.RefObjId, fn.RefObjClass, fn.RefObjField,
		fn.RefObjFieldOrder, fn.RefObjFieldType
	FROM dbo.fnGetRefsToObj(@nObjId, NULL) fn
	JOIN Class$ c ON c.Id = fn.RefObjClass
	JOIN Field$ f ON f.Id = fn.RefObjField

	--( Test an incoming atomic refences to the object

	SELECT TOP 1 @nWhatever = RefObjId
	FROM @tblRefs
	WHERE ObjId = @nObjId
		AND ClassName = N'MoStemMsa'
		AND FieldName = N'PartOfSpeech'

	IF @@ROWCOUNT != 1
		EXEC tsu_Failure 'No refencing nouns found.'

	--( Test incoming collection and owned object

	SELECT TOP 1 @nRefId = oo.ObjId
	FROM @tblOwnedObjs oo
	JOIN @tblRefs r ON r.ObjId = oo.ObjId
	JOIN MoAffixForm_InflectionClasses maic ON maic.Src = r.RefObjID AND maic.Dst = r.ObjId

	IF @@ROWCOUNT != 1
		EXEC tsu_Failure 'MoAffixForm_InflectionClasses.Dst doesn''t refer to objects owned by nouns.'

END
GO

---------------------------------------------------------------------

/***********************************************************************************************
 *	Suite: ReplaceRefs
 *
 *	Dependencies:
 *		Uses
 **********************************************************************************************/

IF OBJECT_ID('ut_ReplaceRef_ReplaceRefColl') IS NOT NULL BEGIN
	DROP PROCEDURE ut_ReplaceRef_ReplaceRefColl
END
GO
CREATE PROCEDURE ut_ReplaceRef_ReplaceRefColl AS
BEGIN
	DECLARE
		@nObjId INT,
		@nRefId INT,
		@nFieldId INT,
		@hInsObj INT,
		@vcIds VARCHAR(100),
		@nDummyId INT

	SELECT @nObjId = Obj FROM CmPossibility_Name WHERE Txt = 'noun'
	IF @@ROWCOUNT != 1
		EXEC tsu_failure 'Can''t find "noun" The database has changed.'

	SELECT @nRefId = Obj FROM CmPossibility_Name WHERE Txt = 'D. Livingston'
	IF @@ROWCOUNT != 1
		EXEC tsu_failure 'Can''t find "D. Livingston" The database has changed.'

	SELECT @nFieldId = f.Id
		FROM Field$ f
		JOIN Class$ c ON c.Id = f.Class AND c.Name = 'CmPossibility'
		WHERE f.Name = 'Researchers'

	IF @@ROWCOUNT != 1
		EXEC tsu_failure 'Can''t Researchers possibility.'

	--( This should attach a researcher to the noun possibility.

	SET @vcIds = CONVERT(VARCHAR(10), @nRefId)
	EXEC ReplaceRefColl$ @nFieldId, @nObjId, @vcIds, NULL

	SELECT @nDummyId = Src
		FROM CmPossibility_Researchers
		WHERE Src = @nObjId AND Dst = @nRefId

	IF @@ROWCOUNT != 1
		EXEC tsu_failure 'Can''t find researcher for reference collection'
END
GO

---------------------------------------------------------------------

/***********************************************************************************************
 *	Suite: Class$Trigger, tests on the Class$ table triggers
 *
 *	Dependencies:
 *		Uses UpdateClassView$
 *		TODO: There are more dependencies than this.
 **********************************************************************************************/

IF OBJECT_ID('ut_Class$Trigger_UpdateClassView') IS NOT NULL BEGIN
	DROP PROCEDURE [ut_Class$Trigger_UpdateClassView]
END
GO
CREATE PROCEDURE [ut_Class$Trigger_UpdateClassView] AS
BEGIN
	DECLARE
		@PossId INT,
		@UpdateSubclasses TINYINT,
		@ViewCodeCount INT,
		@ClassId INT;

	--(	The CmLocation table has only the ID field. The CmLocation class
	--( does have an attribute Alias, but this is a Unicode field, and gets
	--( stored off in the database in table CmLocation_Alias. Therefore, the
	--( view CmLocation_ doesn't have any more fields than its parent class
	--( view CmPossibility_.

	SELECT @ClassId = Id FROM Class$ WHERE Name = N'CmLocation';
	IF @@ROWCOUNT != 1
		EXEC tsu_failure 'Can''t find "CmLocation" The database has changed.';
	SET @UpdateSubclasses = 0;

	EXEC UpdateClassView$ @ClassId, @UpdateSubclasses;

	SELECT @ViewCodeCount = COUNT(*)
	FROM sys.sql_modules
	WHERE object_id = OBJECT_ID('CmLocation_')
		AND definition LIKE N'%CmPossibility_%'
		AND definition LIKE N'%CmLocation%'
		AND definition LIKE N'%[Id]%'

	IF @ViewCodeCount != 1
		EXEC tsu_failure 'The view code for CmLocation_ is inaccurate in sys.sql_modules.';

	--( Now check for CmPossibility

	SELECT @ClassId = Id FROM Class$ WHERE Name = N'CmPossibility';
	IF @@ROWCOUNT != 1
		EXEC tsu_failure 'Can''t find "CmPossibility" The database has changed.';
	SET @UpdateSubclasses = 0;

	EXEC UpdateClassView$ @ClassId, @UpdateSubclasses;

	SELECT @ViewCodeCount = COUNT(*)
	FROM sys.sql_modules
	WHERE object_id = OBJECT_ID('CmPossibility_')
		AND definition LIKE N'%CmObject_%'
		AND definition LIKE N'%SortSpec%'

	IF @ViewCodeCount != 1
		EXEC tsu_failure 'The view code for CmPossibility_ is inaccurate in sys.sql_modules.';

END
GO

---------------------------------------------------------------------

/***********************************************************************************************
 *	Suite: Field$Trigger, tests on the Field$ table triggers
 *
 *	Dependencies:
 *		Uses AddCustomField$
 **********************************************************************************************/

--( Adding an owning atomic StText field requires all existing instances of the owning class
--( to possess an empty StText and StTxtPara.

IF OBJECT_ID('ut_Field$Trigger_InsertCreateStTxt') IS NOT NULL BEGIN
	DROP PROCEDURE [ut_Field$Trigger_InsertCreateStTxt]
END
GO
CREATE PROCEDURE [ut_Field$Trigger_InsertCreateStTxt] AS
BEGIN
	DECLARE
		@nFieldId INT,
		@nClassId INT,
		@nCountGenericRecord INT,
		@nCountStText INT,
		@nCountStTxtPara INT


	SELECT @nCountGenericRecord = COUNT(*) FROM RnGenericRec

	SELECT @nClassId = [Id] FROM Class$ WHERE [Name] = 'RnGenericRec'
	SET @nFieldId = NULL

	--( Create a new custom field, which triggers the Field$ instert trigger

	EXEC AddCustomField$ @nFieldId OUTPUT, 'custom', 23, @nClassid, 14, NULL, NULL, NULL

	--( Check for StText Records

	SELECT @nCountStText = COUNT(*)
	FROM StText t
	JOIN CmObject o ON o.[id] = t.[Id] AND o.OwnFlid$ = @nFieldId

	IF @nCountGenericRecord != @nCountStText
		EXEC tsu_failure 'Field$ insert trigger failed to create appropriate StText records'

	--( See if StTxtPara records got created for each StText record.

	SELECT @nCountStTxtPara = COUNT(tp.[Id])
	FROM StTxtPara tp
	JOIN CmObject tpbase ON tpbase.[Id] = tp.[Id]
	JOIN StText t ON t.[Id] = tpbase.Owner$
	JOIN CmObject tbase ON tbase.[id] = t.[Id] AND tbase.OwnFlid$ = @nFieldId

	IF @nCountStTxtPara != @nCountStText
		EXEC tsu_failure 'Field$ insert trigger failed to create appropriate StTxtPara records'

END
GO

------------------------------------------------------------------------------------------------

IF OBJECT_ID('ut_Field$Trigger_Delete') IS NOT NULL BEGIN
	DROP PROCEDURE [ut_Field$Trigger_Delete]
END
GO
CREATE PROCEDURE [ut_Field$Trigger_Delete] AS
BEGIN
	--( We're testing this because the delete trigger was not
	--( dropping the check constraint associated with integers that
	--( have a Min not null and Max not null. No other numeric
	--( types have this particular constraint. (I don't know why.)

	DECLARE @FieldId INT;
	SELECT @FieldId = Id FROM Field$ WHERE Name = 'UnderStyle';

	DELETE FROM Field$ WHERE Id = @FieldId;

	--( The whole unit test will blow up at this point if the trigger is not
	--( working properly. Don't know how else to test it.
END
GO

------------------------------------------------------------------------------------------------

-- IF OBJECT_ID('ut_Field$Trigger_No_Upd') IS NOT NULL BEGIN
-- 	DROP PROCEDURE [ut_Field$Trigger_No_Upd]
-- END
-- GO
-- CREATE PROCEDURE [ut_Field$Trigger_No_Upd] AS

--( I'm stumped how to create a unit test for this. An error is raised by the trigger, and
--( I don't know to trap it from within a stored procedure like this one. It can be tested by
--( hand, though. The following commands should raise the error, meaning the trigger worked
--( as required.
--(
--( update field$ set type = 5 where id = 1001 -- should error out
--( update field$ set ListRootId = null where [id] = 1001 -- should not error out
--(
--( A lot of the fields have constraints already, which make the odds of hitting this trigger
--( small, and which make testing hard.

/***********************************************************************************************
 *	Suite: LogInfo$
 *
 *	Dependencies:
 *		None
 *
 *	Notes:
 *		I don't have a good idea how to test most of this, other than build in the same logic
 *		that we have in the actual stored procedure.
 **********************************************************************************************/


IF OBJECT_ID('ut_LogInfo$_TestLangProjInfo') IS NOT NULL BEGIN
	DROP PROCEDURE [ut_LogInfo$_TestLangProjInfo]
END
GO
CREATE PROCEDURE ut_LogInfo$_TestLangProjInfo
AS
BEGIN
	DECLARE
		@nLogFileSizeTest INT,
		@bnLogFileMaxSizeTest BIGINT,
		@rLogUsedPercentTest REAL,
		@nSpaceAvailForLogFileTest INT

	DECLARE
		@ncLogFileName NCHAR(260),
		@nLogFileSize INT,
		@nLogFileSpaceUsed INT,
		@bnLogFileMaxSize BIGINT,
		@nSpaceAvailForLogFile INT

	--== Execute ==--

	EXEC LogInfo$
		@ncLogFileName OUTPUT,
		@nLogFileSize OUTPUT,
		@nLogFileSpaceUsed OUTPUT,
		@bnLogFileMaxSize OUTPUT,
		@nSpaceAvailForLogFile OUTPUT

	--== Tests ==--

	CREATE TABLE #fixeddrives (drive CHAR(1) PRIMARY KEY, mbfree INTEGER NOT NULL)
	--( xp_fixeddrives is not documented by MS, but it is quite a bit on the web. See, for example,
	--( http://www.mssqlcity.com/FAQ/Devel/get_list_of_drives.htm
	INSERT INTO #fixeddrives EXEC master..xp_fixeddrives
	SELECT @nSpaceAvailForLogFileTest = mbfree FROM #fixeddrives WHERE drive = LEFT(@ncLogFileName, 1)
	DROP TABLE #fixeddrives
	--( xp_fixeddrives expresses space in Mb. We want it in Kb
	SET @nSpaceAvailForLogFileTest = @nSpaceAvailForLogFileTest * 1024

	--( We have a create temp table after this, but there's no helping it.

	SELECT
		@nLogFileSizeTest = [size],
		@bnLogFileMaxSizeTest = [maxsize]
	FROM sysfiles
	WHERE ([status] & 0x40) <> 0 -- status of 0x40 indicates the log file

	--( SQL Server returns the size of the file in 8-KB pages. We want it in KB. The conversion
	--( factor is 8.

	SET @nLogFileSizeTest = @nLogFileSizeTest * 8
	IF @nLogFileSize != @nLogFileSizeTest
		EXEC tsu_failure 'Failed to convert Log File size to KB'

	--( SQL Server returns the max size of the file in 8-KB pages. We want it in KB. The conversion
	--( factor 8. The value of maxsize could also be 0 (no growth) or -1 (grow until disk full).
	IF @bnLogFileMaxSizeTest > 0
		SET @bnLogFileMaxSizeTest = @bnLogFileMaxSizeTest * 8

	IF @bnLogFileMaxSize != @bnLogFileMaxSizeTest
		EXEC tsu_failure 'Failed to convert Log File max size to KB'

	--( SQL Server returns space used as a percentage.

--( Removed the following test as it appears to be unreliable. The following had worked
--( for some time, but today failed. (9 Dec 2003)
--
-- 	CREATE TABLE #LogInfo (DbName NVARCHAR(128), LogSize REAL, LogUsed REAL, Status TINYINT)
-- 	INSERT INTO #LogInfo EXEC ('DBCC SQLPERF (LOGSPACE)')
-- 	SELECT @rLogUsedPercentTest = LogUsed FROM #LogInfo WHERE [DbName] = DB_NAME()
-- 	DROP TABLE #LogInfo
--
-- 	IF @nLogFileSpaceUsed != ROUND(@nLogFileSize * (@rLogUsedPercentTest / 100), 0) BEGIN
-- 		SELECT
-- 			@nLogFileSpaceUsed AS ExecLogSpaceUsed,
-- 			ROUND(@nLogFileSize * (@rLogUsedPercentTest / 100), 0) AS TestLogSpaceUsed

		--(   When LogInfo$ executes, it uses a temp table, in the same manner as a
		--( temp table is used above. This will create a very small change in the
		--( size of the log file. The change will be insignificant, and
		--( this test will pass. However the possibility still exists where the test
		--( will fail, even though the stored proc is correct. If that happens,
		--( executing the test again may cause it to pass, or we might want to write
		--( in a fudge factor.
		--(   We could use a table variable to avoid this, because table variables
		--( do not affect the log file. However, if you try a table variable, SQL
		--( Server will give an error "EXECUTE cannot be used as a source when
		--( inserting into a table variable."

--  		EXEC tsu_failure 'Failed to convert Log File space used to KB'
-- 	END

	--( Max size tests

	IF @bnLogFileMaxSizeTest = -1 BEGIN
		SET @nSpaceAvailForLogFileTest = @nSpaceAvailForLogFileTest + (@nLogFileSize - @nLogFileSpaceUsed)
		IF @nSpaceAvailForLogFileTest != @nSpaceAvailForLogFile
			EXEC tsu_failure 'Failed to calc space available for log file correctly with -1'
	END
	ELSE IF @bnLogFileMaxSizeTest = 0 BEGIN
		SET @nSpaceAvailForLogFileTest = @nLogFileSizeTest - @nLogFileSpaceUsed
		IF @nSpaceAvailForLogFileTest != @nSpaceAvailForLogFile
			EXEC tsu_failure 'Failed to calc space available for log file correctly with 0'
	END
	ELSE BEGIN
		SET @nSpaceAvailForLogFileTest = @bnLogFileMaxSizeTest  - @nLogFileSpaceUsed
		IF @nSpaceAvailForLogFileTest != @nSpaceAvailForLogFile
			EXEC tsu_failure 'Failed to calc space available for log file correctly with max file size set'
	END

END
GO

/***********************************************************************************************
 *	Suite: CopyObj$
 *
 *	Notes:
 *	------
 *	The purpose of this procedure is to copy any object. The tests have to check for three
 *	types of copy:
 *
 *		1. Different data types were copied correctly. For instance, an int from the source
 *			object should copy correctly to the new object.
 *		2. Owned objects should be duplicated.
 *		3. References
 *			a. References sometimes point to themselves. For instance, the People list has a
 *				researcher that points back to the People list. For copies, this reference back
 *				to itself needs to have the new object, not the old source object.
 *			b. For all other reference properties, we need simply to point to the old object.
 *
 *	Not all field types will be tested in all the following tests. The tests ut_CopyObj$_RnEvent
 *	and ut_CopyObj$_UserView have the following tests:
 *
 *	Field Types tested:
 *		Field Type 1, kcptBoolean: UserView.System
 *		Field Type 2, kcptInteger: UserView.Type
 *		Field Type 3, kcptNumeric: *not used*
 *		Field Type 4, kcptFloat: *not used*
 *		Field Type 5, kcptTime: RnEvent.DateCreated
 *		Field Type 6, kcptGuid: UserView.App
 *		Field Type 8, kcptGenDate: RnGenericRec.DateOfEvent
 *		Field Type 9, kcptBinary: UserView.Details
 *		Field Type 13, kcptString: RnEvent.Title and Title_Fmt (both make up the type)
 *		Field Type 16, kcptMultiUnicode: UserView.Name, in MultiTxt$
 *		Field Type 24, kcptReferenceAtom: RnEvent.Confidence (the reference is checked elsewhere.)
 *
 *	"External", referenced objects don't get duplicated, they just get referred
 *	to by the new, copied object(s). "Internal" references, which are references objects
 *	within the new tree, must refer to new objects
 **********************************************************************************************/

IF OBJECT_ID('ut_CopyObj$_NoMultiBigTxt') IS NOT NULL BEGIN
	DROP PROCEDURE [ut_CopyObj$_NoMultiBigTxt]
END
GO
CREATE PROCEDURE ut_CopyObj$_NoMultiBigTxt AS
BEGIN
	--( In CmTypes.h, the constant kcptMultiBigUnicode is for MultiBigTxt.
	SELECT * FROM Field$ WHERE [Type] = 20
	IF @@ROWCOUNT != 0
		EXEC tsu_failure 'MultiBigTxt is not yet implemented, per YAGNI.'
END

GO

---------------------------------------------------------------------
IF OBJECT_ID('ut_CopyObj$_CopyPossList') IS NOT NULL BEGIN
	DROP PROCEDURE [ut_CopyObj$_CopyPossList]
END
GO
CREATE PROCEDURE ut_CopyObj$_CopyPossList AS
BEGIN
	DECLARE
		@nSourceObjId int,
		@nNewObjId int,
		@nReturn int,
		@nRowCount INT,
		@dtDateModifiedSource DATETIME,
		@dtDateModifiedDest DATETIME

	SELECT @nSourceObjID = [Obj]
	FROM CmMajorObject_Name
	WHERE [Txt] = 'Confidence Levels'

	IF @@ROWCOUNT != 1
		EXEC tsu_failure 'Confidence Levels no longer exists in database'

	SET @nNewObjId = -1  --( To make sure this is different

	EXEC @nReturn = CopyObj$ @nSourceObjId, NULL, NULL, NULL, @nNewObjId output

	--( The select statement has to come before the tsu_failure, so we
	--( execute it here. The else below makes use of the test.
	--( The query assumes a clean database, where no user has copied a list yet.

	SELECT [txt]
	FROM CmMajorObject_Name
	WHERE [obj] = @nNewObjID
		AND [Txt] = 'Confidence Levels'

	SET @nRowCount = @@ROWCOUNT

	SELECT @dtDateModifiedSource = [DateModified] FROM CmMajorObject WHERE [Id] = @nSourceObjID
	SELECT @dtDateModifiedDest = [DateModified] FROM CmMajorObject WHERE [Id] = @nNewObjId

	IF @nNewObjId IS NULL
		EXEC tsu_failure 'Can''t have a null New object id'
	ELSE IF @nRowCount = 0
		EXEC tsu_failure 'Couldn''t find newly copied list name in CmMajorObject_Name'
	ELSE IF @dtDateModifiedSource = @dtDateModifiedDest
		EXEC tsu_failure 'CmMajorObject.DateModified not updated'

END
GO

---------------------------------------------------------------------
IF OBJECT_ID('ut_CopyObj$_CopyPossListRef2CopiedObj') IS NOT NULL BEGIN
	DROP PROCEDURE [ut_CopyObj$_CopyPossListRef2CopiedObj]
END
GO

--( This copy possibility list test tests reference copying. When
--( an object owns other objects, the owned objects get copied.
--( Referenced objects don't get copied. However, a referenced
--( object might be part of the ownership tree that gets copied.
--( In that case, we want to reference the newly copied object,
--( not the source object. For example, the People possibility
--( list owns CmPerson items. CmPerson is subclassed from
--( CmPossibility, which has a reference to Researchers.
--( Researchers is the very same People possibility list we're
--( copying. Therefore, CmPerson can point to itself as a
--( reference. (Clear as mud?)

CREATE PROCEDURE ut_CopyObj$_CopyPossListRef2CopiedObj AS
BEGIN

	--== Setup ==--

	DECLARE
		@nSourceObjId int,
		@nDestinationObjId INT,
		@nNewObjId int,
		@nReturn int,
		@nRowCount INT,
		@dtDateModifiedSource DATETIME,
		@dtDateModifiedDest DATETIME,
		@nvcTxt NVARCHAR(13)

	SELECT @nSourceObjID = [Obj]
	FROM CmPossibility_Name
	WHERE [Txt] = 'D. Livingston'

	IF @@ROWCOUNT != 1
		EXEC tsu_failure 'D. Livingston no longer exists in database'

	--( The reference to itself does not exist in the current TestLangProj.
	--( We'll see about this one anyway. If it's not there, we'll create it
	--( for the test.

	SELECT * FROM CmPossibility_Researchers WHERE [Src] = @nSourceObjID AND [Dst] = @nSourceObjID

	IF @@ROWCOUNT != 1
		INSERT INTO CmPossibility_Researchers VALUES (@nSourceObjID, @nSourceObjID)

	--== Execute ==--

	SET @nNewObjId = -1  --( To make sure this is different
	EXEC @nReturn = CopyObj$ @nSourceObjId, NULL, NULL, NULL, @nNewObjId output

	--== Tests ==--

	--( The only test we're concerned here with copying possibility lists is
	--( getting the references right. The rest go into ut_CopyObj$_CopyPossList.

	SELECT * FROM CmPossibility_Researchers WHERE [Src] = @nNewObjId AND [Dst] = @nNewObjId

	IF @@ROWCOUNT != 1
		EXEC tsu_failure 'The CmPossibility_Researchers reference didn''t get copied right.'

END
GO

---------------------------------------------------------------------
IF OBJECT_ID('ut_CopyObj$_RnEvent') IS NOT NULL BEGIN
	DROP PROCEDURE [ut_CopyObj$_RnEvent]
END
GO
CREATE PROCEDURE ut_CopyObj$_RnEvent AS
BEGIN
	DECLARE
		@nRnEventId INT,
		@nNewObjId INT,
		@nReturn INT,
		@nCount INT,
		@nId INT

	--( Going for event "Wedding of the son of the main hunter to
	--( the chief's daughter". The Description is, "Contains
	--( information on the preparation, ceremony,..."

	SELECT @nRnEventID = eventbase.[Id]
	FROM CmObject eventbase
	JOIN CmObject txtbase ON txtbase.Owner$ = eventbase.[Id]
	JOIN CmObject txtparabase ON txtparabase.Owner$ = txtbase.[Id]
	JOIN StTxtPara tp ON tp.[Id] = txtparabase.[Id]
		AND tp.Contents LIKE 'Contains information%'

	IF @nRnEventID IS NULL --( if more than 1 record, the test will crash
		EXEC tsu_failure 'TestLangProj data has changed'

	/*== Create the copy ==*/

	SET @nNewObjId = -1
	EXEC @nReturn = CopyObj$ @nRnEventId, NULL, NULL, NULL, @nNewObjId output

	IF @nNewObjId = -1 OR @nNewObjId IS NULL --( the new ID wasn't created
		EXEC tsu_failure 'CopyObj$ didn''t create a new ID'

	/*== Examine results ==*/

	--( RnGenericRec, a base of RnEvent )--

	SELECT @nCount = COUNT([Id]) FROM RnGenericRec WHERE [Id] = @nNewObjId
	IF @nCount != 1
		EXEC tsu_failure 'RnGenericRec is wrong'

	SELECT @nCount = COUNT(rg1.[Id])
	FROM RnGenericRec rg1
	JOIN RnGenericRec rg2 ON
		rg2.Title = rg1.Title AND
		rg2.Title_Fmt = rg1.Title_Fmt AND
		rg2.Confidence = rg1.Confidence
	WHERE rg1.[Id] = @nRnEventId AND rg2.[Id] = @nNewObjId

	IF @nCount != 1
		EXEC tsu_failure 'New RnGenericRec Title, Title_Fmt, or Confidence doesn''t agree with Source RnGenericRec'

	SELECT @nCount = COUNT(Id)
	FROM RnGenericRec
	WHERE [Id] = @nNewObjId AND DATEDIFF(day, DateCreated, GETDATE()) != 0

	IF @nCount != 0
		EXEC tsu_failure 'DateCreated does''nt have today''s date'

	SELECT @nCount = COUNT(Id)
	FROM RnGenericRec
	WHERE [Id] = @nNewObjId AND DATEDIFF(day, DateModified, GETDATE()) != 0

	IF @nCount != 0
		EXEC tsu_failure 'DateModified does''nt have today''s date'

	--( RnEvent )--

	SELECT @nCount = COUNT([Id]) FROM RnEvent WHERE [Id] = @nNewObjId
	IF @nCount != 1
		EXEC tsu_failure 'RnEvent is wrong'

	SELECT @nCount = COUNT(e1.[Id])
	FROM RnEvent e1
	JOIN RnEvent e2 ON e2.Type = e1.Type AND e2.DateOfEvent = e1.DateOfEvent
	WHERE e1.[Id] = @nRnEventId AND e2.[Id] = @nNewObjId

	IF @nCount != 1
		EXEC tsu_failure 'New RnEvent Type or DateOfEvent doesn''t agree with Source RnEvent'

	--== RnGenericRec Relationships ==--

	--( RnGenericRec.VersionHistory: owning atomic. It should own an StText, which in turn
	--( owns a StTxtPara

	SELECT @nCount = COUNT([Id]) FROM CmObject WHERE Owner$ = @nNewObjId AND OwnFlid$ = 4004002
	IF @@ROWCOUNT != 1
		EXEC tsu_failure 'VersionHistory is wrong'

	SELECT @nId = [Id] FROM CmObject WHERE Owner$ = @nNewObjId AND OwnFlid$ = 4004002 --( StText record

	SELECT @nCount = COUNT([Id]) FROM StText WHERE [Id] = @nId
	IF @nCount != 1
		EXEC tsu_failure 'StText owned by VersionHistory is wrong'

	SELECT @nId = [Id] FROM CmObject WHERE Owner$ = @nId --( StTxtPara record

	SELECT @nCount = COUNT([Id]) FROM StTxtPara WHERE [Id] = @nId
	IF @nCount != 1
		EXEC tsu_failure 'StTxtPara owned by VersionHistory via StText is wrong'

	--( RnGenericRec.Reminders: reference collection. No Reminders here; nothing much to check

	SELECT @nCount = COUNT(Src) FROM RnGenericRec_Reminders WHERE Src = @nNewObjId --( 4004003
	IF @nCount != 0
		EXEC tsu_failure 'Reminders is wrong'

	--( RnGenericRec.Researchers: reference collection. It references a CmPerson

	SELECT @nCount = COUNT(Src) FROM RnGenericRec_Researchers WHERE Src = @nNewObjId --( 4004004
	IF @nCount != 1
		EXEC tsu_failure 'Researchers is wrong'

	SELECT @nId = Dst FROM RnGenericRec_Researchers WHERE Src = @nNewObjId

	--( RnGenericRec.Confidence: reference atomic. (flid 4004005) The Confidence field exists
	--( directly in the RnGenericRec record.

	SELECT @nId = Confidence FROM RnGenericRec WHERE [Id] = @nNewObjId

	SELECT @nCount = COUNT([Id]) FROM CmPossibility WHERE [Id] = @nId
	IF @nCount != 1
		EXEC tsu_failure 'CmPossibility for RnGenericRec.Confidence reference is missing'

	--( RnGenericRec.Restrictions: reference collection

	SELECT @nCount = COUNT(Src) FROM RnGenericRec_Restrictions WHERE Src = @nNewObjId --( 4004006
	IF @nCount != 0
		EXEC tsu_failure 'Restrictions is wrong'

	--( RnGenericRec.AnthroCodes: reference collection
	SELECT @nCount = COUNT(Src) FROM RnGenericRec_AnthroCodes WHERE Src = @nNewObjId --( 4004007
	IF @nCount != 3
		EXEC tsu_failure 'AnthroCodes is wrong'

	SELECT @nCount = COUNT([Id])
	FROM CmAnthroItem
	WHERE [Id] IN (SELECT [Dst] FROM RnGenericRec_AnthroCodes WHERE Src = @nNewObjId)

	IF @nCount != 3
		EXEC tsu_failure 'CmAnthroItems for RnGenericRec_AnthroCodes references are missing'

	--( RnGenericRec.PhraseTags: reference collection

	SELECT @nCount = COUNT(Src) FROM RnGenericRec_PhraseTags WHERE Src = @nNewObjId --( 4004008
	IF @nCount != 0
		EXEC tsu_failure 'PhraseTags is wrong'

	--( SubRecords: owning sequence. This will be one of the most intense workouts the stored
	--( procedure will get in copying owned objects.

	SELECT @nCount = COUNT([Id]) FROM CmObject WHERE Owner$ = @nNewObjId AND OwnFlid$ = 4004009
	IF @nCount != 5
		EXEC tsu_failure 'SubRecords number is wrong'

	SELECT @nCount = COUNT([Id])
	FROM RnGenericRec
	WHERE [Id] IN (SELECT [Id] FROM CmObject WHERE Owner$ = @nNewObjId AND OwnFlid$ = 4004009)

	IF @nCount != 5
		EXEC tsu_failure 'RnGenericRecs base for Subrecords number is wrong'

	SELECT @nCount = COUNT([Id])
	FROM RnEvent
	WHERE [Id] IN (SELECT [Id] FROM CmObject WHERE Owner$ = @nNewObjId AND OwnFlid$ = 4004009)

	IF @nCount != 4
		EXEC tsu_failure 'RnEvents owned by Subrecords number is wrong'

	SELECT @nCount = COUNT([Id])
	FROM RnAnalysis
	WHERE [Id] IN (SELECT [Id] FROM CmObject WHERE Owner$ = @nNewObjId AND OwnFlid$ = 4004009)

	IF @nCount != 1
		EXEC tsu_failure 'RnAnalysis owned by Subrecords number is wrong'

	SELECT @nCount = COUNT([Id])
	FROM CmObject
	WHERE [Owner$] IN (SELECT [Id] FROM CmObject WHERE Owner$ = @nNewObjId AND OwnFlid$ = 4004009)

	IF @nCount != 35 --( objects owned by 4 RnEvents and 1 RnAnalysis
		EXEC tsu_failure 'Objects owned by SubRecords is wrong'

	--( RnGenericRec.CrossReferences: reference collection
	SELECT @nCount = COUNT(Src) FROM RnGenericRec_CrossReferences WHERE Src = @nNewObjId --( 4004012
	IF @nCount != 0
		EXEC tsu_failure 'CrossReferences is wrong'

	--( External Materials: owning atomic
	SELECT @nCount = COUNT([Id]) FROM CmObject WHERE Owner$ = @nNewObjId AND OwnFlid$ = 4004013
	IF @nCount != 1
		EXEC tsu_failure 'ExternalMaterials is wrong'

	--( Further Questions: owning atomic
	SELECT @nCount = COUNT([Id]) FROM CmObject WHERE Owner$ = @nNewObjId AND OwnFlid$ = 4004014
	IF @nCount != 1
		EXEC tsu_failure 'FurtherQuestions is wrong'

	--( RnGenericRec.SeeAlso: reference collection
	SELECT @nCount = COUNT(Src) FROM RnGenericRec_SeeAlso WHERE Src = @nNewObjId --( 4004015
	IF @nCount != 0
		EXEC tsu_failure 'SeeAlso is wrong'

	--== RnEvent Relationships ==--

	--( RnEvent.Description: owning atomic
	SELECT @nCount = COUNT([Id]) FROM CmObject WHERE Owner$ = @nNewObjId AND OwnFlid$ = 4006001
	IF @nCount != 1
		EXEC tsu_failure 'Description is wrong'

	--( RnEvent.Participants: owning collection
	SELECT @nCount = COUNT([Id]) FROM CmObject WHERE Owner$ = @nNewObjId AND OwnFlid$ = 4006002
	IF @nCount != 4
		EXEC tsu_failure 'Participants is wrong'

	--( RnEvent.Locations: reference collection
	SELECT @nCount = COUNT(Src) FROM RnEvent_Locations WHERE Src = @nNewObjId --( 4006003
	IF @nCount != 1
		EXEC tsu_failure 'Locations is wrong'

	--( RnEvent.Type: reference atomic. (flid 4006004) The value exists
	--( directly in the RnEvent record.

	--( RnEvent.Weather: reference collection
	SELECT @nCount = COUNT(Src) FROM RnEvent_Weather WHERE Src = @nNewObjId --( 4006006
	IF @nCount != 1
		EXEC tsu_failure 'Weather is wrong'

	--( RnEvent.Sources: reference collection
	SELECT @nCount = COUNT(Src) FROM RnEvent_Sources WHERE Src = @nNewObjId --( 4006007
	IF @nCount != 1
		EXEC tsu_failure 'Sources is wrong'

	--( RnEvent.TimeOfEvent: reference collection
	SELECT @nCount = COUNT(Src) FROM RnEvent_TimeOfEvent WHERE Src = @nNewObjId --( 4006009
	IF @nCount != 1
		EXEC tsu_failure 'TimeOfEvent is wrong'

	SELECT @nCount = COUNT([Id]) FROM CmObject WHERE Owner$ = @nNewObjId AND OwnFlid$ = 4006010
	IF @nCount != 1
		EXEC tsu_failure 'Personal Notes is wrong'

END
GO

---------------------------------------------------------------------
IF OBJECT_ID('ut_CopyObj$_UserView') IS NOT NULL BEGIN
	DROP PROCEDURE [ut_CopyObj$_UserView]
END
GO
CREATE PROCEDURE ut_CopyObj$_UserView AS
BEGIN
	DECLARE
		@nUserViewId INT,
		@nNewObjId INT,
		@nReturn INT,
		@nCount INT

	SELECT @nUserViewId = Obj
	FROM UserView_Name uvn
	JOIN UserView uv ON uv.[Id] = uvn.Obj
	WHERE uvn.Txt = 'Browse'

	IF @nUserViewId IS NULL --( if more than 1 record, the test will crash
		EXEC tsu_failure 'TestLangProj data has changed'

	/*== Create the copy ==*/

	SET @nNewObjId = -1
	EXEC @nReturn = CopyObj$ @nUserViewId, NULL, NULL, NULL, @nNewObjId output

	IF @nNewObjId = -1 OR @nNewObjId IS NULL --( the new ID wasn't created
		EXEC tsu_failure 'CopyObj$ didn''t create a new ID'

	/*== Examine results ==*/

	SELECT @nCount = COUNT(uv1.[Id])
	FROM UserView uv1
	JOIN UserView uv2 ON
		uv2.Type = uv1.Type AND
		uv2.App = uv1.App AND
		uv2.[System] = uv1.[System] AND
		uv2.SubType = uv1.SubType
	WHERE uv1.[Id] = @nUserViewId AND uv2.[Id] = @nNewObjId

	IF @nCount != 1
		EXEC tsu_failure 'New UserView record doesn''t match'

	--( The stored procedure appended a Roman numeral with parens at the end
	--( of the new text in MultiTxt$. For instance, "Browse" becomes "Browse (2)".
	--( This has changed a couple of times, and may change again.

	SELECT @nCount = COUNT(mt.Obj) FROM UserView_Name mt WHERE Obj = @nNewObjId

	IF @nCount != 1
		EXEC tsu_failure 'New UserView Name is wrong'

END
GO

---------------------------------------------------------------------
IF OBJECT_ID('ut_CopyObj$_ScrBook') IS NOT NULL BEGIN
	DROP PROCEDURE [ut_CopyObj$_ScrBook]
END
GO
CREATE PROCEDURE ut_CopyObj$_ScrBook AS
BEGIN
	DECLARE
		@nScrBookId INT,
		@nNewObjId INT,
		@nOwnerObjId INT,
		@nOwnerFlid INT,
		@nReturn INT,
		@nCount INT,
		@nPrevMaxOwnOrd INT

	SELECT @nScrBookId = Obj
	FROM ScrBook_Name sbn
	WHERE sbn.Txt = 'Philemon'

	SELECT @nOwnerObjId = Owner$, @nOwnerFlid = OwnFlid$
	FROM CmObject
	WHERE [Id] = @nScrBookId

	SELECT @nPrevMaxOwnOrd = MAX(OwnOrd$)
	FROM ScrBook_
	WHERE Owner$ = @nOwnerObjId

	IF @@ROWCOUNT != 1
		EXEC tsu_failure 'TestLangProj data has changed'

	SET @nNewObjId = -1
	EXEC @nReturn = CopyObj$ @nScrBookId, @nOwnerObjId, @nOwnerFlid, NULL, @nNewObjId output

	SELECT @nCount = COUNT(*)
	FROM ScrBook_Name sbn
	WHERE sbn.Obj = @nNewObjId AND sbn.Txt = 'Philemon'

	IF @nCount != 1
		EXEC tsu_failure 'Philemon didn''t get copied'

	SELECT @nCount = COUNT(*)
	FROM ScrBook_
	WHERE [id] = @nNewObjId AND OwnOrd$ = @nPrevMaxOwnOrd + 1

	IF @nCount != 1
		EXEC tsu_failure 'Philemon got copied to the wrong place in the list'
END
GO

---------------------------------------------------------------------

IF OBJECT_ID('ut_CopyObj$_ScrBookInsertBeforeJude') IS NOT NULL BEGIN
	DROP PROCEDURE ut_CopyObj$_ScrBookInsertBeforeJude
END
GO

CREATE PROCEDURE ut_CopyObj$_ScrBookInsertBeforeJude AS
BEGIN
	DECLARE
		@nScrBookIdPhm INT,
		@nScrBookIdJude INT,
		@nNewObjId INT,
		@nOwnerObjId INT,
		@nOwnerFlid INT,
		@nReturn INT,
		@nCount INT,
		@nPrevJudeOwnOrd INT

	SELECT @nScrBookIdPhm = [Id], @nOwnerObjId = Owner$, @nOwnerFlid = OwnFlid$
	FROM ScrBook_
	WHERE CanonicalNum = 57

	SELECT @nScrBookIdJude = [Id], @nPrevJudeOwnOrd = OwnOrd$
	FROM ScrBook_
	WHERE CanonicalNum = 65

	IF @@ROWCOUNT != 1
		EXEC tsu_failure 'TestLangProj data has changed'

	SET @nNewObjId = -1
	EXEC @nReturn = CopyObj$ @nScrBookIdPhm, @nOwnerObjId, @nOwnerFlid, @nScrBookIdJude, @nNewObjId output

	SELECT @nCount = COUNT(*)
	FROM ScrBook_Name sbn
	WHERE sbn.Obj = @nNewObjId AND sbn.Txt = 'Philemon'

	IF @nCount != 1
		EXEC tsu_failure 'Philemon didn''t get copied'

	SELECT @nCount = COUNT(*)
	FROM ScrBook_
	WHERE [id] = @nNewObjId AND OwnOrd$ = @nPrevJudeOwnOrd

	IF @nCount != 1
		EXEC tsu_failure 'Philemon got copied to the wrong place in the list'

	SELECT @nCount = COUNT(*)
	FROM ScrBook_
	WHERE [id] = @nScrBookIdJude AND OwnOrd$ = @nPrevJudeOwnOrd + 1

	IF @nCount != 1
		EXEC tsu_failure 'Jude did not have its OwnOrd$ updated to make room for the new copy of Philemon in the list'
END
GO


/***********************************************************************************************
 *	Suite: GetObj
 *
 *	Dependencies:
 *		None
 **********************************************************************************************/

IF OBJECT_ID('ut_GetObj_fnGetOwnedIds') IS NOT NULL BEGIN
	DROP PROCEDURE ut_GetObj_fnGetOwnedIds
END
GO
CREATE PROCEDURE ut_GetObj_fnGetOwnedIds AS
BEGIN
	DECLARE
		@nPartsOfSpeechId INT,
		@nDirect INT,
		@nFunc INT

	DECLARE @tblFunc TABLE (Id INT)
	DECLARE @tblDirect TABLE (Id INT)

	--( Get the Parts of Speech list Id
	SELECT @nPartsOfSpeechId = Id FROM CmObject WHERE OwnFlid$ = 6001005

	--( Now get the records directly, for comparison to the function.
	INSERT INTO @tblDirect
	SELECT Id
	FROM CmObject
	WHERE Owner$ = @nPartsOfSpeechId --AND OwnFlid$ = 8008

	INSERT INTO @tblDirect
	SELECT o2.Id
	FROM CmObject o
	JOIN CmObject o2 ON o2.Owner$ = o.Id AND o2.OwnFlid$ = 7004
	WHERE o.Owner$ = @nPartsOfSpeechId

	INSERT INTO @tblDirect
	SELECT o3.Id
	FROM CmObject o
	JOIN CmObject o2 ON o2.Owner$ = o.Id AND o2.OwnFlid$ = 7004
	JOIN CmObject o3 ON o3.Owner$ = o2.Id AND o3.OwnFlid$ = 7004
	WHERE o.Owner$ = @nPartsOfSpeechId

	SELECT @nDirect = COUNT(*) FROM @tblDirect

	--( Now get the records from the func we're testing.
	INSERT INTO @tblFunc
	SELECT Id FROM dbo.fnGetOwnedIds(@nPartsOfSpeechId, 8008, 7004)

	SELECT @nFunc = COUNT(*) FROM @tblFunc

	IF @nFunc != @nDirect
		EXEC tsu_failure 'The number of records are different'

	SELECT @nDirect = MIN(Id) FROM @tblDirect
	SELECT @nFunc = MIN(Id) FROM @tblFunc

	IF @nFunc != @nDirect
		EXEC tsu_failure 'The first ID is different'

	SELECT @nDirect = MAX(Id) FROM @tblDirect
	SELECT @nFunc = MAX(Id) FROM @tblFunc

	IF @nFunc != @nDirect
		EXEC tsu_failure 'The last ID is different'
END
GO

/***********************************************************************************************
 *	Suite: SetMultiTxt
 *
 *	Dependencies:
 *		None
 **********************************************************************************************/

IF OBJECT_ID('ut_SetMultiTxt_InsDel$') IS NOT NULL BEGIN
	DROP PROCEDURE [ut_SetMultiTxt_InsDel$]
END
GO
CREATE PROCEDURE ut_SetMultiTxt_InsDel$ AS
BEGIN
	DECLARE
		@nRowCount INT,
		@nFieldId INT,
		@nObj INT,
		@nWritingSys INT
	SET @nFieldId = 5062001 --( flid for WfiWordform_Form

	SELECT @nObj = Obj, @nWritingSys = Ws FROM WfiWordform_Form WHERE Txt = 'nihimbilira'
	IF @nRowCount != 1
		EXEC tsu_failure 'TestLangProj data has changed'

	EXEC SetMultiTxt$ @nFieldId, @nObj, @nWritingSys, null
	SELECT * FROM WfiWordform_Form WHERE Txt = 'nihimbilira'
	IF @nRowCount != 0
		EXEC tsu_failure 'The string removal portion didn''t work'

	EXEC SetMultiTxt$ @nFieldId, @nObj, @nWritingSys, 'nihimbilira'
	SELECT * FROM WfiWordform_Form WHERE Txt = 'nihimbilira'
	IF @nRowCount != 0
		EXEC tsu_failure 'The string insert didn''t work'
END
GO

/***********************************************************************************************
 *	Suite: Delete
 *
 *	Dependencies:
 *		Stored Procedure DeleteObjects depends on Delete triggers on all classes. These
 *		are built by running CreateDeleteObj
 **********************************************************************************************/

IF OBJECT_ID('ut_Delete_DeleteObjects') IS NOT NULL BEGIN
	DROP PROCEDURE ut_Delete_DeleteObjects
END
GO
CREATE PROCEDURE ut_Delete_DeleteObjects AS
BEGIN
	DECLARE
		@nObjId INT,
		@sObjId NVARCHAR(10)

	DECLARE @tblOwnedObjects TABLE ("ID" INT, "LEVEL" INT)

	--==( Single Object Delete )==--

	--( Get the ID for the noun possibility. Should only be 1.
	SELECT @nObjId = "OBJ" FROM CmPossibility_Name WHERE "TXT" = 'noun'

	--( Get the objects owned by noun
	INSERT INTO @tblOwnedObjects SELECT "ID", 1 FROM CmObject WHERE "OWNER$" = @nObjId

	--( Get the objects owned by the objects owned by noun
	INSERT INTO @tblOwnedObjects
	SELECT o2."ID", 2
	FROM CmObject o0
	JOIN CmObject o1 ON o1.Owner$ = o0."ID"
	JOIN CmObject o2 ON o2.Owner$ = o1."ID"
	WHERE o0."ID" = @nObjId

	--( Get the next level of ownership
	INSERT INTO @tblOwnedObjects
	SELECT o3."ID", 3
	FROM CmObject o0
	JOIN CmObject o1 ON o1.Owner$ = o0."ID"
	JOIN CmObject o2 ON o2.Owner$ = o1."ID"
	JOIN CmObject o3 ON o3.Owner$ = o2."ID"
	WHERE o0."ID" = @nObjId

	SET @sObjId = CONVERT(NVARCHAR(10), @nObjId)
	EXEC DeleteObjects @sObjId

	--( Check owned stuff
	SELECT @nObjId = o3."ID"
	FROM CmObject o0
	JOIN CmObject o1 ON o1.Owner$ = o0."ID"
	JOIN CmObject o2 ON o2.Owner$ = o1."ID"
	JOIN CmObject o3 ON o3.Owner$ = o2."ID"
	JOIN @tblOwnedObjects too ON too."ID" = o3."ID" AND too."LEVEL" = 3
	WHERE o0."ID" = @nObjId

	IF @@ROWCOUNT != 0
		EXEC tsu_failure 'Something on ownership level 3 didn''t get deleted'

	SELECT @nObjId = o2."ID"
	FROM CmObject o0
	JOIN CmObject o1 ON o1.Owner$ = o0."ID"
	JOIN CmObject o2 ON o2.Owner$ = o1."ID"
	JOIN @tblOwnedObjects too ON too."ID" = o2."ID" AND too."LEVEL" = 2
	WHERE o0."ID" = @nObjId

	IF @@ROWCOUNT != 0
		EXEC tsu_failure 'Something on ownership level 2 didn''t get deleted'

	SELECT @nObjId = o1."ID"
	FROM CmObject o1
	JOIN @tblOwnedObjects too ON too."ID" = o1."ID" AND too."LEVEL" = 1
	WHERE o1."OWNER$" = @nObjId

	IF @@ROWCOUNT != 0
		EXEC tsu_failure 'Something on ownership level 1 didn''t get deleted'

	--( Check class hierarchy

	SELECT @nObjId = pos."ID" FROM PartOfSpeech pos WHERE pos."ID" = @nObjId
	IF @@ROWCOUNT != 0
		EXEC tsu_failure 'PartOfSpeech didn''t get deleted'

	SELECT @nObjId = p."ID" FROM CmPossibility p WHERE p."ID" = @nObjId
	IF @@ROWCOUNT != 0
		EXEC tsu_failure 'CmPossibility didn''t get deleted'

	SELECT @nObjId = o."ID" FROM CmObject o WHERE o."ID" = @nObjId
	IF @@ROWCOUNT != 0
		EXEC tsu_failure 'CmObject didn''t get deleted'

	--( Check some pieces

	SELECT @nObjId = p."OBJ" FROM CmPossibility_Abbreviation p WHERE p."OBJ" = @nObjId
	IF @@ROWCOUNT != 0
		EXEC tsu_failure 'CmPossibility_Abbreviation didn''t get deleted'

	SELECT @nObjId = p."OBJ" FROM CmPossibility_Name p WHERE p."OBJ" = @nObjId
	IF @@ROWCOUNT != 0
		EXEC tsu_failure 'CmPossibility_Name didn''t get deleted'

	SELECT @nObjId = p."SRC" FROM CmPossibility_Researchers p WHERE p."SRC" = @nObjId
	IF @@ROWCOUNT != 0
		EXEC tsu_failure 'CmPossibility_Researchers didn''t get deleted'

	SELECT @nObjId = p."SRC" FROM CmPossibility_Restrictions p WHERE p."SRC" = @nObjId
	IF @@ROWCOUNT != 0
		EXEC tsu_failure 'CmPossibility_Restrictions didn''t get deleted'

	SELECT @nObjId = p."SRC" FROM PartOfSpeech_InflectableFeats p WHERE p."SRC" = @nObjId
	IF @@ROWCOUNT != 0
		EXEC tsu_failure 'PartOfSpeech_InflectableFeats didn''t get deleted'

	SELECT @nObjId = m."OBJ" FROM MultiBigStr$ m WHERE m."OBJ" = @nObjId
	IF @@ROWCOUNT != 0
		EXEC tsu_failure 'MultiBigStr$ didn''t get deleted'

END
GO

/***********************************************************************************************
 *	Suite: Sync$Table
 *
 *	Dependencies:
 *		None
 **********************************************************************************************/

IF OBJECT_ID('ut_Sync$Table_ClearSyncTable1$') IS NOT NULL BEGIN
	DROP PROCEDURE [ut_Sync$Table_ClearSyncTable1$]
END
GO
CREATE PROCEDURE ut_Sync$Table_ClearSyncTable1$ AS
BEGIN
		DECLARE @ConnectionCount int, @SyncCount int, @SyncCountNew int, @errMessage NVARCHAR(200)

		-- Make sure we're the only connection to the database. If not, we won't be able
		-- to properly test the ClearSyncTable$ proc
		select @ConnectionCount = count(distinct spid) from master.dbo.sysprocesses sproc
			join master.dbo.sysdatabases sdb on sdb.dbid = sproc.dbid and name = 'TestLangProj'
			where sproc.spid != @@spid
		if @ConnectionCount > 0 BEGIN
			SET @errMessage = 'Cannot test ClearSyncTable$ due to ' +
				CAST(@ConnectionCount AS varchar(15)) + ' extra connection(s) to TestLangProj'
			EXEC tsu_failure @errMessage
			return 1
		END

		-- If there are any existing records sitting in the table, we need to take them into account
		select @SyncCount = (select count(*) from sync$)

		-- Add a couple new records to the sync$ table so we can see if they get smoked
		insert sync$ (LpInfoId, Msg, ObjId, ObjFlid)
		values (newid(), 1, 99, 999)
		insert sync$ (LpInfoId, Msg, ObjId, ObjFlid)
		values (newid(), 2, 199, 1999)
		Set @SyncCount = @SyncCount + 2
		if (select count(*) from sync$) != @SyncCount
			EXEC tsu_failure 'Failed to insert new records into sync$ table'

		EXEC ClearSyncTable$ 'TestLangProj'

		select @SyncCountNew = (select count(*) from sync$)
		if @SyncCountNew != 0 BEGIN
			SET @errMessage = 'Records not deleted from sync$ table. Actual count was ' +
				CAST(@SyncCountNew AS varchar(15)) + '.'
			EXEC tsu_failure @errMessage
		END
END
GO

---------------------------------------------------------------------
IF OBJECT_ID('ut_Sync$Table_StoreSyncRec1$') IS NOT NULL BEGIN
	DROP PROCEDURE [ut_Sync$Table_StoreSyncRec1$]
END
GO
CREATE PROCEDURE ut_Sync$Table_StoreSyncRec1$ AS
BEGIN
		DECLARE @ConnectionCount int, @SyncCount int, @SyncCountNew int, @uidNew uniqueidentifier,
			@errMessage NVARCHAR(200)

		-- Make sure we're the only connection to the database because this test shouldn't actually
		-- create any records in the Sync$ table.
		select @ConnectionCount = count(distinct spid) from master.dbo.sysprocesses sproc
			join master.dbo.sysdatabases sdb on sdb.dbid = sproc.dbid and name = 'TestLangProj'
			where sproc.spid != @@spid
		if @ConnectionCount > 0 BEGIN
			SET @errMessage = 'Cannot test StoreSyncRec$ due to ' +
				CAST(@ConnectionCount AS varchar(15)) + ' extra connection(s) to TestLangProj'
			EXEC tsu_failure @errMessage
			return 1
		END

		-- If there are any existing records sitting in the table, we need to take them into account
		select @SyncCount = (select count(*) from sync$)

		-- Call StoreSyncRec$, but nothing should be added.
		SET @uidNew = newid()
		EXEC StoreSyncRec$ @dbName = 'TestLangProj', @uid = @uidNew, @msg = 3, @hvo = 299, @flid = 2999
		select @SyncCountNew = count(*) from sync$
		if @SyncCountNew != @SyncCount BEGIN
			SET @errMessage = 'StoreSyncRec$ should not have added records to sync$ table. Actual count was: ' +
				CAST(@SyncCountNew AS varchar(15)) +
				'; Expected: ' + CAST(@SyncCount AS varchar(15)) + '.'
			EXEC tsu_failure @errMessage
		END
END
GO

/***********************************************************************************************
 *	Suite: GetObjs
 *
 *	Dependencies:
 *		None
 *
 *	Debug:
 *		Set @fDebug = 1
 **********************************************************************************************/

IF OBJECT_ID('ut_GetObjs_fnGetOwnedObjects$') IS NOT NULL BEGIN
	DROP PROCEDURE ut_GetObjs_fnGetOwnedObjects$
END
GO
CREATE PROCEDURE ut_GetObjs_fnGetOwnedObjects$ AS
BEGIN

	DECLARE
		@fDebug BIT,  -- set to 1 for debugging
		@nObjId INT,
		@nScratchId INT,
		@StrId NVARCHAR(20);

	declare @tObjInfo table (
		[ObjId]			int	not null,
		[ObjClass]		int null,
		[InheritDepth]	int null default(0),
		[OwnerDepth]	int null default(0),
		[RelObjId]		int	null,
		[RelObjClass]	int	null,
		[RelObjField]	int	null,
		[RelOrder]		int	null,
		[RelType]		int	null,
		[OrdKey]		varbinary(250) null	default(0))

	SET @fDebug = 0

	--==( Single Object Delete, with Base, sub, and recurse )==--

	--( Get the ID for the noun possibility. Should only be 1.
	SELECT @nObjId = Obj FROM CmPossibility_Name WHERE Txt = 'noun'
	SET @StrId = CAST(@nObjId AS NVARCHAR(20));

	INSERT INTO @tObjInfo
	SELECT * FROM dbo.fnGetOwnedObjects$(
		@StrId,
		528482304,	--@grfcpt,
		1,			--@fBaseClasses,
		1,			--@fSubClasses,
		1,			--@fRecurse,
		null,		--@riid,
		0)			--@fCalcOrdKey)

	IF @fDebug = 1
		SELECT * FROM @tObjInfo

	-- Check class hierarchy --

	SELECT @nScratchId = pos.ID
	FROM PartOfSpeech pos
	JOIN @tObjInfo toi ON toi.ObjId = pos.Id
	WHERE toi.ObjID = @nObjId

	IF @nScratchID != @nObjId
		EXEC tsu_failure 'PartOfSpeech wasn''t found'

	SELECT @nScratchId = p.ID
	FROM CmPossibility p
	JOIN @tObjInfo toi ON toi.ObjId = p.Id
	WHERE toi.ObjID = @nObjId

	IF @nScratchID != @nObjId
		EXEC tsu_failure 'CmPossibility wasn''t found'

	SELECT @nScratchID = o.ID
	FROM CmObject o
	JOIN @tObjInfo toi ON toi.ObjId = o.Id
	WHERE toi.ObjID = @nObjId

	IF @nScratchID != @nObjId
		EXEC tsu_failure 'CmObject wasn''t found'

	-- Check some object pieces --

	SELECT @nScratchID = p.Obj
	FROM CmPossibility_Abbreviation p
	JOIN @tObjInfo toi ON toi.ObjId = p.Obj
	WHERE toi.ObjID = @nObjId

	IF @nScratchID != @nObjId
		EXEC tsu_failure 'CmPossibility_Abbreviation wasn''t found'

	SELECT @nScratchID = p.Obj
	FROM CmPossibility_Name p
	JOIN @tObjInfo toi ON toi.ObjId = p.Obj
	WHERE toi.ObjID = @nObjId

	IF @nScratchID != @nObjId
		EXEC tsu_failure 'CmPossibility_Name wasn''t found'

	SELECT @nScratchID = m.Obj
	FROM MultiBigStr$ m
	JOIN @tObjInfo toi ON toi.ObjId = m.Obj
	WHERE toi.ObjID = @nObjId

	IF @nScratchID != @nObjId
		EXEC tsu_failure 'MultiBigStr$ wasn''t found'

	-- Some references from the object --

	SELECT @nScratchID = p.Src
	FROM CmPossibility_Researchers p --( reference collection to subclass of CmPerson
	JOIN @tObjInfo toi ON toi.ObjId = p.Src
	WHERE toi.ObjID = @nObjId

	IF @nScratchID != @nObjId
		EXEC tsu_failure 'CmPossibility_Researchers wasn''t found'

	SELECT @nScratchID = p.Src
	FROM CmPossibility_Restrictions p  --( reference collection to subclass of CmPossibility
	JOIN @tObjInfo toi ON toi.ObjId = p.Src
	WHERE toi.ObjID = @nObjId

	IF @nScratchID != @nObjId
		EXEC tsu_failure 'CmPossibility_Restrictions wasn''t found'

	SELECT @nScratchID = p.Src
	FROM PartOfSpeech_InflectableFeats p  --( reference collection
	JOIN @tObjInfo toi ON toi.ObjId = p.Src
	WHERE toi.ObjID = @nObjId

	IF @nScratchID != @nObjId
		EXEC tsu_failure 'PartOfSpeech_InflectableFeats wasn''t found'

	-- Some owned objects --

	SELECT TOP 1 @nScratchID = owned.Owner$
	FROM CmPossibility_Name p --( Part of speech owning another Part of speech
	JOIN CmObject owned ON owned.Id = p.Obj AND owned.Owner$ = @nObjId
	JOIN @tObjInfo toi ON toi.ObjId = owned.Owner$
	WHERE p.Txt = 'nominal' --( Nominal works in all three current writing systems

	IF @nScratchID != @nObjId
		EXEC tsu_failure 'PartOfSpeech ''nominal'' wasn''t found'

	SELECT TOP 1 @nScratchId = stp.Id
	FROM CmObject o
	JOIN CmObject oo ON oo.Owner$ = o.ID
	JOIN CmObject ooo ON ooo.Owner$ = oo.ID
	JOIN CmObject oooo ON oooo.Owner$ = ooo.ID
	JOIN StTxtPara stp ON stp.Id = oooo.Id
	JOIN @tObjInfo toi ON toi.ObjID = stp.ID AND toi.OwnerDepth = 3
	WHERE o.ID = @nObjId

	IF @@ROWCOUNT = 0
		EXEC tsu_failure 'Didn''t find any StTxtPara objects at level 3'

END
GO

---------------------------------------------------------------------

IF OBJECT_ID('ut_GetObjs_GetLinkedObjs$') IS NOT NULL BEGIN
	DROP PROCEDURE ut_GetObjs_GetLinkedObjs$
END
GO
CREATE PROCEDURE ut_GetObjs_GetLinkedObjs$ AS
BEGIN

	DECLARE
		@fDebug BIT,  -- set to 1 for debugging
		@nObjId INT,
		@nClassId INT,
		@nvcObjId NVARCHAR(20);

	--( If someone knows a better way to test this, be my
	--( guest.

	SET @fDebug = 0

	--( The stored procedure currently uses #ObjInfoTbl$, but
	--( we're gonna see if we can get it dropped soon. This test,
	--( using a table variable, reflects that hope.

	declare @tObjInfo table (
		[ObjId]			int	not null,
		[ObjClass]		int null,
		[InheritDepth]	int null default(0),
		[OwnerDepth]	int null default(0),
		[RelObjId]		int	null,
		[RelObjClass]	int	null,
		[RelObjField]	int	null,
		[RelOrder]		int	null,
		[RelType]		int	null,
		[OrdKey]		varbinary(250) null	default(0))

	--==( Single Object Delete, with Base, sub, and recurse )==--

	create table [#ObjInfoTbl$](
		[ObjId] int not null,
		[ObjClass] int null,
		[InheritDepth] int null default(0),
		[OwnerDepth] int null default(0),
		[RelObjId] int null,
		[RelObjClass] int null,
		[RelObjField] int null,
		[RelOrder] int null,
		[RelType] int null,
		[OrdKey] varbinary(250) null default(0))

	--( Get the ID for the noun possibility. Should only be 1.
	SELECT @nObjId = Obj FROM CmPossibility_Name WHERE Txt = 'noun'
	SET @nvcObjID = CAST(@nObjId AS NVARCHAR(20));

	exec GetLinkedObjs$
		@nvcObjId,
		528482304,	--@grfcpt,
		1,			--@fBaseClasses,
		1,			--@fSubClasses,
		1,			--@fRecurse,
		-1,
		null,		--@riid,
		0			--@fCalcOrdKey

	INSERT INTO @tObjInfo
	SELECT * FROM #ObjInfoTbl$

	drop table [#ObjInfoTbl$]

	IF @fDebug = 1
		SELECT * FROM @tObjInfo

	-- Check for referring atomic, referring *to* this object

	SELECT @nClassId = f.Class
	FROM Field$ f
	WHERE f.Id = 5001002 AND f.DstCls = 5049

	IF @nClassID != 5001
		EXEC tsu_failure 'Assert failure: MoStemMsa.PartOfSpeech no longer refers to noun.'

	SET @nObjId = NULL

	SELECT TOP 1 @nObjId = ObjId
	FROM @tObjInfo
	WHERE RelObjClass = @nClassId

	IF @nObjId IS NULL
		EXEC tsu_failure 'Didn''t find any MoStemMsa.PartOfSpeech'

END
GO

/***********************************************************************************************
 *	Suite: StStyle
 *
 *	Dependencies:
 *		None
 **********************************************************************************************/

IF OBJECT_ID('ut_StStyle_InsUdpTrigger') IS NOT NULL BEGIN
	DROP PROCEDURE ut_StStyle_InsUdpTrigger
END
GO
CREATE PROCEDURE ut_StStyle_InsUdpTrigger AS
BEGIN
	DECLARE
		@Type INT,
		@Rules VARBINARY(8000),
		@IsPublishedTextStyle BIT,
		@IsBuiltIn BIT,
		@IsModified BIT,
		@UserLevel INT,
		@Context INT,
		@Structure INT,
		@Function INT,
		@Owner$ INT,
		@OwnFlid$ INT,
		@NewObjId INT,
		@NewObjGuid UNIQUEIDENTIFIER,
		@fReturnTimestamp TINYINT,
		@NewObjTimestamp INT,
		@Err INT;

	SELECT TOP 1
		--( Don't retrieve @Name here. We'll have a different name
		@Type = Type,
		@Rules = Rules,
		@IsPublishedTextStyle = IsPublishedTextStyle,
		@IsBuiltIn = IsBuiltIn,
		@IsModified = IsModified,
		@UserLevel = UserLevel,
		@Context = Context,
		@Structure = Structure,
		@Function = [Function],
		@Owner$ = Owner$,
		@OwnFlid$ = OwnFlid$
	FROM StStyle_
	WHERE Name = N'Normal';

	IF @@ROWCOUNT != 1
		EXEC tsu_Failure 'Database has changed. Couldn''t find the Normal style.'

	SET @NewObjId = NULL;
	SET @NewObjGuid = NULL;
	SET @fReturnTimestamp = 0;

	--( There's plenty that can go wrong just be executing this.

	EXEC MakeObj_StStyle
		N'Test Style Name',
		@Type,
		@Rules,
		@IsPublishedTextStyle,
		@IsBuiltIn,
		@IsModified,
		@UserLevel,
		@Context,
		@Structure,
		@Function,
		NULL, --( Usage WS,
		NULL, --( Usage Txt
		@Owner$,
		@OwnFlid$,
		NULL, --( StartObj
		@NewObjId OUTPUT,
		@NewObjGuid OUTPUT,
		@fReturnTimestamp,
		NULL;
END
GO

/***********************************************************************************************
 *	Suite: IDs
 *
 *	Dependencies:
 *		None
 **********************************************************************************************/

IF OBJECT_ID('ut_Ids_fnGetIdsFromString') IS NOT NULL BEGIN
	DROP PROCEDURE ut_Ids_fnGetIdsFromString
END
GO
CREATE PROCEDURE ut_Ids_fnGetIdsFromString AS
BEGIN
	DECLARE
		@ntIDs NVARCHAR(4000),
		@nCount INT,
		@nID INT,
		@nvcName NVARCHAR(100),
		@nvcClass2Name NVARCHAR(100),
		@hXmlIds INT

	DECLARE @tIds TABLE ("ID" INT)

	--==( Single ID )==--

	SET @ntIds = N'1'

	INSERT INTO @tIds
	SELECT f."ID"
	FROM dbo.fnGetIdsFromString(@ntIds) AS f

	SELECT @nCount = COUNT(*) FROM @tids
	IF @nCount != 1
		EXEC tsu_Failure 'Should only be one record'

	SELECT @nId = "ID"
	FROM @tIds

	IF @nId != 1
		EXEC tsu_failure 'The ID is not 1'

	DELETE @tIds

	--==( More than one ID )==--

	SET @ntIds = N'1,2,3'

	INSERT INTO @tIds
	SELECT f."ID"
	FROM dbo.fnGetIdsFromString(@ntIds) AS f

	SELECT @nId = "ID"
	FROM @tIds
	WHERE "ID" = 2

	IF @@ROWCOUNT != 1
		EXEC tsu_Failure 'Record for ID 2 couldn''t be found'

	IF @nId != 2
		EXEC tsu_failure 'The ID is not 2'

	DELETE @tIds

END
GO

/***********************************************************************************************
 *	Suite: ManageConstraints$
 *
 *	Dependencies:
 *		None
 *	Test Dependencies:
 *		Constraints created for CmObject
 **********************************************************************************************/

IF OBJECT_ID('ut_ManageConstraints$_Deactivate') IS NOT NULL BEGIN
	DROP PROCEDURE [ut_ManageConstraints$_Deactivate]
END
GO
CREATE PROCEDURE ut_ManageConstraints$_Deactivate AS
BEGIN
	DECLARE
		@nvcTableName NVARCHAR(50),
		@nDisabled BIT,
		@sysName SYSNAME,
		@nvcMessage NVARCHAR(200)

	SET @nvcTableName = 'CmObject'
	EXEC ManageConstraints$ @nvcTableName, 'F', 'NOCHECK'

	DECLARE curDisabled CURSOR FOR
		SELECT
			OBJECTPROPERTY(OBJECT_ID(consobjs.[name]), 'CnstIsDisabled') AS IsDisabled,
			consobjs.[name]
		FROM sysconstraints sc
		JOIN sysobjects consobjs ON consobjs.[id] = sc.[constid] --( to get constraint names
		JOIN sysobjects tableobjs ON tableobjs.[id] = sc.[id] --( to get table names
		WHERE tableobjs.[Name] LIKE '%CmObject%' and consobjs.xtype = 'F'

	OPEN curDisabled
	FETCH NEXT FROM curDisabled INTO @nDisabled, @sysName
	WHILE @@FETCH_STATUS = 0
	BEGIN
		IF @nDisabled = 0 BEGIN
			SET @nvcMessage = 'Constraint ' + @sysName + ' is enabled'
			EXEC tsu_failure @nvcMessage
		END

		FETCH NEXT FROM curDisabled INTO @nDisabled, @sysName
	END
	CLOSE curDisabled
	DEALLOCATE curDisabled

END
GO

---------------------------------------------------------------------
IF OBJECT_ID('ut_ManageConstraints$_Activate') IS NOT NULL BEGIN
	DROP PROCEDURE [ut_ManageConstraints$_Activate]
END
GO
CREATE PROCEDURE ut_ManageConstraints$_Activate AS
BEGIN
	DECLARE
		@nvcTableName NVARCHAR(50),
		@nDisabled BIT,
		@sysName SYSNAME,
		@nvcMessage NVARCHAR(200)

	SET @nvcTableName = 'CmObject'
	EXEC ManageConstraints$ @nvcTableName, 'F', 'CHECK'

	DECLARE curEnabled CURSOR FOR
		SELECT
			OBJECTPROPERTY(OBJECT_ID(consobjs.[name]), 'CnstIsDisabled') AS IsDisabled,
			consobjs.[name]
		FROM sysconstraints sc
		JOIN sysobjects consobjs ON consobjs.[id] = sc.[constid] --( to get constraint names
		JOIN sysobjects tableobjs ON tableobjs.[id] = sc.[id] --( to get table names
		WHERE tableobjs.[Name] LIKE '%CmObject%' and consobjs.xtype = 'F'

	OPEN curEnabled
	FETCH NEXT FROM curEnabled INTO @nDisabled, @sysName
	WHILE @@FETCH_STATUS = 0
	BEGIN
		IF @nDisabled = 1 BEGIN
			SET @nvcMessage = 'Constraint ' + @sysName + ' is disabled'
			EXEC tsu_failure @nvcMessage
		END

		FETCH NEXT FROM curEnabled INTO @nDisabled, @sysName
	END
	CLOSE curEnabled
	DEALLOCATE curEnabled

END
GO

---------------------------------------------------------------------
IF OBJECT_ID('ut_ManageConstraints$_Drop') IS NOT NULL BEGIN
	DROP PROCEDURE [ut_ManageConstraints$_Drop]
END
GO
CREATE PROCEDURE ut_ManageConstraints$_Drop AS
BEGIN
	DECLARE @nRowCount INT

	DECLARE @nvcTableName NVARCHAR(50)

	SET @nvcTableName = 'CmObject'
	EXEC ManageConstraints$ @nvcTableName, 'F', 'DROP'

	SELECT consobjs.[name]
	FROM sysconstraints sc
	JOIN sysobjects consobjs ON consobjs.[id] = sc.[constid] --( to get constraint names
	JOIN sysobjects tableobjs ON tableobjs.[id] = sc.[id] --( to get table names
	WHERE tableobjs.[Name] LIKE '%CmObject%' and consobjs.xtype = 'F'

	SET @nRowCount = @@ROWCOUNT

	IF @nRowCount <> 0
		EXEC tsu_failure 'Not all contstraints dropped'

END
GO

---------------------------------------------------------------------
IF OBJECT_ID('ut_ManageConstraints$_DeactivateAll') IS NOT NULL BEGIN
	DROP PROCEDURE [ut_ManageConstraints$_DeactivateAll]
END
GO
--( This is almost identical to ut_ManageConstraints$_Deactivate
CREATE PROCEDURE ut_ManageConstraints$_DeactivateAll AS
BEGIN
	DECLARE
		@nvcTableName NVARCHAR(50),
		@nDisabled BIT,
		@sysName SYSNAME,
		@nvcMessage NVARCHAR(200)

	EXEC ManageConstraints$ NULL, 'F', 'NOCHECK'

	DECLARE curDisabled CURSOR FOR
		SELECT
			OBJECTPROPERTY(OBJECT_ID(consobjs.[name]), 'CnstIsDisabled') AS IsDisabled,
			consobjs.[name]
		FROM sysconstraints sc
		JOIN sysobjects consobjs ON consobjs.[id] = sc.[constid] --( to get constraint names
		JOIN sysobjects tableobjs ON tableobjs.[id] = sc.[id] --( to get table names
		WHERE tableobjs.[Name] LIKE '%CmObject%' and consobjs.xtype = 'F'

	OPEN curDisabled
	FETCH NEXT FROM curDisabled INTO @nDisabled, @sysName
	WHILE @@FETCH_STATUS = 0
	BEGIN
		IF @nDisabled = 0 BEGIN
			SET @nvcMessage = 'Constraint ' + @sysName + ' is enabled'
			EXEC tsu_failure @nvcMessage
		END

		FETCH NEXT FROM curDisabled INTO @nDisabled, @sysName
	END
	CLOSE curDisabled
	DEALLOCATE curDisabled

END
GO


---------------------------------------------------------------------
IF OBJECT_ID('ut_IsValidObject$_ObjectIsExactType') IS NOT NULL BEGIN
	DROP PROCEDURE [ut_IsValidObject$_ObjectIsExactType]
END
GO
CREATE PROCEDURE ut_IsValidObject$_ObjectIsExactType AS
BEGIN
	DECLARE
		@idOfStTextToCheck int,
		@fValid int,
		@sysName SYSNAME,
		@nvcMessage NVARCHAR(200)

	-- Get the id of an arbitrary StText
	SELECT @idOfStTextToCheck = MIN(id) FROM StText

	EXEC IsValidObject$ @idOfStTextToCheck, 14, @fValid out

	IF @fValid = 0 BEGIN
		SET @nvcMessage = 'StText ' + CAST(@idOfStTextToCheck AS nvarchar(20)) +
			' is reported as an invalid object'
		EXEC tsu_failure @nvcMessage
	END
END
GO

---------------------------------------------------------------------
IF OBJECT_ID('ut_IsValidObject$_ObjectIsUnrelatedType') IS NOT NULL BEGIN
	DROP PROCEDURE [ut_IsValidObject$_ObjectIsUnrelatedType]
END
GO
CREATE PROCEDURE ut_IsValidObject$_ObjectIsUnrelatedType AS
BEGIN
	DECLARE
		@fValid int,
		@sysName SYSNAME,
		@nvcMessage NVARCHAR(200)

	-- HVO 1 should be the Language Project, not an StText
	EXEC IsValidObject$ 1, 14, @fValid out

	IF @fValid = 1 BEGIN
		SET @nvcMessage = 'The Language Project (Id=1) is incorrectly reported as a valid StText'
		EXEC tsu_failure @nvcMessage
	END
END
GO

---------------------------------------------------------------------
IF OBJECT_ID('ut_IsValidObject$_ObjectDoesNotExist') IS NOT NULL BEGIN
	DROP PROCEDURE [ut_IsValidObject$_ObjectDoesNotExist]
END
GO
CREATE PROCEDURE ut_IsValidObject$_ObjectDoesNotExist AS
BEGIN
	DECLARE
		@bogusId int,
		@fValid int,
		@sysName SYSNAME,
		@nvcMessage NVARCHAR(200)

	-- Get an HVO which is greater than the greatest existing object
	SELECT @bogusId = MAX(id) + 1 FROM CmObject

	EXEC IsValidObject$ @bogusId, 16, @fValid out

	IF @fValid = 1 BEGIN
		SET @nvcMessage = 'Nonexistant object ' + CAST(@bogusId AS nvarchar(20)) +
			' is incorrectly reported as a valid StTxtPara'
		EXEC tsu_failure @nvcMessage
	END
END
GO

---------------------------------------------------------------------
IF OBJECT_ID('ut_IsValidObject$_ObjectIsDerivedType') IS NOT NULL BEGIN
	DROP PROCEDURE [ut_IsValidObject$_ObjectIsDerivedType]
END
GO
CREATE PROCEDURE ut_IsValidObject$_ObjectIsDerivedType AS
BEGIN
	DECLARE
		@idOfStTxtParaToCheck int,
		@fValid int,
		@sysName SYSNAME,
		@nvcMessage NVARCHAR(200)

	-- Get the id of an arbitrary StTxtPara
	SELECT @idOfStTxtParaToCheck = MIN(id) FROM StTxtPara

	-- Test whether this StTxtPara is a CmObject (class id 0)
	EXEC IsValidObject$ @idOfStTxtParaToCheck, 0, @fValid out

	IF @fValid = 0 BEGIN
		SET @nvcMessage = 'StTxtPara ' + CAST(@idOfStTxtParaToCheck AS nvarchar(20)) +
			' is reported as an invalid CmObject'
		EXEC tsu_failure @nvcMessage
	END

	-- Test whether this StTxtPara is a StPara (class id 15)
	EXEC IsValidObject$ @idOfStTxtParaToCheck, 15, @fValid out

	IF @fValid = 0 BEGIN
		SET @nvcMessage = 'StTxtPara ' + CAST(@idOfStTxtParaToCheck AS nvarchar(20)) +
			' is reported as an invalid StPara'
		EXEC tsu_failure @nvcMessage
	END
END
GO

---------------------------------------------------------------------
IF OBJECT_ID('ut_IsValidObject$_ObjectIsDerivedType') IS NOT NULL BEGIN
	DROP PROCEDURE [ut_IsValidObject$_ObjectIsDerivedType]
END
GO
CREATE PROCEDURE ut_IsValidObject$_ObjectIsDerivedType AS
BEGIN
	DECLARE
		@idOfStTxtParaToCheck int,
		@fValid int,
		@sysName SYSNAME,
		@nvcMessage NVARCHAR(200)

	-- Get the id of an arbitrary StTxtPara
	SELECT @idOfStTxtParaToCheck = MIN(id) FROM StTxtPara

	-- Test whether this StTxtPara is a CmObject (class id 0)
	EXEC IsValidObject$ @idOfStTxtParaToCheck, 0, @fValid out

	IF @fValid = 0 BEGIN
		SET @nvcMessage = 'StTxtPara ' + CAST(@idOfStTxtParaToCheck AS nvarchar(20)) +
			' is reported as an invalid CmObject'
		EXEC tsu_failure @nvcMessage
	END

	-- Test whether this StTxtPara is a StPara (class id 15)
	EXEC IsValidObject$ @idOfStTxtParaToCheck, 15, @fValid out

	IF @fValid = 0 BEGIN
		SET @nvcMessage = 'StTxtPara ' + CAST(@idOfStTxtParaToCheck AS nvarchar(20)) +
			' is reported as an invalid StPara'
		EXEC tsu_failure @nvcMessage
	END
END
GO

---------------------------------------------------------------------
IF OBJECT_ID('ut_ClassIsDerivedFrom$_ClassIsSameClass') IS NOT NULL BEGIN
	DROP PROCEDURE [ut_ClassIsDerivedFrom$_ClassIsSameClass]
END
GO
CREATE PROCEDURE ut_ClassIsDerivedFrom$_ClassIsSameClass AS
BEGIN
	DECLARE
		@fValid int,
		@nvcMessage NVARCHAR(200)

	-- Test whether an StTxtPara is a subclass of StTxtPara
	EXEC ClassIsDerivedFrom$ 16, 16, @fValid out

	IF @fValid = 1 BEGIN
		SET @nvcMessage = 'StTxtPara is incorrectly reported as a subclass of StTxtPara'
		EXEC tsu_failure @nvcMessage
	END
END
GO

---------------------------------------------------------------------
IF OBJECT_ID('ut_ClassIsDerivedFrom$_ClassIsSubClass') IS NOT NULL BEGIN
	DROP PROCEDURE [ut_ClassIsDerivedFrom$_ClassIsSubClass]
END
GO
CREATE PROCEDURE ut_ClassIsDerivedFrom$_ClassIsSubClass AS
BEGIN
	DECLARE
		@fValid int,
		@nvcMessage NVARCHAR(200)

	-- Test whether an StTxtPara (16) is a subclass of StPara (15)
	EXEC ClassIsDerivedFrom$ 16, 15, @fValid out

	IF @fValid = 0 BEGIN
		SET @nvcMessage = 'StTxtPara is incorrectly reported as not derived from au'
		EXEC tsu_failure @nvcMessage
	END
END
GO

/***********************************************************************************************
 *	Suite: Multi
 *
 *	Originally written for the refactoring MultiTxt$ out of the system, this section tests
 *	for the multilingual tables and related stuff.
 *
 *	Dependencies:
 *		None
 *	Test Dependencies:
 *		None
 **********************************************************************************************/

IF OBJECT_ID('ut_Multi_GetMultiTableName') IS NOT NULL BEGIN
	DROP PROCEDURE [ut_Multi_GetMultiTableName]
END
GO
CREATE PROCEDURE ut_Multi_GetMultiTableName AS
BEGIN
	DECLARE
		@nFieldId INT,
		@nTable NVARCHAR(60)

	SELECT @nFieldId = [Id] FROM Field$ WHERE Class = 5062 AND [Name] = 'Form'
	IF @@ROWCOUNT != 1
		EXEC tsu_failure 'Flid for WfiWordform_Form doesn''t exist anymore'

	SET @nTable = NULL
	EXEC GetMultiTableName @nFieldId, @nTable OUTPUT

	IF @nTable != 'WfiWordform_Form' OR @nTable IS NULL
		EXEC tsu_failure 'GetMultiTableName didn''t return WfiWordform_Form'
END
GO

---------------------------------------------------------------------
IF OBJECT_ID('ut_Multi_MergeWritingSystem') IS NOT NULL BEGIN
	DROP PROCEDURE [ut_Multi_MergeWritingSystem]
END
GO
CREATE PROCEDURE ut_Multi_MergeWritingSystem AS
BEGIN
	DECLARE
		@nOldWritingSystem INT,
		@nNewWritingSystem INT,
		@nWS INT

	SET @nNewWritingSystem = 9999

	SELECT @nOldWritingSystem = [Id] FROM LgWritingSystem WHERE IcuLocale = 'en'
	IF @@ROWCOUNT != 1
		EXEC tsu_failure 'ID for en in LgWritingSystem not found'

	EXEC MergeWritingSystem @nOldWritingSystem, @nNewWritingSystem

	SELECT @nWS = WS FROM WfiWordform_Form WHERE WS = @nOldWritingSystem
	IF @@ROWCOUNT != 0
		EXEC tsu_failure 'Still found the old writing system in WfiWordformForm'

END
GO

/***********************************************************************************************
 *	Suite: Utils
 *
 *	Dependencies:
 *		None
 *	Test Dependencies:
 *		None
 **********************************************************************************************/

IF OBJECT_ID('ut_Utils_RenameClass') IS NOT NULL BEGIN
	DROP PROCEDURE ut_Utils_RenameClass
END
GO
CREATE PROCEDURE ut_Utils_RenameClass AS
BEGIN
	DECLARE
		@ClassId INT,
		@NewClassName NVARCHAR(100),
		@Object_Id INT,
		@FieldId INT,
		@Counter INT,
		@FieldCountBefore INT,
		@FieldCountAfter INT,
		@ColumnName NVARCHAR(100),
		@ViewName NVARCHAR(100),
		@RecordCount INT,
		@TableName1 NVARCHAR(100),
		@TableName NVARCHAR(100)


	SET @NewClassName = N'CmPoss'
	SELECT @ClassId = Id FROM Class$ WHERE Name = N'CmPossibility'
	IF @@ROWCOUNT != 1
		EXEC tsu_failure 'Can''t find "CmPossibility" The database has changed.';

	SELECT @FieldCountBefore = COUNT(*) FROM Field$ WHERE Class = @ClassId

	EXEC RenameClass @ClassId, @NewClassName

	--==( Check Renamed Tables )==--

	--( Check that Field$ got put back together right.  Ann

	SELECT @FieldCountAfter = COUNT(*) FROM Field$
	WHERE Class = @ClassId and
		((Name = 'Name' and id = 7001) or
		(Name = 'Abbreviation' and id = 7002) or
		(Name = 'Description' and id = 7003) or
		(Name = 'SubPossibilities' and id = 7004) or
		(Name = 'SortSpec' and id = 7006) or
		(Name = 'Restrictions' and id = 7007) or
		(Name = 'Confidence' and id = 7008) or
		(Name = 'Status' and id = 7009) or
		(Name = 'DateCreated' and id = 7010) or
		(Name = 'DateModified' and id = 7011) or
		(Name = 'Discussion' and id = 7012) or
		(Name = 'Researchers' and id = 7013) or
		(Name = 'HelpId' and id = 7014) or
		(Name = 'ForeColor' and id = 7015) or
		(Name = 'BackColor' and id = 7016) or
		(Name = 'UnderColor' and id = 7017) or
		(Name = 'UnderStyle' and id = 7018) or
		(Name = 'Hidden' and id = 7019) or
		(Name = 'IsProtected' and id = 7020))

	IF @FieldCountAfter != 19
		EXEC tsu_failure 'The field IDs in Field$ didn''t get reset right 1.'

	--( Check that Field$ got put back together right.

	SELECT @FieldCountAfter = COUNT(*) FROM Field$ WHERE Class = @ClassId
	IF @FieldCountAfter != @FieldCountBefore
		EXEC tsu_failure 'The field IDs in Field$ didn''t get reset right.'

	--( Check that the table for the class got renamed.

	SET @Object_Id = OBJECT_ID('CmPossibility')
	IF @Object_Id IS NOT NULL
		EXEC tsu_failure 'Table CmPossibility still exists.'
	SET @Object_Id = OBJECT_ID('CmPoss')
	IF @Object_Id IS NULL
		EXEC tsu_failure 'Table CmPoss doesn''t exist.'

	--(Type 13 (string) Check to see if it exists in the renamed table
	--(if this type column is in the new table  -Ann

	SELECT @RecordCount = COUNT(*) FROM Field$ WHERE Class = @ClassId and Type = 13
	IF @RecordCount = 0
		print 'No Type 13 Columns found in Class ' + CAST(@ClassId AS char(2))
	ElSE BEGIN
		SELECT TOP 1 @ColumnName = Name FROM Field$ WHERE Class = @ClassId
		IF @@ROWCOUNT != 1
			print 'No Type 13 Columns found in Class ' + CAST(@ClassId AS char(2))
		SELECT @TableName = Name FROM Class$ WHERE Id = @ClassId
		IF @@ROWCOUNT != 1
			print 'No Row found for Class ' + CAST(@ClassId AS char(2))
		IF columnproperty (object_id(@TableName), @ColumnName, 'AllowsNull') IS NULL
			EXEC tsu_failure 'Type 13 Column doesn''t exist in the renamed table.'
	END

	--( Type 14 (multistring). Check to see if the new column is in the renamed view
	-- if this type column is in the new table  -Ann

	SELECT @RecordCount = COUNT(*) FROM Field$ WHERE Class = @ClassId and Type = 14
	IF @RecordCount != 0 BEGIN
		SELECT TOP 1 @ColumnName = Name FROM Field$ WHERE Class = @ClassId and Type = 14
		IF @@ROWCOUNT != 1
			print 'No Type 14 Columns found in Class ' + CAST(@ClassId AS char(2))
		SELECT @TableName = Name FROM Class$ WHERE Id = @ClassId
		IF @@ROWCOUNT != 1
			print 'No Row found for Class ' + CAST(@ClassId AS char(2))
		SET @ViewName = @TableName + '_' + @ColumnName
		IF OBJECT_ID(@ViewName, N'V') IS NULL
			EXEC tsu_failure 'Type 14 Column doesn''t exist in the renamed view.'
	END

	--( Check that the table for multiunicode (type 16) got renamed.

	SET @Object_Id = OBJECT_ID('CmPossibility_Name')
	IF @Object_Id IS NOT NULL
		EXEC tsu_failure 'Table CmPossibility_Name still exists.'
	SET @Object_Id = OBJECT_ID('CmPoss_Name')
	IF @Object_Id IS NULL
		EXEC tsu_failure 'Table CmPoss_Name doesn''t exist.'

	--( For MultiBigStr$, the flid gets renamed to 999xxx at one point,
	--( then back again. We need to make sure the flid gets renamed.
	--( This will help us figure whether the flid failed to be updated,
	--( or the view based on MultiBigStr$ didn't get regenerated right.
	--( (Type 18).

	SELECT TOP 1 @FieldId = Id FROM Field$ WHERE Class = @ClassId AND Name = N'Description'
	SELECT @Counter = COUNT(*) FROM MultiBigStr$ WHERE Flid = @FieldId
	IF @Counter = 0
		EXEC tsu_failure 'The MultiBigStr$ table didn''t get updated properly.'

	--( Check that the table for referencing sequence (type 26) got renamed.

	SET @Object_Id = OBJECT_ID('CmPossibility_Restrictions')
	IF @Object_Id IS NOT NULL
		EXEC tsu_failure 'Table CmPossibility_Restrictions still exists.'
	SET @Object_Id = OBJECT_ID('CmPoss_Restrictions')
	IF @Object_Id IS NULL
		EXEC tsu_failure 'Table CmPoss_Restrictions doesn''t exist.'

	--( No type 28 (RefencenceSequence) exists in CmPossibility. Test later.
	--( Check to see that the attribute table for this type column exists -Ann

	SELECT @RecordCount = COUNT(*) FROM Field$ WHERE Class = @ClassId and Type = 28
	IF @RecordCount != 0 BEGIN
		SELECT TOP 1 @ColumnName = Name FROM Field$ WHERE Class = @ClassId and Type = 28
		IF @@ROWCOUNT != 1
			print 'No Type 28 Columns found in Class ' + CAST(@ClassId AS char(2))
		SELECT @TableName = Name FROM Class$ WHERE Id = @ClassId
		IF @@ROWCOUNT != 1
			print 'No Row found for Class ' + CAST(@ClassId AS char(2))
		SET @TableName1 = @TableName + '_' + @ColumnName
		print @tablename1
		IF OBJECT_ID(@TableName1, N'U') IS NULL
			EXEC tsu_failure 'Table doesn''t exist for the type 28 column.'
	END

	--==( Check for Renamed Views )==--

	--( Check for the class table's view (for example, CmPossibility_)

	SET @Object_Id = OBJECT_ID('CmPossibility_')
	IF @Object_Id IS NOT NULL
		EXEC tsu_failure 'Table CmPossibility_ still exists.'
	SET @Object_Id = OBJECT_ID('CmPoss_')
	IF @Object_Id IS NULL
		EXEC tsu_failure 'Table CmPoss_ doesn''t exist.'

	--( Check that the view for MultiBigStr (type 18) got renamed.

	SET @Object_Id = OBJECT_ID('CmPossibility_Description')
	IF @Object_Id IS NOT NULL
		EXEC tsu_failure 'Table CmPossibility_Description still exists.'
	SET @Object_Id = OBJECT_ID('CmPoss_Description')
	IF @Object_Id IS NULL
		EXEC tsu_failure 'Table CmPoss_Description doesn''t exist.'

	--( Check that the view for owning atomic (type 23) got renamed.

	SET @Object_Id = OBJECT_ID('CmPossibility_Discussion')
	IF @Object_Id IS NOT NULL
		EXEC tsu_failure 'Table CmPossibility_Discussion still exists.'
	SET @Object_Id = OBJECT_ID('CmPoss_Discussion')
	IF @Object_Id IS NULL
		EXEC tsu_failure 'Table CmPoss_Discussion doesn''t exist.'

	--( Type 25 (Owning Collections)
	--( Check to see that the renamed owned collection views for this type column exists -Ann

	SELECT @RecordCount = COUNT(*) FROM Field$ WHERE Class = @ClassId and Type = 25
	IF @RecordCount != 0 BEGIN
		SELECT TOP 1 @ColumnName = Name FROM Field$ WHERE Class = @ClassId and Type = 25
		IF @@ROWCOUNT != 1
			print 'No Type 25 Columns found in Class ' + CAST(@ClassId AS char(2))
		SELECT @TableName = Name FROM Class$ WHERE Id = @ClassId
		IF @@ROWCOUNT != 1
			print 'No Row found for Class ' + CAST(@ClassId AS char(2))
		SET @ViewName = @TableName + '_' + @ColumnName
		IF OBJECT_ID(@ViewName, N'V') IS NULL
			EXEC tsu_failure 'Type 25 Column wasn''t created into a renamed view.'
	END
	--( Check that the view for owning atomic (type 27) got renamed. This
	--( particular one points to itself. That is, CmPossibility owns a
	--( CmPossibility.

	SET @Object_Id = OBJECT_ID('CmPossibility_SubPossibilities')
	IF @Object_Id IS NOT NULL
		EXEC tsu_failure 'Table CmPossibility_SubPossibilities still exists.'
	SET @Object_Id = OBJECT_ID('CmPoss_SubPossibilities')
	IF @Object_Id IS NULL
		EXEC tsu_failure 'Table CmPoss_SubPossibilities doesn''t exist.'

	--==( Check for Renamed Triggers )==--

	--( Check for class table triggers

	SET @Object_Id = OBJECT_ID('TR_CmPossibility_ObjDel_Del')
	IF @Object_Id IS NOT NULL
		EXEC tsu_failure 'Table TR_CmPossibility_ObjDel_Del still exists.'
	SET @Object_Id = OBJECT_ID('TR_CmPoss_ObjDel_Del')
	IF @Object_Id IS NULL
		EXEC tsu_failure 'Table TR_CmPoss_ObjDel_Del doesn''t exist.'

	SET @Object_Id = OBJECT_ID('TR_CmPossibility_TStmp')
	IF @Object_Id IS NOT NULL
		EXEC tsu_failure 'Table TR_CmPossibility_TStmp still exists.'
	SET @Object_Id = OBJECT_ID('TR_CmPoss_TStmp')
	IF @Object_Id IS NULL
		EXEC tsu_failure 'Table TR_CmPoss_TStmp doesn''t exist.'

	--( Check for attribute table triggers

	SET @Object_Id = OBJECT_ID('TR_CmPossibility_Researchers_DtTmDel')
	IF @Object_Id IS NOT NULL
		EXEC tsu_failure 'Table TR_CmPossibility_Researchers_DtTmDel still exists.'
	SET @Object_Id = OBJECT_ID('TR_CmPoss_Researchers_DtTmDel')
	IF @Object_Id IS NULL
		EXEC tsu_failure 'Table TR_CmPoss_Researchers_DtTmDel doesn''t exist.'

	--==( Check for Renamed Constraints/Foreign Keys )==--

	--( Type 2 integer check constraint

	SET @Object_Id = OBJECT_ID('_CK_CmPoss_UnderStyle')
	IF @Object_Id IS NULL
		EXEC tsu_failure 'Check constraint _CK_CmPoss_UnderStyle doesn''t exist.'

	--( Type 24 referencing atomic *to* the object

	SET @Object_Id = OBJECT_ID('_FK_CmPerson_Education')
	IF @Object_Id IS NULL
		EXEC tsu_failure 'Foreign key _FK_CmPerson_Education doesn''t exist.'

	--( Type 26 referencing collection *to* the object

	SET @Object_Id = OBJECT_ID('_FK_CmPerson_Positions_Dst')
	IF @Object_Id IS NULL
		EXEC tsu_failure 'Foreign key _FK_CmPerson_Positions_Dst doesn''t exist.'

	--( Type 26 referencing collection *of* the object

	SET @Object_Id = OBJECT_ID('_FK_CmPoss_Researchers_Dst')
	IF @Object_Id IS NULL
	EXEC tsu_failure 'Foreign key _FK_CmPoss_Researchers_Dst doesn''t exist.'

	--( constraints on Field$

	SET @Object_Id = OBJECT_ID('TR_Field$_UpdateModel_Del')
	IF @Object_Id IS NULL
	EXEC tsu_failure 'Constrainst TR_Field$_UpdateModel_Del doesn''t exist.'

	SET @Object_Id = OBJECT_ID('TR_Field$_No_Upd')
	IF @Object_Id IS NULL
	EXEC tsu_failure 'Constrainst TR_Field$_No_Upd doesn''t exist.'

	--( Type 27 currently doesn't get a constraint built, like the referencing
	--( atomic, collection, and sequences do.

END
GO
