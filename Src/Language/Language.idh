/*--------------------------------------------------------------------*//*:Ignore this sentence.
Copyright (C) 1999, 2002 SIL International. All rights reserved.

Distributable under the terms of either the Common Public License or the
GNU Lesser General Public License, as specified in the LICENSING.txt file.

File: Language.idh
Responsibility: John Thomson
Last reviewed: Mid June, 2000. Several changes suggested, not yet all made or reviewed.

Description:
	The Language classes provide specifications and implementations of how text in various
	(language) writing systems behaves.

	Note: Language.idh is included in FwKernelTlb.idl. This is how it becomes available to C#
	programs. Therefore, to make a new or modified interface available without remakefw,
	you must cc mkfwk-nodep, than do a clean COMInterfaces-nodep, then build COMInterfaces-nopdep.

	The root (document) class is the LgWritingSystem class. Logically there ought
	possibly to be a LgLanguage class which owns a number of writing systems; but a Language
	has no computationally interesting behavior until it is encoded in a writing system, and it
	is useful to be able to install an writing system in isolation. We therefore decided not to
	implement Language as a distinct class, but just to have the LgWritingSystem class
	provide some basic documentation about its language.

	The language writing system class has a number of "engines." Each of these implements an
	interface for one area of functionality related to text manipulation.

	Note that writing systems as described in this document are not intended to model the
	linguistically interesting aspects of these concepts. They are specifically intended to
	model those aspects needed so that the computer can correctly manipulate data in the
	particular writing system.
-------------------------------------------------------------------------------*//*:End Ignore*/
// Indentation is as if all this were embedded in a library declaration.

	//:>****************************************************************************************
	//:>		Forward declarations
	//:>****************************************************************************************
	interface IRenderEngine;
	interface ILgCharacterPropertyEngine;
	interface ILgStringConverter;
	interface ILgTokenizer;
	interface ILgSpellCheckFactory;
	interface ILgSpellChecker;
	interface ILgCollatingEngine;
	interface ILgSearchEngine;
	interface ICollation;
	interface ILgWritingSystem;
	interface ILgWritingSystemFactory;
	interface ILgTextServices;

	//:>****************************************************************************************
	//:>		Enumerations
	//:>****************************************************************************************

	// Main types of characters, as defined by Unicode and used by the character
	// property engine.
	typedef [v1_enum] enum LgGeneralCharCategory
	{
		kccLu, // = Letter, Uppercase
		kccLl, // = Letter, Lowercase
		kccLt, // = Letter, Titlecase (e.g., Dz digraph as single code point)
		kccLm, // = Letter, Modifier
		kccLo, // = Letter, Other

		kccMn, // = Mark, Non-Spacing
		kccMc, // = Mark, Spacing Combining
		kccMe, // = Mark, Enclosing

		kccNd, // = Number, Decimal Digit
		kccNl, // = Number, Letter
		kccNo, // = Number, Other

		kccZs, // = Separator, Space
		kccZl, // = Separator, Line
		kccZp, // = Separator, Paragraph

		kccCc, // = Other, Control
		kccCf, // = Other, Format
		kccCs, // = Other, Surrogate
		kccCo, // = Other, Private Use
		kccCn, // = Other, Not Assigned

		kccPc, // = Punctuation, Connector
		kccPd, // = Punctuation, Dash
		kccPs, // = Punctuation, Open
		kccPe, // = Punctuation, Close
		kccPi, // = Punctuation, Initial quote (may behave like Ps or Pe depending
			   //				  on usage)
		kccPf, // = Punctuation, Final quote (may behave like Ps or Pe depending
			   //				  on usage)
		kccPo, // = Punctuation, Other

		kccSm, // = Symbol, Math
		kccSc, // = Symbol, Currency
		kccSk, // = Symbol, Modifier
		kccSo, // = Symbol, Other
	} LgGeneralCharCategory;  // Hungarian: cc

	// Unicode Bidirectional Categories, used by character property engine
	typedef [v1_enum] enum LgBidiCategory
	{
		// Strong
		kbicL,   // Left-Right; most alphabetic chars, etc.
		kbicLRE, // Left-Right Embedding
		kbicLRO, // Left-Right Override
		kbicR,   // Right-Left; Hebrew and its punctuation
		kbicAL,  // Right-Left Arabic
		kbicRLE, // Right-Left Embedding
		kbicRLO, // Right-Left Override
		kbicPDF, // Pop Directional Format

		// Weak
		kbicEN,  //	European Number
		kbicES,  //	European Number Separator
		kbicET,  //	European Number Terminator
		kbicAN,  //	Arabic Number
		kbicCS,  //	Common Number Separator

		// Separators:
		kbicNSM, // Non-Spacing Mark
		kbicBN,  // Boundary Neutral
		kbicB,   //	Paragraph Separator
		kbicS,   //	Segment Separator

		// Neutrals:
		kbicWS,  //	Whitespace
		kbicON,  //	Other Neutrals ; All other characters: punctuation, symbols
	} LgBidiCategory;  // Hungarian: bic

	// Line Breaking Character classes defined by Unicode.
	typedef [v1_enum] enum LgLBP
	{
				 // '*' indicates normative property
		klbpAI,  //  0   Ambiguous (Alphabetic or Ideographic)
		klbpAL,  //  1   Ordinary Alphabetic
		klbpB2,  //  2   Break Opportunity Before and After
		klbpBA,  //  3   Break Opportunity After
		klbpBB,  //  4   Break Opportunity Before
		klbpBK,  //  5 * Mandatory Break
		klbpCB,  //  6 * Contingent Break Opportunity
		klbpCL,  //  7   Closing
		klbpCM,  //  8 * Combining Marks
		klbpCR,  //  9 * Carriage Return
		klbpEX,  // 10   Exclamation
		klbpGL,  // 11 * Non-breaking ("Glue")
		klbpHY,  // 12   Hyphen
		klbpID,  // 13   Ideographic
		klbpIN,  // 14   Inseparable
		klbpIS,  // 15   Infix Separator (Numeric)
		klbpLF,  // 16 * Line Feed
		klbpNS,  // 17   Non Starter
		klbpNU,  // 18   Numeric
		klbpOP,  // 19   Opening
		klbpPO,  // 20   Postfix (Numeric)
		klbpPR,  // 21   Prefix (Numeric)
		klbpQU,  // 22   Ambiguous Quotation
		klbpSA,  // 23   Complex Context
		klbpSG,  // 24 * Surrogates
		klbpSP,  // 25 * Space
		klbpSY,  // 26   Symbols Allowing Breaks
		klbpXX,  // 27   Unknown (used for unassigned characters)
		klbpZW   // 28 * Zero Width Space
	} LgLBP;  // Hungarian lbp

	// Character decomposition tags
	typedef [v1_enum] enum LgDecompMapTag
	{
		kdtNoTag,
		kdtFont,
		kdtNoBreak,
		kdtInitial,
		kdtMedial,
		kdtFinal,
		kdtIsolated,
		kdtCircle,
		kdtSuper,
		kdtSub,
		kdtVertical,
		kdtWide,
		kdtNarrow,
		kdtSmall,
		kdtSquare,
		kdtFraction,
		kdtCompat
	} LgDecompMapTag;	// Hungarian dt

	// XML tags
	typedef [v1_enum] enum LgXMLTag
	{
		kxmlInvalid,
		kxmlChardefs,
		kxmlDef,
		kxmlUdata,
		kxmlLinebrk
	} LgXMLTag;		// Hungarian xml

	/*******************************************************************************************
		Interface ILgWritingSystem
		An LgWritingSystem represents one way of writing data in a particular language
		(or dialect). It has a number of engines which implement various aspects of writing
		system behavior.

		ENHANCE: May need some more 'documentation' type attributes, such as
		an author, region, country--what exactly is useful?

		@h3{When to implement}
		Clients should not implement this interface.

		@h3{When to use}
		Use this class when you need to get one of the engines or other bits of information
		it stores about an writing system. In some cases, if you need only one engine, it is
		simpler to ask the ${LgWritingSystemFactory} for it in a single step.

		Don't use an ILgWritingSystem when you just need to identify an writing system, but
		don't actually need any of the engines. Use the integer which stands for the writing
		system.

		@h3{How to obtain an instance}
		Normally, use the get_Engine method of an ${LgWritingSystemFactory}. This will create
		and writing system with all default engines if one does not already exist. To avoid
		this, use get_EngineOrNull instead.

		@h3{Hungarian: ws or wseng}
		(Note: use wseng when you need to distinguish the interface/object from the writing
		system's integer code, which uses ws as its Hungarian.)
	*******************************************************************************************/
	DeclareInterface(LgWritingSystem, Unknown, 9F74A170-E8BB-466d-8848-5FDB28AC5AF8)
	{
		// The identifier for this writing system.
		[propget] HRESULT Id(
			[out, retval] BSTR *pbstr);

		// GET THE WRITING SYSTEM INTEGER that identifies this writing system to classes which
		// don't actually need to use its methods
		[propget] HRESULT Handle(
			[out, retval] int * pws);

		// Get the language name.
		[propget] HRESULT LanguageName(
			[out, retval] BSTR * pbstr);

		// Get the ISO 639-3 language code (Ethnologue code).
		[propget] HRESULT ISO3(
			[out, retval] BSTR * pbstr);

		// Get the locale assigned to this writing system.
		[propget] HRESULT LCID(
			[out, retval] int * pnLocale);
		// Set the locale for this writing system.
		[propput] HRESULT LCID(
			[in] int nLocale);

		// Get the name of the spelling dictionary to use for this writing system.
		// Currently returns a generally-useful default, unless explicitly set to empty
		// to prevent this.
		[propget] HRESULT SpellCheckingId(
			[out, retval] BSTR *pbstr);
		// Set the name of the spelling dictionary to use for this writing system.
		// Eventually we plan to persist this fully; for now, it is useful only for setting
		// to null to disable it for this session.
		[propput] HRESULT SpellCheckingId(
			[in] BSTR bstr);

		// Get the primary direction, used for complex embedding; may have fragments like
		// numbers that go the other way internally.
		[propget] HRESULT RightToLeftScript(
			[out, retval] ComBool * pfRightToLeft);
		// Set the primary direction, used for complex embedding; may have fragments like
		// numbers that go the other way internally.
		[propput] HRESULT RightToLeftScript(
			[in] ComBool fRightToLeft);

		// Get the engine used to render text with the specified properties. At present only
		// font, bold, and italic properties are significant.
		// Font name may be '<default serif>' which produces a renderer suitable for the default
		// serif font.
		[propget] HRESULT Renderer(
			[in] IVwGraphics * pvg,
			[out, retval] IRenderEngine ** ppreneng);

		// Get the "serif font variation" string which is used, for instance, to specify
		// Graphite features.
		[propget] HRESULT DefaultFontFeatures(
			[out, retval] BSTR * pbstr);
		// Set the "serif font variation" string which is used, for instance, to specify
		// Graphite features.
		[propput] HRESULT DefaultFontFeatures(
			[in] BSTR bstr);

		// Get the default serif font; usually used for the main body of text in a document.
		[propget] HRESULT DefaultFontName(
			[out, retval] BSTR * pbstr);
		// Set the default serif font; usually used for the main body of text in a document.
		[propput] HRESULT DefaultFontName(
			[in] BSTR bstr);

		// Get the engine used to find character properties, including figuring out where line
		// breaks are allowed.
		[propget] HRESULT CharPropEngine(
			[out, retval] ILgCharacterPropertyEngine ** pppropeng);
		// Apply any changes to the chrp before it is used for real: currently,
		// interpret the magic font names.
		HRESULT InterpretChrp(
			[in, out] LgCharRenderProps * pchrp);

		// A Keyman keyboard name that should be used to invoke the appropriate
		// Keyman keyboard if the writing sytem requires it. Leave as empty string
		// for non-Keyman IMs.
		[propget] HRESULT Keyboard(
			[out, retval] BSTR * pbstr);
		[propput] HRESULT Keyboard(
			[in] BSTR bstr);

		// The current input language. By default this is derived from LCID, but it can be
		// overridden temporarily (for one session). Note that this is not persisted.
		[propget] HRESULT CurrentLCID(
			[out, retval] int * pnLangId);
		// Set the current (temporary) LangId for this writing system.
		[propput] HRESULT CurrentLCID(
			[in] int nLangId);
	};

	//:>****************************************************************************************
	//:>	These are the interfaces for the engines--the code that actually does the work.
	//:>****************************************************************************************

	/*******************************************************************************************
		Interface ILgInputMethodEditor
		Functions related to special ways of typing for exotic writing systems.
		The ${#Setup} method is called before the user types something and may do things at the
		system level (such as setting the current system IME or Keyman file) to change what is
		received through WM_CHAR. The other methods allow post-processing of what is received
		through WM_CHAR.

		@h3{When to implement}
		Clients should not normally implement this interface. Standard implementations are in
		Language.dll. If you have a very unusual input method requirement, you could make your
		own implementation.

		Note: current FieldWorks code is @i{not} using this approach to typing. Check out
		@HTTP{intranet.sil.org/softwaredev/project_status.htm} to see if there are any plans.

		@h3{When to use}
		Most programmers will not use this interface directly. It is used by the Views
		subsystem and controls that accept typing in vernacular scripts.

		@h3{How to obtain an instance}
		At present, you can't. Eventually OldWritingSystem will implement a method. Some
		implemenations may also be available through CoCreateInstance.

		@h3{Hungarian: ime}

	*******************************************************************************************/
	DeclareInterface(LgInputMethodEditor, Unknown, E1B27A5F-DD1B-4BBA-9B72-00BDE03162FC)
	{
		// GET THE SYSTEM READY TO use this input method; for example, switch Keyman to the
		// proper table.
		HRESULT Setup();

		// Given something the user typed, following any preprocessing that happens
		// automatically as a result of Setup (e.g., Keyman processing), do any further
		// processing required to actually replace the selected part of the string with  what
		// the user typed.
		// The default implementation just replaces characters from ichMin to ichLim with
		// those from bstrInput, then sets *pichModMin to ichMin, and *pichModLim and
		// *pichIP both to ichMin + BstrLen(bstrInput).
		// @param bstrInput What the user typed.
		// @param pttpInput Text properties desired for new text
		// @param ptsbOld Original, unedited text, gets modified by this method
		// @param ichMin Range in old ptsbOld to replace
		// @param ichLim Range in old ptsbOld to replace
		// @param pichModMin Range in modified ptsbOld that is different from before
		// @param pichModLim Range in modified ptsbOld that is different from before
		// @param pichIP Position of insertion point in modified string
		// @return The result is the modified string represented by ptsbOld.
		// @exception E_INVALIDARG ichMin/Lim is not a valid range within ptsbOld
		[local, restricted] HRESULT Replace(
			[in] BSTR bstrInput,
			[in] ITsTextProps * pttpInput,
			[in] ITsStrBldr * ptsbOld,
			[in] int ichMin,
			[in] int ichLim,
			[out] int * pichModMin,
			[out] int * pichModLim,
			[out] int * pichIP);

		// The user pressed a certain number of backspaces. Delete an appropriate amount of
		// the string represented by the input string builder, indicating exactly what changed.
		// Also, if there were not enough characters to delete, indicate how many backspaces
		// were left over.
		// @param pichStart start position (delete characters before here)
		// @param cactBackspace number of backspaces pressed
		// @param ptsbOld the text being edited; gets changed by this call
		// @param pichModMin range in output text affected
		// @param pichModLim range in output text affected
		// @param pichIP position of IP in modified string
		// @param pcactBsRemaining Number not handled, caller should apply to previous run or
		// string
		HRESULT Backspace(
			[in] int pichStart,
			[in] int cactBackspace,
			[in] ITsStrBldr * ptsbOld,
			[out] int * pichModMin,
			[out] int * pichModLim,
			[out] int * pichIP,
			[out] int * pcactBsRemaining);

		// The user pressed a certain number of delete forward characters. Compute the effect on
		// ptsbInOut
		// Also, if there were not enough characters to delete, indicate how many backspaces
		// were left over.
		// @param pichStart start position (delete characters after here)
		// @param cactDelForward number of DF pressed
		// @param ptsbInOut the text being edited; gets changed by this call
		// @param pichModMin range in output text affected
		// @param pichModLim range in output text affected
		// @param pichIP position of IP in modified string
		// @param pcactDfRemaining Number not handled, caller should apply to next run or string
		HRESULT DeleteForward(
			[in] int pichStart,
			[in] int cactDelForward,
			[in] ITsStrBldr * ptsbInOut,
			[out] int * pichModMin,
			[out] int * pichModLim,
			[out] int * pichIP,
			[out] int * pcactDfRemaining);

		// Return true if input method considers an IP at the specified index reasonable.
		// Note that really useful IPs should also satisfy the Renderer; see
		// ${ILgSegment#IsValidInsertionPoint}.
		HRESULT IsValidInsertionPoint(
			[in] int ich,
			[in] ITsString * ptss,
			[out, retval] BOOL * pfValid);
	};

	/*******************************************************************************************
		Interface ILgFontManager
		Obtain a list of the (TrueType) fonts that are available on the system, and handle
		simple queries about font availability.

		Note: the font manager may load the available fonts once, and use this cached list
		to answer subsequent queries. To be sure the answer to a query is current, call
		RefreshFontList.

		@h3{When to implement}
		Clients should not implement this interface. There is a standard implementation in
		Language.dll.

		@h3{When to use}
		Use this interface when you need to know whether a given font is available on the
		system, or to get a list of available fonts.

		@h3{How to obtain an instance}
		Use CoCreateInstance, CLSID_LgFontManager. Or use the CreateInstance() method of a
		smart pointer.

		@h3{Hungarian: fm}
	*******************************************************************************************/
	DeclareInterface(LgFontManager, Unknown, 73718689-B701-4241-A408-4C389ECD6664)
	{
		// Is the given font available?
		HRESULT IsFontAvailable(
			[in] BSTR bstrName,
			[out, retval] ComBool * pfAvail);

		// Is the given font available?
		HRESULT IsFontAvailableRgch(
			[in] int cch,
			[in] OLECHAR * prgchName,
			[out, retval] ComBool * pfAvail);

		// Get the list of available fonts delimited by L'\0'.
		HRESULT AvailableFonts(
			[out] BSTR * pbstrNames);

		// Update the list of fonts (by re-reading from the OS).
		HRESULT RefreshFontList();
	};


	//:>****************************************************************************************
	//:>	CoClass definitions.
	//:>****************************************************************************************

	#ifndef NO_COCLASSES
	DeclareCoClass(LgInputMethodEditor, 659C2C2F-7AF6-4F9E-AC6F-7A03C8418FC9)
	{
		interface ILgInputMethodEditor;
	};

	DeclareCoClass(LgFontManager, 02C3F580-796D-4B5F-BE43-166D97319DA5)
	{
		interface ILgFontManager;
	};
	#endif // !NO_COCLASSES

	// Flags used to specify variations on how to collate.
	// Default is all listed options off.
	// Except where noted, options are orthogonal and may be ORed together for combined
	// effect.
	// Unrecognized options are ignored. This allows for forwards compatibility: as we
	// introduce new options, older engines will continue to work but ignore them.
	// (An unrecognized option is any bit not used by any of the options defined here.)
	typedef [v1_enum] enum LgCollatingOptions
	{
		fcoDefault = 0,
		fcoIgnoreCase = 1,
		fcoDontIgnoreVariant = 2,
		fcoLim // max valid value.
	} LgCollatingOptions; // Hungarian colopt

	/*******************************************************************************************
		Interface ILgCollatingEngine
		A collating engine knows how to compare strings in the same writing system.

		@h3{When to implement}
		Clients should not normally implement this interface. There are standard implementations
		in Language.dll. A new implementation might possibly be made for a language with very
		unusual collating requirements, if none of the standard implementations can be
		configured to suit.

		@h3{When to use}
		Use this interface when you need to know whether a given string collates before or after
		another, or to create a list of keys that can be simply compared in order to sort a
		larger list.

		@h3{How to obtain an instance}
		Obtain a collating engine from the writing system using
		${LgWritingSystem#get_CollatingEngine}. Obtain a default Unicode collater from
		${LgWritingSystemFactory#get_DefaultCollater}.

		@h3{Hungarian: coleng}
	*******************************************************************************************/
	DeclareInterface(LgCollatingEngine, Unknown, D27A3D8C-D3FE-4E25-9097-8F4A1FB30361)
	{
		// Get a sort key which may be compared to any other sort key produced by this
		// object via a simple BSTR comparison. This is especially useful in large-scale
		// sorting, where the work to generate the key only needs to be done once per key
		[propget] HRESULT SortKey(
			[in] BSTR bstrValue,
			[in] LgCollatingOptions colopt,
			[out, retval] BSTR * pbstrKey);

		// Get a sort key which may be compared to any other sort key produced by this
		// object via a simple wcscmp comparison. This is especially useful in large-scale
		// sorting, where the work to generate the key only needs to be done once per key

		// @param cchMaxOut Available space in output buffer. If 0, the method just sets
		// *pchKey to the number required.
		// @exception ERROR_INSUFFICIENT_BUFFER if not enough space in output buffer (gives
		// needed amount in *pcchOut).
		[restricted] HRESULT SortKeyRgch(
			[in, size_is(cchIn)] const OLECHAR * pch,
			[in] int cchIn,
			[in] LgCollatingOptions colopt,
			[in] int cchMaxOut,
			[out, size_is(cchMaxOut)] OLECHAR * pchKey,
			[out] int * pcchOut);

		// Return in *pnVal (<0, 0, or >0) depending on whether the first string is
		// (less than, equal, or greater than) the second string passed. This in principle
		// creates a SortKey for each string using the SortKey method, then compares them.
		// Any actual implementation promises to give the same results as doing that.
		// However, the actual implementation may be more efficient than that, saving time
		// when only a single comparison is to be made involving each string.
		HRESULT Compare(
			[in] BSTR bstrValue1,
			[in] BSTR bstrValue2,
			[in] LgCollatingOptions colopt,
			[out, retval] int * pnVal);

		// Get the language writing system factory used with this collating engine object.
		[propget] HRESULT WritingSystemFactory(
			[out, retval] ILgWritingSystemFactory ** ppwsf);
		// Set the language writing system factory to use with this collating engine object.
		[propputref] HRESULT WritingSystemFactory(
			[in] ILgWritingSystemFactory * pwsf);

		// The next two methods are required by C# which doesn't know that BSTRs can be anything
		// but NUL-terminated UTF-16 strings.

		// Get a sort key which may be compared to any other sort key produced by this
		// object via a simple BSTR comparison. This is especially useful in large-scale
		// sorting, where the work to generate the key only needs to be done once per key
		[propget] HRESULT SortKeyVariant(
			[in] BSTR bstrValue,
			[in] LgCollatingOptions colopt,
			[out, retval] VARIANT * psaKey);		// will be a "safearray".

		// Return in *pnVal (<0, 0, or >0) depending on whether the first string is
		// (less than, equal, or greater than) the second string passed. This in principle
		// creates a SortKey for each string using the SortKey method, then compares them.
		// Any actual implementation promises to give the same results as doing that.
		// However, the actual implementation may be more efficient than that, saving time
		// when only a single comparison is to be made involving each string.
		HRESULT CompareVariant(
			[in] VARIANT saValue1,			// "safearray"
			[in] VARIANT saValue2,			// "safearray"
			[in] LgCollatingOptions colopt,
			[out, retval] int * pnVal);

		// Initialize the collating engine to the given locale.
		HRESULT Open(
			[in] BSTR bstrLocale);

		// Close and free the currently open collating engine, if any.
		HRESULT Close();

		// ENHANCE JohnT: we should have an Rgch version of Compare().
	};

	/*******************************************************************************************
		Interface ILgCharacterPropertyEngine
		This interface provides information about character properties and converting between
		characters.

		Note the use of int rather than OLECHAR throughout for character codes. This allows
		for the possibility of characters not in plane 0, though the current base implementation
		considers all characters outside plane 0 to be unassigned.

		In general, routines which take a single character as input return E_INVALIDARG if the
		character is outside the extended Unicode range (i.e., it could not be represented as
		two surrogate pair characters).

		@h3{When to implement}
		Clients should not normally implement this interface. There are standard implementations
		in Language.dll.

		@h3{When to use}
		Use this interface when you need to know properties of characters, such as whether a
		character is a letter, how it behaves in the Unicode bidi algorithm, how it combines
		with other characters, whether it is a symbol, separator, etc, its case, how it
		might decompose, and so forth. A particularly important use is to determine possible
		line break positions in a string.

		@h3{How to obtain an instance}
		Obtain a collating engine from the writing system using
		${LgWritingSystem#get_CharPropEngine}. Obtain a default Unicode char props engine from
		${LgWritingSystemFactory#get_UnicodeCharProps}.

		@h3{Hungarian: propeng}
	*******************************************************************************************/
	DeclareInterface(LgCharacterPropertyEngine, Unknown, 890C5B18-6E95-438E-8ADE-A4FFADDF0684)
	{
		// Get the exact character category as defined in the Unicode standard.
		// See @HTTP{www.unicode.org/Public/UNIDATA/UnicodeData.html#General%20Category}
		[propget] HRESULT GeneralCategory(
			[in] int ch,
			[out, retval] LgGeneralCharCategory * pcc);

		// Get the Bidi category of a character as defined in the Unicode standard.
		// See @HTTP{www.unicode.org/Public/UNIDATA/UnicodeData.html#Bidirectional%20Category}
		// See @HTTP{www.unicode.org/unicode/reports/tr9/} for the full algorithm
		[propget] HRESULT BidiCategory(
			[in] int ch,
			[out, retval] LgBidiCategory * pbic);

		// Return true if Unicode general category starts with L. See ${#get_GeneralCategory}
		// If this returns true, exactly one of ${#get_IsUpper}, ${#get_IsLower},
		// ${#get_IsTitle}, ${#get_IsModifier}, or ${#get_IsOtherLetter} will return true.
		[propget] HRESULT IsLetter(
			[in] int ch,
			[out, retval] ComBool *pfRet);
		// Return true if character is considered to be part of a word (by default, this
		// corresponds to Unicode general category Mc, Mn, and categories starting with L.
		// ENHANCE: Eventually, this method may need to be altered or replaced to acocunt
		// for the reality that some languages have context rules to determine whether a
		// character is word-forming or not (e.g., apostrophes).
		// See ${#get_GeneralCategory}
		[propget] HRESULT IsWordForming(
			[in] int ch,
			[out, retval] ComBool *pfRet);
		// Return true if Unicode general category starts with P. See ${#get_GeneralCategory}
		[propget] HRESULT IsPunctuation(
			[in] int ch,
			[out, retval] ComBool *pfRet);
		// Return true if Unicode general category starts with N. See ${#get_GeneralCategory}
		[propget] HRESULT IsNumber(
			[in] int ch,
			[out, retval] ComBool *pfRet);
		// Return true if Unicode general category starts with Z. See ${#get_GeneralCategory}
		[propget] HRESULT IsSeparator(
			[in] int ch,
			[out, retval] ComBool *pfRet);
		// Return true if Unicode general category starts with S. See ${#get_GeneralCategory}
		[propget] HRESULT IsSymbol(
			[in] int ch,
			[out, retval] ComBool *pfRet);
		// Return true if Unicode general category starts with M. See ${#get_GeneralCategory}
		[propget] HRESULT IsMark(
			[in] int ch,
			[out, retval] ComBool *pfRet);
		// Return true if Unicode general category starts with C. See ${#get_GeneralCategory}
		[propget] HRESULT IsOther(
			[in] int ch,
			[out, retval] ComBool *pfRet);


		// Return true if Unicode general category is Lu. See ${#get_GeneralCategory}
		[propget] HRESULT IsUpper(
			[in] int ch,
			[out, retval] ComBool *pfRet);
		// Return true if Unicode general category is Ll. See ${#get_GeneralCategory}
		// In languages without case all characters are considered lower case.
		[propget] HRESULT IsLower(
			[in] int ch,
			[out, retval] ComBool *pfRet);
		// Return true if Unicode general category is Lt. See ${#get_GeneralCategory}
		// This refers to "Title case" characters, typically a single code point standing for
		// two letters, where the first is upper case and the second is lower.
		// Unicode general category Lt, typically digraph with first upper
		[propget] HRESULT IsTitle(
			[in] int ch,
			[out, retval] ComBool *pfRet);
		// Return true if Unicode general category is Lm. See ${#get_GeneralCategory}
		[propget] HRESULT IsModifier(
			[in] int ch,
			[out, retval] ComBool *pfRet);
		// Return true if Unicode general category is Lo. See ${#get_GeneralCategory}
		[propget] HRESULT IsOtherLetter(
			[in] int ch,
			[out, retval] ComBool *pfRet);

		// Return true if Unicode general category is Ps. See ${#get_GeneralCategory}
		// Signifies opening punctuation, like left paren
		// ENHANCE JohnT: Should opening include Pi, Initial quote?
		[propget] HRESULT IsOpen(
			[in] int ch,
			[out, retval] ComBool *pfRet);
		// Return true if Unicode general category is Pe. See ${#get_GeneralCategory}
		// Signifies closing punctuation, like right paren.
		// ENHANCE JohnT: should we also include Pf, final quote?
		[propget] HRESULT IsClose(  // Unicode general category Pe,
			[in] int ch,
			[out, retval] ComBool *pfRet);
		// Return true if Unicode general category is Pc. See ${#get_GeneralCategory}
		// Signifies  middle of a word, like hyphen.
		// ENHANCE JohnT: should we also include Pd, dash
		[propget] HRESULT IsWordMedial(
			[in] int ch,
			[out, retval] ComBool *pfRet);

		// Return true if Unicode general category is Cc. See ${#get_GeneralCategory}
		[propget] HRESULT IsControl(
			[in] int ch,
			[out, retval] ComBool *pfRet);

		// Convert a character to lower case if it is Lu or Lt; otherwise return it unchanged.
		// ENHANCE JohnT: should we convert characters that are not Lu or Lt but for which
		// UnicodeData.txt specifies a case conversion?
		//
		// See ${#ToLower} to convert an entire string, or to make use of Unicode muli-character
		// conversions.
		// @exception E_INVALIDARG if passed invalid Unicode code point, including one half
		// of a surrogate pair.
		[propget] HRESULT ToLowerCh(
				  [in] int ch,
				  [out, retval] int * pch);
		// Convert a character to upper case if it is Ll or Lt; otherwise return it unchanged.
		// ENHANCE JohnT: should we convert characters that are not Ll or Lt but for which
		// UnicodeData.txt specifies a case conversion?
		//
		// See ${#ToUpper} to convert an entire string, or to make use of Unicode muli-character
		// conversions.
		// @exception E_INVALIDARG if passed invalid Unicode code point, including one half
		// of a surrogate pair.
		[propget] HRESULT ToUpperCh(
				  [in] int ch,
				  [out, retval] int * pch);
		// Convert a character to title case if it is Lu or Ll; otherwise return it unchanged.
		// Usually this is the same as converting it to upper case.
		// ENHANCE JohnT: should we convert characters that are not Lu or Ll but for which
		// UnicodeData.txt specifies a case conversion?
		//
		// See ${#ToTitle} to convert an entire string, or to make use of Unicode muli-character
		// conversions.
		// @exception E_INVALIDARG if passed invalid Unicode code point, including one half
		// of a surrogate pair.
		[propget] HRESULT ToTitleCh(
				  [in] int ch,
				  [out, retval] int * pch);

		// Convert a string to lower case. Characters that are not Lu or Lt pass through
		// unchanged.  Note that the output may be longer than the input! This function, unlike
		// ${#get_ToLowerCh}, will apply multi-character conversions if Unicode specifies them.
		// @exception E_INVALIDARG if characters in input are not valid Unicode.
		HRESULT ToLower(
				  [in] BSTR bstr,
				  [out, retval] BSTR * pbstr);
		// Convert a string to upper case. Characters that are not Ll or Lt pass through
		// unchanged.  Note that the output may be longer than the input! This function, unlike
		// ${#get_ToUpperCh}, will apply multi-character conversions if Unicode specifies them.
		// @exception E_INVALIDARG if characters in input are not valid Unicode.
		HRESULT ToUpper(
				  [in] BSTR bstr,
				  [out, retval] BSTR * pbstr);
		// Convert a string to title case. Characters that are not Lu or Ll pass through
		// unchanged.  Note that the output may be longer than the input!  This function, unlike
		// ${#get_ToUpperCh}, will apply multi-character conversions if Unicode specifies them.
		// Note that this is not usually useful, because if you want title case, you usually
		// want to convert only the first non-punctuation character, or perhaps the first of
		// each word.  However, this at least provides a way to get at multi-character
		// conversions by passing a single character input string.
		// @exception E_INVALIDARG if characters in input are not valid Unicode.
		HRESULT ToTitle(
				  [in] BSTR bstr,
				  [out, retval] BSTR * pbstr);

		// Convert a string to lower case. Characters that are not Lu or Lt pass through
		// unchanged.  Note that the output may be longer than the input! This function, unlike
		// ${#get_ToLowerCh}, will apply multi-character conversions if Unicode specifies them.
		// If cchOut is zero, just return the length needed.
		// @exception E_FAIL if cchOut is non-zero and too small
		// @exception E_INVALIDARG if characters in input are not valid Unicode.
		[restricted] HRESULT ToLowerRgch(
				  [in, size_is(cchIn)] OLECHAR * prgchIn,
				  [in] int cchIn,
				  [out, size_is(cchOut)] OLECHAR * prgchOut,
				  [in] int cchOut,
				  [out] int * pcchRet);
		// Convert a string to upper case. Characters that are not Ll or Lt pass through
		// unchanged.  Note that the output may be longer than the input! This function, unlike
		// ${#get_ToUpperCh}, will apply multi-character conversions if Unicode specifies them.
		// If cchOut is zero, just return the length needed.
		// @exception E_FAIL if cchOut is non-zero and too small
		// @exception E_INVALIDARG if characters in input are not valid Unicode.
		[restricted] HRESULT ToUpperRgch(
				  [in, size_is(cchIn)] OLECHAR * prgchIn,
				  [in] int cchIn,
				  [out, size_is(cchOut)] OLECHAR * prgchOut,
				  [in] int cchOut,
				  [out] int * pcchRet);
		// Convert a string to title case. Characters that are not Lu or Ll pass through
		// unchanged.  Note that the output may be longer than the input! This function, unlike
		// ${#get_ToUpperCh}, will apply multi-character conversions if Unicode specifies them.
		// Note that this is not usually useful, because if you want title case, you usually
		// want to convert only the first non-punctuation character, or perhaps the first of
		// each word.  However, this at least provides a way to get at multi-character
		// conversions by passing a single character input string.
		// If cchOut is zero, just return the length needed.
		// @exception E_FAIL if cchOut is non-zero and too small
		// @exception E_INVALIDARG if characters in input are not valid Unicode.
		[restricted] HRESULT ToTitleRgch(
				  [in, size_is(cchIn)] OLECHAR * prgchIn,
				  [in] int cchIn,
				  [out, size_is(cchOut)] OLECHAR * prgchOut,
				  [in] int cchOut,
				  [out] int * pcchRet);

		// Returns true if the specified code point is a member of the specified user defined
		// class of code points. Nathan thinks we should restrict class names to a single
		// character to make patterns containing them more readable. Example \C\Vxyz for all
		// words containing a consonant, followed by a vowel, followed by xyz.
		//
		// Not yet implemented, and may not be, as it is not clear that this is the right place
		// to store user defined character classes.
		[propget] HRESULT IsUserDefinedClass(
			[in] int ch,
			[in] int chClass,
			[out, retval] ComBool * pfRet);

		// Converts a string into another string in which all characters are replaced with their
		// sound alike equivalent. For example, if for this language s and z where specified to
		// sound alike, we could take s as the generic form and convert all z's to this form.
		// Note that we need to support the possibility that 0 (empty code point) and x and y
		// sound alike which means that all x's and 's and y's will be ignored when testing for
		// sound alikeness.
		//
		// ENHANCE JohnT: Should this be a separate engine? Does it belong to the spelling
		// engine?
		// ENHANCE Development(JohnT): enhance the specification so it can specify sound-alikes.
		//
		// Not yet implemented, and may never be.
		[propget] HRESULT SoundAlikeKey(
			[in] BSTR bstrValue,
			[out, retval] BSTR * pbstrKey);

		// Get the official Unicode character name (character database field 1).
		// Will also produce a somewhat helpful descriptive string for surrogate halves and
		// PUA characters, though officially they have no name.
		// (Warning: obtaining this for the first character in each page will be somewhat slow,
		// and will use up something like 10K of RAM).
		// @exception E_INVALIDARG if character input is not valid Unicode.
		[propget] HRESULT CharacterName(
			[in] int ch,
			[out, retval] BSTR * pbstrName);

		// Get the decomposition of this character (Unicode char database field 5).
		// Empty string if it does not decompose.
		// @exception E_INVALIDARG if character input is not valid Unicode.
		[propget] HRESULT Decomposition(
			[in] int ch,
			[out, retval] BSTR * pbstr);
		// Get the decomposition of this character (Unicode char database field 5).
		// Empty string if it does not decompose.
		// @exception E_INVALIDARG if character input is not valid Unicode.
		[restricted] HRESULT DecompositionRgch(
			[in] int ch,
			[in] int cchMax,
			[out] OLECHAR * prgch,
			[out] int * pcch,
			[out] ComBool * pfHasDecomp);

		// Get the recursive canonical decomposition of a character. Empty string if it does
		// not decompose at all.
		// @exception E_INVALIDARG if character input is not valid Unicode.
		[propget] HRESULT FullDecomp(
			[in] int ch,
			[out, retval] BSTR * pbstrOut);
		// Get the recursive canonical decomposition of a character. The character itself if it
		// does not decompose at all.
		// @exception E_INVALIDARG if character input is not valid Unicode.
		[restricted] HRESULT FullDecompRgch(
			[in] int ch,
			[in] int cchMax,
			[out] OLECHAR * prgch,
			[out] int * pcch,
			[out] ComBool * pfHasDecomp);

		// Get the character's value as a number.(Field 8 in
		// @HTTP{www.unicode.org/Public/UNIDATA/UnicodeData.html}).
		// @exception E_INVALIDARG if character input is not valid Unicode.
		// @exception E_UNEXPECTED if the character is not
		// one of the Nd, Nl, or No types, or if it is one of those types but the
		// Unicode database gives no numeric value for it.
		// Currently also if the character represents a fraction.
		// @end
		// ENHANCE JohnT: is there a more useful behavior for the fraction case?
		// Would it be better to return 0 for all cases where we don't know a useful answer?
		[propget] HRESULT NumericValue(
			[in] int ch,
			[out, retval] int * pn);

		// Get the character's combining class (Unicode char database field 3; see
		// @HTTP{www.unicode.org/Public/UNIDATA/UnicodeData.html#Canonical%20Combining%20Classes})
		// @exception E_INVALIDARG if character input is not valid Unicode.
		[propget] HRESULT CombiningClass(
			[in] int ch,
			[out, retval] int * pn);

		// Get any comment recorded about this character (Unicode char database field 11).
		// Note: currently this is not implemented to obtain the rather uninteresting comments
		// recorded in the standard UnicodeDatabase file. It will give interesting answers only
		// if a comment is provided in the specification for this writing system.
		[propget] HRESULT Comment(
			[in] int ch,
			[out, retval] BSTR * pbstr);

		// Get line breaking properties (from enumeration LgLBP) for an array of characters.
		// This passes an array in, and an array with the same number of elements out, to
		// improve efficiency when properties are required for a string of characters.
		// See @HTTP{www.unicode.org/unicode/reports/tr14/}.
		// @exception E_INVALIDARG if characters in input are not valid Unicode.
		[restricted] HRESULT GetLineBreakProps(
			[in, size_is(cchIn)] const OLECHAR * prgchIn,
			[in] int cchIn,
			[out, size_is(cchIn)] byte * prglbOut);

		// Get line break status (from combinations of values in enumeration LgLineBreakStatus)
		// of each character in the input array.
		// @exception E_INVALIDARG if characters in input are not valid Unicode.
		[restricted] HRESULT GetLineBreakStatus(
			[in, size_is(cb)] const byte * prglbpIn,
			[in] int cb,
			[out, size_is(cb)] byte * prglbsOut);

		// This combines the functions of ${#GetLineBreakProps} and ${#GetLineBreakStatus},
		// plus the ability to skip part of the string, and stop at break characters.
		//
		// The first two arguments define an array of characters as for ${#GetLineBreakProps}.
		// The output is basically what would be produced by passing the output of
		// that method as input to GetLineBreakStatus, with two exceptions:
		//
		// 1. We only want line break status info for characters from ichMin to ichLim.
		// (A larger array is passed in because we may need to look at preceding characters
		// to confidently know whether we can break after the char at ichMin.)
		//
		// 2. If we detect a character which forces a line or segment break in the range
		// ichMin..ichLim, we stop and do not return any info about subsequent characters.
		//
		// Also, we set *pichBreak to the index of the break character.
		// *pichBreak is set to -1 if we don't find a break character.
		// Break characters are things like CR, LF, TAB, or the embedded object character.
		[restricted] HRESULT GetLineBreakInfo(
			[in, size_is(cchIn)] const OLECHAR * prgchIn,
			[in] int cchIn,
			[in] int ichMin,
			[in] int ichLim,
			[out, size_is(ichLim - ichMin)] byte * prglbsOut,
			[out] int * pichBreak);

		// Strip diacritics. Specifically, removes all characters that have the property Lm on
		// Mn.  Note that this will not comvert a single code point that includes a diacritic to
		// its unmodified equivalent. It is usually desireable to first perform normalization
		// (form D or KD) before stripping diacritics.
		HRESULT StripDiacritics(
			  [in] BSTR bstr,
			  [out, retval] BSTR * pbstr);
		// Strip diacritics. Specifically, removes all characters that have the property Lm or
		// Mn.  Note that this will not comvert a single code point that includes a diacritic to
		// its unmodified equivalent. It is usually desireable to first perform normalization
		// (form D or KD) before stripping diacritics.
		[restricted] HRESULT StripDiacriticsRgch(
			[in, size_is(cchIn)] OLECHAR * prgchIn,
			[in] int cchIn,
			[out, size_is(cchMaxOut)] OLECHAR * prgchOut,
			[in] int cchMaxOut,
			[out] int * pcchOut);

		// Perform compatibility normalization of the input string, that is, every character
		// which  has a compatibility decomposition is decomposed (recursively). This is
		// Normalization Form KD (NFKD) as defined by Unicode TR 15.
		[restricted] HRESULT NormalizeKdRgch(
			[in, size_is(cchIn)] OLECHAR * prgchIn,
			[in] int cchIn,
			[out, size_is(cchMaxOut)] OLECHAR * prgchOut,
			[in] int cchMaxOut,
			[out] int * pcchOut);

		// Perform normalization of the input string, that is, every character
		// which  has a decomposition is decomposed (recursively). This is
		// Normalization Form D (NFD) as defined by Unicode TR 15.
		HRESULT NormalizeD(
			  [in] BSTR bstr,
			  [out, retval] BSTR * pbstr);
		// Perform compatibility normalization of the input string, that is, every character
		// which  has a compatibility decomposition is decomposed (recursively). This is
		// Normalization Form D (NFD) as defined by Unicode TR 15.
		[restricted] HRESULT NormalizeDRgch(
			[in, size_is(cchIn)] OLECHAR * prgchIn,
			[in] int cchIn,
			[out, size_is(cchMaxOut)] OLECHAR * prgchOut,
			[in] int cchMaxOut,
			[out] int * pcchOut);

		// Returns the locale of the engine.  See put_Locale for more notes.
		[propget] HRESULT Locale(
			[out, retval] int * pnLocale);

		// Assigns the locale of the engine.  The locale affects the ICU functions called for
		// line breaking and changing cases.  Note that the locale is read in using the
		// Microsoft format we've been using for the rest of FieldWorks, as opposed to the ICU
		// format (which it's translated into inside the class implementation).
		[propput] HRESULT Locale(
			[in] int nLocale);

		// Gets the text that the LineBreakBefore and LineBreakAfter functions are using.  This
		// function is included for completion.
		HRESULT GetLineBreakText(
			[in] int cchMax,
			[out] OLECHAR * prgchOut,
			[out] int * pcchOut);
		// Sets the text for the LineBreakBefore and the LineBreakAfter functions to use.
		[propput] HRESULT LineBreakText(
			[in, size_is(cchMax)] OLECHAR * prgchIn,
			[in] int cchMax);


		// Finds the nearest line break immediately before the given index (ichIn).  The
		// function returns not only a location but the weight of the line break (currently not
		// implemented).  See http://www.unicode.org/unicode/reports/tr14/ for more information
		// on line breaking properties.
		HRESULT LineBreakBefore(
			[in] int ichIn,
			[out] int * pichOut,
			[out] LgLineBreak * plbWeight);

		// Finds the nearest line break immediately after the given index (ichIn).  The function
		// returns not only a location but the weight of the line break (currently not
		// implemented).  See http://www.unicode.org/unicode/reports/tr14/ for more information
		// on line breaking properties.
		HRESULT LineBreakAfter(
			[in] int ichIn,
			[out] int * pichOut,
			[out] LgLineBreak * plbWeight);
	};

	/*******************************************************************************************
		Interface ILgIcuCharPropEngine
		This interface provides initialization functions for an ICU character property engine.

		@h3{When to implement}
		Clients should not normally implement this interface. There are standard implementations
		in Language.dll.

		@h3{When to use}
		Use this interface when you need to initialize an ICU character property engine.

		@h3{How to obtain an instance}
		For now the only way is to create one using CoCreateInstance, with
		CLSID_LgIcuCharPropEngine.

		@h3{Hungarian: ipropeng}
	*******************************************************************************************/
	DeclareInterface(LgIcuCharPropEngine, LgCharacterPropertyEngine, E8689492-7622-427b-8518-6339294FD227)
	{
		HRESULT Initialize(
			[in] BSTR bstrLanguage,
			[in] BSTR bstrScript,
			[in] BSTR bstrCountry,
			[in] BSTR bstrVariant);

		HRESULT InitCharOverrides(
			[in] BSTR bstrWsCharsList);
	}

	/*******************************************************************************************
		Interface ILgSearchEngine
		Knows how to search for a pattern in a string. Also how to throw up a dialog for
		asking what to search for.
		ENHANCE JohnT: does throwing up the dialog belong here? That is a UI function...
		ENHANCE JohnT: does a search engine belong in the Language component?

		@h3{When to implement}
		We expect that the standard implementations will be all you need.

		@h3{When to use}
		Use this interface to search for a pattern in a string.

		@h3{How to obtain an instance}
		Currently you can't. No implementations have been attempted.

		@h3{Hungarian: srcheng}
	*******************************************************************************************/
	DeclareInterface(LgSearchEngine, Unknown, 09FCA8D5-5BF6-4BFF-A317-E0126410D79A)
	{
		// Set up the search engine with a specified pattern.
		// ENHANCE JohnT: do we need "match whole words only"? Does sound-alike make sense
		// otherwise?
		// ENHANCE: define wild card syntax to use. (Should they be characters at all? Should we
		// mark pattern characters with a different writing system and display them specially,
		// e.g., <start word>?)
		// ESCES needs at least the following wild card capabilities:
		//	- word begin, end
		//	- string begin, end. The size of string is up to the caller of FindString,
		//		typically a paragraph.
		//	- predefined character classes: punctuation, white space, letter, symbol, number,
		//		the various types of letter defined for character classification.
		//	- user-defined character classes (e.g., consonants, low vowels)
		//		(The find dialog should allow these to be edited.)
		//	- occurrence specifications (optional, 0 or more, 1 or more, range)
		// ENHANCE: for a replace method, we would also need wild cards to mark start and end
		// of substring for use in the output. This can also be useful in the find pattern,
		// to say "what I found earlier must occur again"--e.g. for vowel harmony.
		HRESULT SetPattern(
			[in] BSTR bstrPattern,
			[in] ComBool fIgnoreCase,
			[in] ComBool fIgnoreModifiers,
			[in] ComBool fUseSoundAlike,
			[in] ComBool fUseWildCards);

		// Set the replacement string/pattern. Required only if replacing.
		// ENHANCE JohnT: should this be an optional argument to SetPattern? Or, should this
		// method have all the arguments of SetPattern as well?
		HRESULT SetReplacePattern(
			[in] BSTR bstrPattern);

		// Throw up a dialog which requests from the user, in an appropriate form for the
		// specified writing system, a search pattern. The information requested is that
		// provided by the SetPattern method.
		HRESULT ShowPatternDialog(
			[in] BSTR bstrTitle,  // To show in dialog--Clarify: in title bar?
			[in] ILgWritingSystem * pwse,	// WS to use for display; if NULL, use default ws
			[in] ComBool fForReplace,   // If true, include replace with field
			[out, retval] ComBool * pfGoAhead); // true to proceed with search, false to cancel

		// Search for a string.
		// ENHANCE JohnT: probably a similar method FindStringRgch, probably also FindStringTss
		HRESULT FindString(
			[in] BSTR bstrSource,
			[in] int ichFirst,  // start searching here
			[out] int * ichMinFound,
			[out] int * ichLimFound,
			[out, retval] ComBool * pfFound);

		// Find a substring and indicate what should replace it, if the client decides to
		// go ahead. Answers S_OK if found, S_FALSE if not found, possibly ERROR codes.
		// (Inconsistent with FindString, but keeps it down to one OUT param for VB.)
		// ENHANCE JohnT: should we change FindString to return S_OK/S_FALSE to conform?
		// Should we have this method just return the replacement string (for the last
		// thing found by FindString)?
		HRESULT FindReplace(
			[in] BSTR bstrSource,
			[in] int ichFirst,  // start searching here
			[out] int * ichMinFound,
			[out] int * ichLimFound,
			[out, retval] BSTR * pbstrReplacement);  // (maybe deduced from pattern)

		// ENHANCE JohnT: should we have more methods to read results of last Find, such as
		// substrings matched by parts of the pattern?

		// ENHANCE JohnT: should we have rgch versions of find and replace?

	};

	/*******************************************************************************************
		Interface ILgStringConverter
		Knows how to convert strings from one writing system to another (or similar functions).
		Hungarian: strconv

		ENHANCE JohnT: this class implements the main method of Ken's IStringConvert interface,
		but not its initialization approach; this engine must be initializable from a moniker.
		Is there a way we can capture the commonality?

		Note also: NRSI is interested in implementing string converters, but have identified
		a need for a different interface based that is more stream like. This allows a client
		to "pull" as much output as needed, and the converter to process only as much text
		as needed. It also allows converters to be conveniently chained together for a more
		complex conversion. Thus, we may end up with a quite different interface.

		A further complication is the need to apply conversions to only the CDATA parts of
		XML files, or even to apply different conversions to different elements. This area
		requires considerable further design work.

		@h3{When to implement}
		Implement this interface if you need to plug in a custom string converter for one of
		the components that use such converters. First check out the standard implementations.

		@h3{When to use}
		Use this interface to make systematic changes to strings.

		@h3{How to obtain an instance}
		Currently you can't. No implementations have been attempted.

		@h3{Hungarian: srcheng}
	*******************************************************************************************/
	DeclareInterface(LgStringConverter, Unknown, 8BE2C911-6A81-48B5-A27F-B8CE63983082)
	{
		// Convert a string.
		// ENHANCE JohnT: how will we handle strings that can't be converted without user
		// intervention?  Does this method fail, and some other process picks up the unconverted
		// strings?  What if parts of the string can be converted but others can't?
		// Is this method allowed to UI? Should there be explicit control of that? Should it
		// instead have a call-back to ask what to do about ambiguities?
		HRESULT ConvertString(
			[in] BSTR bstrIn,
			[out,retval] BSTR * pbstrOut);

		// Convert a string.
		// ENHANCE JohnT: another idea is that if the buffer is too small or NULL, it sets
		// pcchOut to the required size and fills in as much as will fit. An error is not
		// reported, so the client must be careful to check that *pcchOut is <= cchMax.
		// There should be some way for the client to just find out how big a buffer is
		// needed.
		// ENHANCE JohnT: Ken's interface calls this method ConvertStrngCP, I think.
		// @exception E_BUFFER_TOO_SMALL if the output buffer won't hold the output
		[restricted] HRESULT ConvertStringRgch(
			[in, size_is(cch)] const OLECHAR * prgch,
			[in] int cch,
			[in] int cchMax,
			[out, size_is(cchMax)] OLECHAR * prgchOut,
			[out] int * pcchOut);
	};

	/*******************************************************************************************
		Interface ILgTokenizer
		Knows how to find some kind of 'tokens' in the input string.

		@h3{When to implement}
		Implement this interface if you need to plug in a special tokenizer for your language.
		First check out the standard implementations to see if one can be customized.

		@h3{When to use}
		Use this interface to break strings up into smaller pieces. Particular implementations
		are optimized for certain kinds of tokens (and ways of specifying tokens).

		@h3{How to obtain an instance}
		Currently you can't. No implementations have been attempted.

		@h3{Hungarian: toker}
	*******************************************************************************************/
	DeclareInterface(LgTokenizer, Unknown, 577C6DA1-CFC1-4AFB-82B2-AF818EC2FE9F)
	{
		// Get the next token of whatever kind this tokenizer supports from the input string.
		// Set *pichMin to the offset of the first character of the token, and *pichLim
		// to the offset of the first character after the token.
		// @param cch specifies the number of characters in the input string
		// @param prgchInput points to the text to tokenize.
		// If it has more than cch characters, the rest will be ignored.
		// ENHANCE JohnT: should we pass an ichMin?
		// @exception E_FAIL if no more tokens available. Also set *pichMin and *pichLim to -1.
		[restricted] HRESULT GetToken(
			[in, size_is(cch)] OLECHAR * prgchInput,
			[in] int cch,
			[out] int * pichMin,
			[out] int * pichLim);

		// Get the start of the first token that begins at or after offset
		// ichFirst in the input string bstrInput.
		// Characters before ichFirst are not examined; the result is as if the string
		// began at ichFirst.
		// @exception E_FAIL if no token found
		[propget] HRESULT TokenStart(
			[in] BSTR bstrInput,
			[in] int ichFirst,
			[out, retval] int *pichMin);
		// Get the end of the first token that BEGINS at or after ichFirst.
		// Note: ichFirst may be the result obtained from a previous call to TokenStart,
		// rather than the value passed to TokenStart, but to obtain the limit of the same
		// token it must not be larger than that. In other words, this method does NOT
		// find the first end-of-token at or after ichFirst: it must find a complete token
		// starting there.
		// @exception E_FAIL if no token found
		[propget] HRESULT TokenEnd(
			[in] BSTR bstrInput,
			[in] int ichFirst,
			[out, retval] int *pichLim);
		// ENHANCE JohnT: should we also have a method that returns the token itself as a
		// newly allocated BSTR?
	};

	// Standard MS Word spell checker options
	// Many implementations will ignore some of these
	// ENHANCE JohnT: any others we need?
	typedef [v1_enum] enum LgSpellCheckOptions
	{
		fsplcNil                   = 0x00000,
		fsplcSuggestFromUserDict   = 0x00001,
		fsplcIgnoreAllCaps         = 0x00002,
		fsplcIgnoreMixedDigits     = 0x00004,
		fsplcIgnoreRomanNumerals   = 0x00008,
		fsplcFindUncappedSentences = 0x00010,
		fsplcFindMissingSpaces     = 0x00020,
		fsplcFindRepeatWord        = 0x00040,
		fsplcFindExtraSpaces       = 0x00080,
		fsplcFindSpacesBeforePunc  = 0x00100,
		fsplcFindSpacesAfterPunc   = 0x00200,
		fsplcFindInitialNumerals   = 0x00800,
		fsplcQuickSuggest          = 0x02000,
		fsplcUseAllOpenUdr         = 0x04000,
		fsplcSglStepSugg           = 0x10000,
		fsplcIgnoreSingleLetter    = 0x20000,
	} LgSpellCheckOptions;

	// Standard MS Word spell checker result codes. Most implementations
	// will not generate all of these.
	typedef [v1_enum] enum LgSpellCheckResults
	{
		scrsNoErrors                    =  0,  /* All buffer processed. */
		scrsUnknownInputWord            =  1,  /* Unknown word. */
		scrsReturningChangeAlways       =  2,  /* Returning a Change Always word. */
		scrsReturningChangeOnce         =  3,  /* Returning a Change Once word. */
		scrsInvalidHyphenation          =  4,  /* Error in hyphenation point. */
		scrsErrorCapitalization         =  5,  /* Cap pattern not valid. */
		scrsWordConsideredAbbreviation  =  6,  /* Word is considered an abbreviation. */
		scrsHyphChangesSpelling         =  7,  /* Word changes spelling when not hyphenated. */
		scrsNoMoreSuggestions           =  8,  /* All methods used. */
		scrsMoreInfoThanBufferCouldHold =  9,  /* More return data than fit in buffer. */
		scrsNoSentenceStartCap          = 10,  /* Start of sentence was not capitalized. */
		scrsRepeatWord                  = 11,  /* Repeat word found. */
		scrsExtraSpaces                 = 12,  /* Too many spaces for context.*/
		scrsMissingSpace                = 13,  /* Too few spaces between words or sentences. */
		scrsInitialNumeral              = 14,  /* Word starts with numeral &
												  fsplcFindInitialNumerals set. */
	} LgSpellCheckResults;

	/*******************************************************************************************
		Interface ILgSpellChecker
		Knows how to check spelling and related functions.
		Loosely based on the ISpellCheckerWideChar interface which Shon implemented in the
		Santa Fe prototype for access to MS Word spelling checkers. The intent is that this
		interface could be easily implemented using that; but this interface assumes that
		writing system-dependent initialization info is provided independent of the client.

		ENHANCE JohnT: How should we handle customization? Should the possibility of a "user
		dictionary" be explicit in the interface, or is that just something that some
		implementations provide? Some of our spelling checkers will probably allow the
		user to add directly to the main dictionary (e.g., if it is their own WFI).

		@h3{When to implement}
		Usually you will use a standard implementation of this interface. If none of them can
		be customized to suit your language you could consider programming a new one (and
		perhaps adding it to the list of standard ones, if it is custimizable).

		@h3{When to use}
		Use this interface when you need to implement spelling checking.

		@h3{How to obtain an instance}
		Currently you can't. No implementations have been attempted. Eventually you will obtain
		one from ${ILgSpellCheckFactory#get_Checker}

		@h3{Hungarian: spchk}
	*******************************************************************************************/
	DeclareInterface(LgSpellChecker, Unknown, E3661AF5-26C6-4907-9243-610DAD84D9D4)
	{
		// Initialize the checker with a custom dictionary file path.
		HRESULT Init(
			[in] LPCOLESTR pszwCustom);

		// Set a combination of the options in LgSpellCheckOptions
		HRESULT SetOptions(
			[in] int grfsplc);

		// Check the specified input buffer. *pscrs gets a member of the LgSpellCheckResults
		// enumeration above. If a problem is found, pbstrBad contains the text to show to the
		// user as the wrong word, and pichMinBad/pichLimBad indicate where it is.  If the
		// checker has previously been told to "change always" the problem word, pbstrSuggest
		// contains the previously decided replacement.
		// ENHANCE JohnT: clarify: can all LgSpellCheckResults values occur on this method?  Do
		// any others result in a pbstrSuggest?  Do we expect our spell checkers to note the
		// various grammatical errors such as sentence start capitalization? Surely "no more
		// suggestions" and "more info than buffer can hold" don't apply here?  When should
		// "change once" be used? Should it give the first suggestion along with "unknown word"?
		HRESULT Check(
			[in, size_is(cchw)] const OLECHAR * prgchw,
			[in] int cchw,
			[out] int * pichMinBad,
			[out] int * pichLimBad,
			[out] BSTR * pbstrBad,
			[out] BSTR * pbstrSuggest,
			[out] int * pscrs);

		// Get a suggestion for the given word. Repeated calls obtain other suggestions;
		// Call once with fFirst set true, then call with fFirst false until you want no more
		// suggestions or until the method answers false.
		// ENHANCE JohnT: is this in fact how the interface is supposed to be used? What if the
		// most recent call was for a different word, but fFirst is not true?
		HRESULT Suggest(
			[in, size_is(cchw)] const OLECHAR * prgchw,
			[in] int cchw,
			[in] ComBool fFirst,
			[out] BSTR *pbstrSuggest);

		// Ignore all subsequent occurrences of the argument word (for the lifetime of this
		// spelling check object, or until FlushIgnoreList is called).
		HRESULT IgnoreAll(
			[in] LPCOLESTR pszw);

		// Record that the user wants pszwDst to be the preferred replacement for pszwSrc.
		// Henceforth, when pszwSrc is detected as a spelling error, pszwDst will be the
		// suggestion, and the result code for Check will be scrsReturningChangeAlways.
		// If fAll is true this happens for all subsequent occurrences of pszwSrc (for the
		// lifetiem of this object, or until FlushChangeList is called); if false,
		// it happens only for the next single occurrence (and the result code will be
		// scrsReturningChangeOnce).
		// ENHANCE JohnT: is fAll useful? I have never seen a spelling dialog with an option
		// that corresponds to change once.
		HRESULT Change(
			[in] LPCOLESTR pszwSrc,
			[in] LPCOLESTR pszwDst,
			ComBool fAll);

		// Add the specified string to the user dictionary. It should never again be
		// reported as a spelling error, either by this checker, or any new one that is
		// subsequently initialized from the same user dictionary.
		// Fails if a user dictionary was not specified or that capability is not supported.
		// Some engines may in fact add the word to a master dictionary (e.g, the WFI).
		// ENHANCE JohnT: clarify: what is the behavior if another checker has previously been
		// created using the same dictionary? Will it notice the change? Do we care?
		HRESULT AddToUser(
			[in] LPCOLESTR pszw);

		// Discard any requests that have been made for words to be ignored.
		HRESULT FlushIgnoreList();
		// Discard any requests that have been made for words to be automatically
		// changed. (ENHANCE JohnT: clarify: what on earth does fAll mean here!!)
		HRESULT FlushChangeList(
			[in] ComBool fAll);
	};

	/*******************************************************************************************
		Interface ILgSpellCheckFactory

		Since ISpellCheckers are transient objects good for one spell check, this is the
		persistent object that gets stored in the writing system.

		Hungarian: spchk
	*******************************************************************************************/
	DeclareInterface(LgSpellCheckFactory, Unknown, 9F9298F5-FD41-44B0-83BA-BED9F56CF974)
	{
		// Get a checker object ready to be used for one spell-check session.
		[propget] HRESULT Checker(
			[out, retval] ILgSpellChecker ** ppspchk);
	};

	/*******************************************************************************************
		Interface ILgNumericEngine
		Knows how to convert numbers to and from binary.

		ENHANCE JohnT: do we need something analogous to Locales? For example, Australia, US
		and Great Britain all use English, but use different date and currency
		conventions. They don't actually do numbers differently, but other similar
		situations could require that.

		ENHANCE JohnT: do we need similar routines for doubles? Do they have language-specific
		formats?

		ENHANCE JohnT: do we need a similar engine (or part of this?) for currencies and dates?

		ENHANCE JohnT: do we need this at all? Or can we just record a locale in the writing
		system and use standard system number formatting?

		@h3{When to implement}
		Only if you need a number representation that can't be done with any of the standard
		approaches.

		@h3{When to use}
		Use this interface when you need to convert numbers to and from binary in a language-
		dependent way.

		@h3{How to obtain an instance}
		If we decide to proceed with this notion, there will need to be a method on writing
		system to return one. For now the only way is to create one using CoCreateInstance,
		with CLSID_LgNumericEngine. This creates a very simple engine that does decimal
		numbers but can be customized as to which characters it uses for decimal separator,
		thousands separator, exponential notation, and minus. You must QueryInterface
		for ISimpleInit and pass an initialization string to set up the special characters.
		For example,

		@code{
		IClassInitMonikerPtr acim;
		qcim.CreateInstance(CLSID_LgNumericEngine);
		CheckHr(qcim->InitNew((BYTE*)L"-.,E", 4 * isizeof(wchar)));
		ILgNumericEnginePtr qnumeng;
		CheckHr(qcim->QueryInterface(IID_ILgNumericEngine, (void **)&qnumeng));
		}

		@h3{Hungarian: numeng}
	*******************************************************************************************/
	DeclareInterface(LgNumericEngine, Unknown, CBBF35E1-CE39-4EEC-AEBD-5B4AAAA52B6C)
	{
		// Get the default string version of an integer, e.g., 123456, -654321
		[propget] HRESULT IntToString(
			[in] int n,
			[out, retval] BSTR * bstr);
		// Get a string representation of an integer using commas or the equivalent,
		// e.g., 12,345,678
		[propget] HRESULT IntToPrettyString(
			[in] int n,
			[out, retval] BSTR * bstr);

		// Get a binary integer corresponding to anything IntToString could output
		// Can handle leading and trailing white space.
		// ENHANCE JohnT: should it also handle output of IntToPrettyString?
		// @exception E_FAIL if result will not fit in 32 bit signed int, or if any
		// characters are not used up in the string (except white space).
		[propget] HRESULT StringToInt(
			[in] BSTR bstr,
			[out, retval] int * pn);

		// Get a binary integer corresponding to anything IntToString could output
		// Can handle leading white space; trailing is handled using pichUnused.
		// ENHANCE JohnT: should it also handle output of IntToPrettyString?
		// @param pichUnused Set to the index of the first character not processed, that is,
		// not recognized as part of a number.
		// @exception E_FAIL if result will not fit in 32 bit signed int
		[restricted] HRESULT StringToIntRgch(
			[in, size_is(cch)] OLECHAR * prgch,
			[in] int cch,
			[out] int * pn,
			[out] int * pichUnused);

		// ENHANCE JohnT: should we have hex or other base output?

		// Get the default string representation of a double, e.g., 1234.56, -6543.21
		[propget] HRESULT DblToString(
			[in] double dbl,
			[in] int cchFracDigits, // number of digits after decimal
			[out, retval] BSTR * bstr);

		// Get a string version of a double with commas or the equivalent, e.g., 12,345,678.9
		[propget] HRESULT DblToPrettyString(
			[in] double dbl,
			[in] int cchFracDigits, // number of digits after decimal
			[out, retval] BSTR * bstr);

		// Get a string representation of a double in exp notation, e.g., 1.2345E3
		[propget] HRESULT DblToExpString(
			[in] double dbl,
			[in] int cchFracDigits, // number of digits after decimal
			[out, retval] BSTR * bstr);

		// Get a double from a string (anything DblToString or DblToExpString could output)
		// Can handle leading and trailing white space.
		// ENHANCE JohnT: should it also handle output of IntToPrettyString?
		// @exception E_FAIL if any characters are not used up in the string (except white
		// space).
		[propget] HRESULT StringToDbl(
			[in] BSTR bstr,
			[out, retval] double * pdbl);

		// Get a double from a string (anything DblToString or DblToExpString could output)
		// Can handle leading white space; trailing is handled using pichUnused.
		// @param pichUnused Set to the index of the first character not processed, that is,
		// not recognized as part of a number.
		[restricted] HRESULT StringToDblRgch(
			[in, size_is(cch)] OLECHAR * prgch,
			[in] int cch,
			[out] double * pdbl,
			[out] int * pichUnused);
	};

	/*******************************************************************************************
		Interface ILgWritingSystemFactory
		Knows how to find an writing system engine from an writing system integer or an ICU
		Locale string.

		@h3{When to implement}
		Never implement this interface.

		@h3{When to use}
		Use this interface when you need to obtain writing systems and their engines.

		@h3{How to obtain an instance}

		@h3{Hungarian: wsf}
	*******************************************************************************************/
	DeclareInterface(LgWritingSystemFactory, Unknown, 22376578-BFEB-4c46-8D72-C9154890DD16)
	{
		// Get the actual writing system object for a given ICU Locale string.
		// The current implementation returns any existing writing system for that ICU Locale,
		// or creates one with default settings if one is not already known.
		// (Use ${#get_EngineOrNull} to avoid automatic creation of a new engine.)
		[propget] HRESULT Engine(
			[in] BSTR bstrIcuLocale,
			[out, retval] ILgWritingSystem ** ppwseng);

		// Get the actual writing system object for a given code, or returns NULL if one does
		// not already exist.
		// (Use ${#get_Engine} if you prefer to have an writing system created automatically if
		// one does not already exist.)
		[propget] HRESULT EngineOrNull(
			[in] int ws,
			[out, retval] ILgWritingSystem ** ppwseng);

		// Get an writing system ID from an ICULocale, or 0 if no such writing system exists.
		// Return S_FALSE if the writing system does not exist.
		HRESULT GetWsFromStr(
			[in] BSTR bstr,
			[out, retval] int * pwsId);
		// Get the ICULocale for the writing system if it exists, or NULL if it doesn't.
		// Return S_FALSE if the writing system does not exist.
		HRESULT GetStrFromWs(
			[in] int wsId,
			[out, retval] BSTR * pbstr);

		// Get the number of writing systems currently installed in the system
		[propget] HRESULT NumberOfWs(
			[out, retval] int * pcws);
		// Get the list of writing systems currrently installed in the system.
		HRESULT GetWritingSystems(
			[out, size_is(cws)] int * rgws,
			[in] int cws);

		// Get the char prop engine for a particular WS
		[propget] HRESULT CharPropEngine(
			[in] int ws,
			[out, retval] ILgCharacterPropertyEngine ** pplcpe);
		// Get the renderer for a particular WS
		[propget] HRESULT Renderer(
			[in] int ws,
			[in] IVwGraphics * pvg,
			[out, retval] IRenderEngine ** ppre);
		// Get the renderer for a particular Chrp
		[propget] HRESULT RendererFromChrp(
			[in] IVwGraphics * pvg,
			// should be [in, ref] possibly?
			[in, out] LgCharRenderProps * pchrp,
			[out, retval] IRenderEngine ** ppre);

		// Get the default user interface writing system.
		[propget] HRESULT UserWs(
			[out, retval] int * pws);
		// Set the default user interface writing system. This should usually be done very early in
		// the lifecycle of the WSF.
		[propput] HRESULT UserWs(
			[in] int ws);
	};

/*******************************************************************************************
	Interface ILgKeymanHandler

	An interface that manages Keyman, being able to invoke a keyboard, find out which
	one is active, find out which keyboards are available, return the windows message that
	Keyman sends when a keyboard is selected, and so forth.

	@h3{When to implement}
	The standard implementation should suffice.

	@h3{When to use}
	Whenever you want to manipulate or query Keyman

	@h3{Hungarian: lkh}
*******************************************************************************************/
DeclareInterface(LgKeymanHandler, Unknown, 3F42144B-509F-4def-8DD3-6D8D26677001)
{

	// Initialize the Keyboard handler. Set fForce to re-initialize even if already
	// initialized, for example, if a keyboard has been added or removed.
	// All data is static, so it is only necessary to call this for one instance.
	// Actually, it is not strictly necessary to call it at all, as other methods will
	// do so if necessary.
	HRESULT Init(
		[in] ComBool fForce);

	// Gracefully shut down the keyboard handler. We need this for calling from .NET so
	// that we don't rely on garbage collection.
	HRESULT Close();

	// Obtain the number of keyboard layouts currently avaiable.
	[propget] HRESULT NLayout(
		[out, retval] int * pclayout);
	// Obtain the ith layout name.
	[propget] HRESULT Name(
		[in] int ilayout,
		[out, retval] BSTR * pbstrName);
	// Get/Set the active keyboard.
	[propget] HRESULT ActiveKeyboardName(
		[out, retval] BSTR * pbstrName);
	[propput] HRESULT ActiveKeyboardName(
		[in] BSTR bstrName);
	// Return the windows message (obtained from RegisterWindowsMessage("WM_KMSELECTLANG").
	[propget] HRESULT KeymanWindowsMessage(
		[out, retval] int * pwm);
	// Enhance JohnT: might be useful to add GetKeymanVersion, StartKeyman.
};

/*******************************************************************************************
	Interface ILgTextServices

	Provide access to TSF functionality wrapped in easy-to-call methods.

	@h3{When to implement}
	Clients should not implement this interface. There is a standard implementation in
	Language.dll.

	@h3{When to use}
	When TSF related functionality is needed, especially from C# code which does not have
	a built-in access path.

	@h3{How to obtain an instance}
	Use CoCreateInstance, CLSID_LgTextServices. Or use the CreateInstance() method of a
	smart pointer.

	@h3{Hungarian: lts}
*******************************************************************************************/
DeclareInterface(LgTextServices, Unknown, 5B6303DE-E635-4DD7-A7FC-345BEEF352D8)
{
	// Set the system keyboard and TSF language.
	HRESULT SetKeyboard(
		[in] int nLcid,
		[in] BSTR bstrKeymanKbd,
		[in, out] int * pnActiveLangId,
		[in, out] BSTR * pbstrActiveKeymanKbd,
		[in, out] ComBool * pfSelectLangPending
		);
};

/*******************************************************************************************
	Interface ILgCodePageEnumerator

	An interface that allows retrieving a list of the code pages installed on the system,
	with names suitable for displaying in a combo box.

	@h3{When to implement}
	The standard implementation should suffice.

	@h3{When to use}
	Whenever you want to retrieve a list of available code pages.

	@h3{Hungarian: lcpe}
*******************************************************************************************/
DeclareInterface(LgCodePageEnumerator, Unknown, 2CFCF4B7-2FFE-4CF8-91BE-FBB57CC7782A)
{

	// Initialize enumerator. This default initializer gives all known code pages.
	// We may eventually have others that allow them to be limited.
	HRESULT Init();

	// Get the next code page. When there are no more, sets pnId to 0 and pbstrName to null.
	HRESULT Next(
		[out] int * pnId,
		[out] BSTR * pbstrName);
};

/*******************************************************************************************
	Interface ILgLanguageEnumerator

	An interface that allows retrieving a list of the languages installed on the system,
	with names suitable for displaying in a combo box.

	@h3{When to implement}
	The standard implementation should suffice.

	@h3{When to use}
	Whenever you want to retrieve a list of available languages.

	@h3{Hungarian: lcpe}
*******************************************************************************************/
DeclareInterface(LgLanguageEnumerator, Unknown, 746A16E1-0C36-4268-A261-E8012B0D67C5)
{

	// Initialize enumerator. This default initializer gives all installed languages.
	// We may eventually have others that allow them to be limited.
	HRESULT Init();

	// Get the next language. When there are no more, sets pnId to 0 and pbstrName to null.
	// For a language unsupported by the OS, it returns the id along with E_FAIL.
	HRESULT Next(
		[out] int * pnId,
		[out] BSTR * pbstrName);
};

/*******************************************************************************************
	Interface ILgIcuConverterEnumerator

	An interface that allows retrieving a list of the converters that ICU supports.
	Eventually it may also support creating converters, though our preferred approach is
	to use the EncConverters interface.

	@h3{When to implement}
	The standard implementation should suffice.

	@h3{When to use}
	To retrieve a list of available converters.

	@h3{Hungarian: lcpe}
*******************************************************************************************/
DeclareInterface(LgIcuConverterEnumerator, Unknown, 8E6D558E-8755-4EA1-9FF6-039D375312E9)
{
	// Get the count of available converters.
	[propget] HRESULT Count(
		[out, retval] int * pcconv);

	// Get the nth converter name.
	[propget] HRESULT ConverterName(
		[in] int iconv,
		[out,retval] BSTR * pbstrName);

	// Get the ID string that identifies the converter to ICU.
	[propget] HRESULT ConverterId(
		[in] int iconv,
		[out,retval] BSTR * pbstrName);

};

/*******************************************************************************************
	Interface ILgIcuTransliteratorEnumerator

	An interface that allows retrieving a list of the transliterators that ICU supports.
	Eventually it may also support creating transliterators, though our preferred approach is
	to use the EncConverters interface.

	@h3{When to implement}
	The standard implementation should suffice.

	@h3{When to use}
	To retrieve a list of available converters.

	@h3{Hungarian: lcpe}
*******************************************************************************************/
DeclareInterface(LgIcuTransliteratorEnumerator, Unknown, 50F2492C-6C46-48BA-8B7F-5F04153AB2CC)
{
	// Get the count of available converters.
	[propget] HRESULT Count(
		[out, retval] int * pctrans);

	// Get the nth converter name.
	[propget] HRESULT TransliteratorName(
		[in] int itrans,
		[out,retval] BSTR * pbstrName);

	// Get the ID string that identifies the transliterator to ICU.
	[propget] HRESULT TransliteratorId(
		[in] int iconv,
		[out,retval] BSTR * pbstrName);
};

/*******************************************************************************************
	Interface ILgLocaleEnumerator

	An interface that allows retrieving a list of the available ICU locales on the system.

	@h3{When to implement}
	The standard implementation should suffice.

	@h3{When to use}
	To retrieve a list of available locales.

	@h3{Hungarian: lcpe}
*******************************************************************************************/
DeclareInterface(LgIcuLocaleEnumerator, Unknown, 08F649D0-D8AB-447B-AAB6-21F85CFA743C)
{
	// Get the count of available converters.
	[propget] HRESULT Count(
		[out, retval] int * pclocale);

	// Get the nth locale name. (ICU getName.)
	[propget] HRESULT Name(
		[in] int iloc,
		[out, retval] BSTR * pbstrName);

	// Get the nth locale language identifier. (ICU getLanguage.)
	[propget] HRESULT Language(
		[in] int iloc,
		[out, retval] BSTR * pbstrName);

	// Get the nth locale country. (ICU getCountry.)
	[propget] HRESULT Country(
		[in] int iloc,
		[out, retval] BSTR * pbstrName);

	// Get the nth locale variant. (ICU getVariant.)
	[propget] HRESULT Variant(
		[in] int iloc,
		[out, retval] BSTR * pbstrName);

	// Get the display name of the locale represented by this enumerator.
	// The display name will be in the selected locale if it is non-empty;
	// pass null or an empty string to get the system default locale.
	[propget] HRESULT DisplayName(
		[in] int iloc,
		[in] BSTR bstrLocaleName,
		[out, retval] BSTR * pbstrName);

};

/*******************************************************************************************
	Interface ILgIcuResourceBundle

	An interface that represents an instance of an ICU ResourceBundle object.

	@h3{When to implement}
	The standard implementation should suffice.

	@h3{When to use}
	To retrieve information from ICU resources; this is useful for things like enumerating
	the countries and locales known to the system.

	@h3{Hungarian: lcpe}
*******************************************************************************************/
DeclareInterface(LgIcuResourceBundle, Unknown, C243C72A-0D15-44D9-ABCB-A6E875A7659A)
{
	// Initialize the root resource bundle. The path may be null to use the standard
	// FieldWorks ICU data directory.
	HRESULT Init(
		[in] BSTR bstrPath,
		[in] BSTR locale);

	// Get the key of the bundle. (Icu getKey.)
	[propget] HRESULT Key(
		[out, retval] BSTR * pbstrKey);

	// Get the 'string' of the bundle. (Icu getString.)
	[propget] HRESULT String(
		[out, retval] BSTR * pbstrString);

	// Get the name of the bundle. (Icu getName.) Note that the Key and String of the
	// bundle are often more useful.
	[propget] HRESULT Name(
		[out, retval] BSTR * pbstrName);

	// Get another resource bundle for a subsection of this one. (Icu get.)
	// If the resource does not exist, this sets pprb to NULL.
	[propget] HRESULT GetSubsection(
		[in] BSTR bstrSectionName,
		[out, retval] ILgIcuResourceBundle ** pprb);

	// Determine whether the bundle has more sub-resources accessible through get_Next.
	// (Icu hasNext.)
	[propget] HRESULT HasNext(
		[out, retval] ComBool * pfHasNext);

	// Get the 'next' subsection and advance. The first call to this retrieves the first
	// item. Call only while HasNext returns true. (Icu getNext.)
	[propget] HRESULT Next(
		[out, retval] ILgIcuResourceBundle ** pprb);

	// Get the size of the bundle. (Icu getSize.)
	[propget] HRESULT Size(
		[out, retval] int * pcrb);

	// Get the ith string. (Icu getStringEx.)
	[propget] HRESULT StringEx(
		[in] int irb,
		[out, retval] BSTR * pbstr);
};

/*******************************************************************************************
	Interface IRegexMatcher

	An interface that allows C# objects to perform regular expression searches using ICU.

	@h3{When to implement}
	The standard implementation should be used.

	@h3{When to use}
	To search a string for a pattern.

	@h3{Hungarian: lcpe}
*******************************************************************************************/
DeclareInterface(RegexMatcher, Unknown, 6C62CCF0-4EE1-493C-8092-319B6CFBEEBC)
{
	// Initialize the pattern to be searched. This must be done before calling other
	// methods.
	HRESULT Init(
		[in] BSTR bstrPattern,
		[in] ComBool fMatchCase);
	// This oddly named method is named for the one in the real RegexMatcher. It sets the
	// input that will be searched.
	HRESULT Reset(
		[in] BSTR bstrInput);
	// This finds the first occurrence of the pattern in the input (starting at ich),
	// if any, and returns a boolean indicating whether it was found. The match may start
	// exactly at ich.
	HRESULT Find(
		[in] int ich,
		[out, retval] ComBool * pfFound);
	// Obtain the start of the indexed group. 0 obtains the start of the entire match;
	// 1 obtains the part matched by the first () group, and so forth. Using an out-of-range
	// index returns -1. (It does not produce a bad HRESULT.)
	[propget] HRESULT Start(
		[in] int igroup,
		[out, retval] int * pich);
	// Returns the end of the indicated group. Following the ICU terminology here...
	// in our jargon it would be the limit of the group, that is, the index of the character
	// AFTER the last one matched.
	[propget] HRESULT End(
		[in] int igroup,
		[out, retval] int * pich);
	// Get any error message from a prior operation.
	[propget] HRESULT ErrorMessage(
		[out, retval] BSTR * pbstrMsg);
}

#ifndef NO_COCLASSES
/*************************************************************************************//*:Ignore
	CoClass definitions.
***********************************************************************************************/
	DeclareCoClass(RegexMatcherWrapper, 13D5C6D3-39D9-4BDA-A3F8-A5CAF6A6940A)
	{
		interface IRegexMatcher;
	};

	// A collater which takes a code page and uses the OS capabilities to compare strings
	DeclareCoClass(LgSystemCollater, E361F805-C902-4306-A5D8-F7802B0E7365)
	{
		interface ILgCollatingEngine;
	};

	// A collater based on Unicode Techinical Report 10.
	DeclareCoClass(LgUnicodeCollater, 0D9900D2-1693-481F-AA70-7EA64F264EC4)
	{
		interface ILgCollatingEngine;
	};

	// A collating engine that wraps the ICU collator.
	DeclareCoClass(LgIcuCollator, E771361C-FF54-4120-9525-98A0B7A9ACCF)
	{
		interface ILgCollatingEngine;
	};

	// The *new* standrad character property engine, which gives answers based purely on
	// Unicode (thanks to ICU).
	DeclareCoClass(LgIcuCharPropEngine, 30D75676-A10F-48FE-9627-EBF4061EA49D)
	{
		interface ILgIcuCharPropEngine;
		interface IMarshal;
	};

	// A Tokenizer that finds word breaks by looking for white space.
	// Compiler must initialize by calling its put_WritingSystem method.
	DeclareCoClass(LgCPWordTokenizer, 7CE7CE94-AC47-42A5-823F-2F8EF51A9007)
	{
		interface ILgTokenizer;
	};

	// An implementation based on locating the word form inventory for the writing system
	// and checking whether instances are in it.
	DeclareCoClass(LgWfiSpellChecker, 818445E2-0282-4688-8BB7-147FAACFF73A)
	{
		interface ILgSpellCheckFactory;
	};

	// An implementation based on MS-Word, using the Word dictionary for a major language.
	DeclareCoClass(LgMSWordSpellChecker, 5CF96DA5-299E-4FC5-A990-2D2FCEE7834D)
	{
		interface ILgSpellCheckFactory;
	};

	// A default implementation of the numeric converter interface based on knowing a
	// negative character, a thousands separator, a decimal separator, and an exponent char.
	// ENHANCE: should we further customize with a list of characters to use for the ten digits?
	DeclareCoClass(LgNumericEngine, FF22A7AB-223E-4D04-B648-0AE40588261D)
	{
		interface ILgNumericEngine;
	};

	DeclareCoClass(LgKeymanHandler, 69ACA99C-F852-4C2C-9B5F-FF83238A17A5)
	{
		interface ILgKeymanHandler;
	};
	DeclareCoClass(LgTextServices, 720485C5-E8D5-4761-92F0-F70D2B3CF980)
	{
		interface ILgTextServices;
	};
	DeclareCoClass(LgCodePageEnumerator, 9045F113-8626-41C0-A61E-A73FBE5920D1)
	{
		interface ILgCodePageEnumerator;
	};
	DeclareCoClass(LgLanguageEnumerator, B887505B-74DE-4ADC-A1D9-5553428C8D02)
	{
		interface ILgLanguageEnumerator;
	};
	DeclareCoClass(LgIcuConverterEnumerator, 9E729461-F80D-4796-BA17-086BC61907F1)
	{
		interface ILgIcuConverterEnumerator;
	};
	DeclareCoClass(LgIcuTransliteratorEnumerator, 3F1FD0A4-B2B1-4589-BC82-9CEF5BA84F4E)
	{
		interface ILgIcuTransliteratorEnumerator;
	};
	DeclareCoClass(LgIcuResourceBundle, 0DD7FC1A-AB97-4A39-882C-269760D86619)
	{
		interface ILgIcuResourceBundle;
	};
	DeclareCoClass(LgIcuLocaleEnumerator, E426656C-64F7-480E-92F4-D41A7BFFD066)
	{
		interface ILgIcuLocaleEnumerator;
	};
#endif /*!NO_COCLASSES*/
